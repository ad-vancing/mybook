# Redis 分布式锁的实现



# Redis单机分布式锁
锁的思路：用一个状态值表示锁，对锁的占用和释放通过状态值来标识。
Redis 分布式锁其实就是在系统里面占一个“坑”，其他程序也要占“坑”的时候，占用成功了就可以继续执行，失败了就只能放弃或稍后重试。
占坑一般使用 `setnx`(set if not exists)指令，只允许被一个程序占有，抢到之后，再用`expire`给锁加一个过期时间防止锁忘记了释放，使用完调用 `del `释放锁。

如返回1，则该客户端获得锁，该客户端最后可以通过`DEL`命令来释放该锁。
如返回0，表明该锁已被其他客户端取得，这时我们可以先返回或进行重试等对方完成或等待锁超时。

>如果或者要重启维护了，那会怎么样？
set是可以同时把setnx和expire合成一条指令来用的，这样可以避免在setnx之后执行expire之前进程意外crash导致意外。

这类琐最大的缺点就是它加锁时只作用在一个Redis节点上，即使Redis通过sentinel保证高可用，如果这个master节点由于某些原因发生了主从切换，那么就会出 现锁丢失的情况。
在Redis的master节点上拿到了锁；
但是这个加锁的key还没有同步到slave节点；
master故障，发生故障转移，slave节点升级为master节点；
导致锁丢失。

  Redis实现分布式锁中，过期时间如何设置的（估计是在问NX和PX如何保持一致性）
   Redis集群时分布式锁的问题（主节点锁信息未同步至从节点，主宕机）（不理想）
# 多节点 Redis 分布式锁（Redlock 算法）
https://blog.csdn.net/zjcjava/article/details/103025997
1. 获取当前时间（start）。
2. 依次向 N 个Master Redis节点请求锁。
请求锁的方式与从单节点 Redis获取锁的方式一致。为了保证在某个 Redis节点不可用时该算法能够继续运行，获取锁的操作都需要设置超时时间，需要保证该超时时间远小于锁的有效时间。这样才能保证客户端在向某个 Redis节点获取锁失败之后，可以立刻尝试下一个节点。
3. 计算获取锁的过程总共消耗多长时间（consumeTime = end - start）。如果客户端从大多数 Redis节点（>= N/2 + 1) 成功获取锁，并且获取锁总时长没有超过锁的有效时间，这种情况下，客户端会认为获取锁成功，否则，获取锁失败。
4. 如果最终获取锁成功，锁的有效时间应该重新设置为锁最初的有效时间减去 consumeTime。
5. 如果最终获取锁失败，客户端应该立刻向所有 Redis节点发起释放锁的请求。

释放锁的过程比较简单：客户端向所有Redis节点发起释放锁的操作，不管这些节点当时在获取锁的时候成功与否。
>客户端发给某个Redis节点的获取锁的请求成功到达了该Redis节点，这个节点也成功执行了SET操作，但是它返回给客户端的响应包却丢失了。这在客户端看来，获取锁的请求由于超时而失败了，但在Redis这边看来，加锁已经成功了。因此，释放锁的时候，客户端也应该对当时获取锁失败的那些Redis节点同样发起请求。实际上，这种情况在异步通信模型中是有可能发生的：客户端向服务器通信是正常的，但反方向却是有问题的。

**Redlock的安全性(safety property)对系统的时钟有比较强的依赖，一旦系统的时钟变得不准确，算法的安全性也就保证不了了。**

[源码](https://github.com/redisson/redisson)
## Redis分布式锁有什么缺陷
如果有节点发生崩溃重启，还是会对锁的安全性有影响的。具体的影响程度跟Redis对数据的持久化程度有关。
>假设一共有5个Redis节点：A, B, C, D, E。设想发生了如下的事件序列：
客户端1成功锁住了A, B, C，获取锁成功（但D和E没有锁住）。
节点C崩溃重启了，但客户端1在C上加的锁没有持久化下来，丢失了。
节点C重启后，客户端2锁住了C, D, E，获取锁成功。
这样，客户端1和客户端2同时获得了锁（针对同一资源）。

分布式锁有一个超时时间，程序的执行如果超出了锁的超时时间就会出现问题。
