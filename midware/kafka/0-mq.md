>MQ工作方式

MQ如何解决分布式事务

消息幂等性如何解决

# 什么是MQ
消息队列（Message Queue，简称MQ），从字面意思上看，本质是个队列，FIFO先入先出，只不过队列中存放的内容是message而已。

主要用途：不同进程Process/线程Thread之间通信。

![](https://cdn.jsdelivr.net/gh/ad-vancing/pics/2023/202305181455908.png)

## 什么场景适合使用消息队列
消息队列中间件是分布式系统中重要的组件，主要解决应用**解耦**，**异步**，流量削锋，延迟通知、最终一致性保证、顺序消息、流式处理等等问题，实现高性能，高可用，可伸缩和最终一致性架构。
```
解耦：允许我们独立修改队列两边的处理过程而互不影响。

冗余：有些情况下，我们在处理数据的过程会失败造成数据丢失。消息队列把数据进行持久化直到它们已经被完全处理，通过这一方式规避了数据丢失风险, 确保你的数据被安全的保存直到你使用完毕

峰值处理能力：不会因为突发的流量请求导致系统崩溃，消息队列能够使服务顶住突发的访问压力, 有助于解决生产消息和消费消息的处理速度不一致的情况

异步通信：消息队列允许用户把消息放入队列但不立即处理它, 等待后续进行消费处理。
```

### 系统解耦，方便扩展
如果某个系统A产出一份核心数据，可能下游无数的其他系统都需要这份数据来实现各种业务逻辑。
然后如果要是某个下游系统突然宕机了呢？系统A的调用代码里是不是会抛异常？那系统A的同学会收到报警说异常了，结果他还要去care是下游哪个系统宕机了。所以在实际的系统架构设计中，如果全部采取直接调用下游系统发送数据这种系统耦合的方式，会严重的影响上下游系统的开发和维护效率。

系统A可以把自己的一份核心数据发到MQ里， 通过Pub/Sub 发布订阅消息模型实现一对多通信，单播升级为广播，当然当发布-订阅模型中只有 1 个订阅者时，它和队列模型就一样了。
下游哪个系统感兴趣自己去消费即可，不需要了就取消数据的消费。

结合项目情况：将订单数据推送给大数据分析平台，用于实时监控、星火数据同步

### 异步调用提高响应效率
如果有一个系统调用链路，是系统A调用系统B，一般耗时20ms；系统B调用系统C，一般耗时200ms；系统C调用系统D，一般耗时2s
因为引入了系统C调用系统D这个步骤，导致最终链路执行时间是2秒多，直接将链路调用性能降低了10倍，这就是导致链路执行过慢的罪魁祸首。
如果业务流程支持异步化的话，是不是就可以考虑把系统C对系统D的调用抽离出去做成异步化的，不要放在链路中同步依次调用。

就像点个外卖，并不需要在你支付的一瞬间立马给你找好骑手

实现思路就是系统A -> 系统B -> 系统C，直接就耗费220ms后直接成功了，系统C就是发送个消息到MQ中间件里，由系统D消费到消息之后慢慢的异步来执行这个耗时2s的业务处理。

![](https://cdn.jsdelivr.net/gh/ad-vancing/pics/2023/202305181547892.png)

结合项目情况：亲情网下单流程较长，通过MQ拆分为异步调用，缩短响应时长

### 利用消息缓存实现流量削峰
写入MQ的速度可以尽可能地快，而处理消息的速度可以适当调整（或快、或慢）。很多场景下，不会立即处理消息，这是，可以在MQ中存储message，并在某一时刻再进行处理。

假设你有一个系统，平时正常的时候每秒可能就几百个请求，系统部署在8核16G的机器的上，正常处理都是ok的，每秒几百请求是可以轻松抗住的。
但是在高峰期一下子来了每秒钟几千请求，瞬时出现了流量高峰，此时你的选择是要搞10台机器，抗住每秒几千请求的瞬时高峰吗？
如果瞬时高峰每天就那么半个小时，接着直接就降低为了每秒就几百请求，如果你线上部署了很多台机器，那么每台机器就处理每秒几十个请求就可以了，这不是有点浪费机器资源吗？

此时我们就可以在应用前端加入消息队列，平时每秒几百请求可以轻松接收消息，到了瞬时高峰期，一下涌入每秒几千的请求，就可以积压在MQ里面，然后那一台机器慢慢的处理和消费。这个短暂的高峰期积压是 ok 的，因为等高峰期过了，再消费一段时间，MQ里积压的数据就消费完毕了。

如果业务场景允许异步削峰，高峰期积压一些请求在MQ里，然后高峰期过了，后台系统在一定时间内消费完毕不再积压的话，那就很适合用这种技术方案。
一般在秒杀活动中应用广泛：1.可以控制活动人数，超过此一定阀值的订单直接丢弃2.可以缓解短时间的高流量压垮应用(应用程序按自己的最大处理能力获取订单)。

结合项目情况：对于大量订单数据同步（流量等订单）？

## 使用消息队列存在的问题
- 系统可用性降低  
MQ 可能挂掉，导致整个系统崩溃
- 复杂性变高  
如何保证消息队列的高可用、怎么保证不发重复消息、不漏发消息，保证消息没有重复消费、不漏消费？怎么处理消息丢失的情况？怎么保证消息传递的顺序性？
- 一致性问题  
A 系统处理完了直接返回成功了，人都以为你这个请求就成功了；但是问题是，要是 BCD 三个系统那里，BD 两个系统写库成功了，结果 C 系统写库失败了，数据就不一致了。

所以消息队列实际是一种非常复杂的架构，引入它有很多好处，但是也得针对它带来的坏处做各种额外的技术方案和架构来规避掉，做好之后，你会发现系统复杂度提升了一个数量级，也许是复杂了 10 倍。但是关键时刻还是得用的。

# 不同消息队列产品的比较
目前使用较多的消息队列有ActiveMQ，RabbitMQ，ActiveMQ，ZeroMQ，Kafka，MetaMQ，RocketMQ。  
大部分都支持集群化、高可用部署架构、消息高可靠支持。  
对于MQ来说，网络传输只是它的一部分，更多需要处理的是消息存储、路由、Broker服务发现和查找、事务、消费模式 （ack、重投等）、集群服务等。
[Kafka、ActiveMQ、RabbitMQ、RocketMQ 有什么优缺点？](https://blog.csdn.net/ThinkWon/article/details/104588612)

![](https://www.javazhiyin.com/wp-content/uploads/2020/04/java3-1587280402.png)

## ActiveMQ 
ActiveMQ 和 RabbitMQ 都是AMQP 的一种具体实现，具体是基于STOMP协议。  
AcitveMQ 和 RabbitMQ 都支持 持久性或非持久性的信息交付。  
默认情况下，消息会存储到磁盘中，可以保证消息队列重启时数据的一致，避免消息的丢失。它们还支持同步和异步发送消息，前者对延迟有实质性影响。为了保证交付，这些代理使用消息确认，这也导致巨大的延迟代价。

老牌消息队列处理服务，已经在很多产品中得到应用，实现了JMS1.1规范，可以和spring-jms轻松融合，实现了多种协议，不够轻巧（源代码比RocketMQ多），对队列数较多的情况支持不好。

缺点：它的队列，只支持简单的JSON格式文本，对于JSON嵌套类的格式文本，一旦消息提交到服务器后，消费端程序无法及时取到消息。
服务器时不时产生拥堵，有时候几分钟，有时候十几分钟，消费端才会拿到数据。

## RabbitMQ
是使用Erlang语言开发的开源消息队列系统，基于`AMQP协议`来实现。RabbitMQ、Kafka 使用自己的协议。  
AMQP的主要特征是面向消息、队列、路由（ Exchange 包括点对点和发布/订 阅）、可靠性、安全。  
支持 AMQP（二进制），STOMP（文本），MQTT（二进制），HTTP（里面包装其他协议）等协议。  
更多用在企业系统内，对数据一致性、稳定性和可靠性要求很高的场景，对性能和吞吐量的要求还在其次。中小型公司使用RabbitMQ的比较多。
同时有非常完善便捷的后台管理界面可以使用。还支持集群化、高可用部署架构、消息高可靠支持，功能较为完善。
RabbitMQ的开源社区很活跃，较高频率的迭代版本，来修复发现的bug以及进行各种优化。结合erlang语言本身的并发优势，性能较好，但是不利于做二次开发和维护。
缺点：是基于erlang语言开发的，所以导致较为难以分析里面的源码，也较难进行深层次的源码定制和改造，毕竟需要较为扎实的erlang语言功底才可以。
在有大量消息堆积的情况下性能会下降。

>AMQP，即Advanced Message Queuing Protocol，高级消息队列协议，是应用层协议的一个开放标准，为面向消息的中间件设计。消息中间件主要用于组件之间的解耦，消息的发送者无需知道消息使用者的存在，反之亦然。 AMQP的主要特征是面向消息、队列、路由（包括点对点和发布/订阅）、可靠性、安全。 RabbitMQ是一个开源的AMQP实现，服务器端用Erlang语言编写，支持多种客户端，如：Python、Ruby、.NET、Java、JMS、C、PHP、ActionScript、XMPP、STOMP等，支持AJAX。用于在分布式系统中存储转发消息，在易用性、扩展性、高可用性等方面表现不俗。


## Kafka
来自linkedin，提供：
- 数据的发布和订阅能力（消息队列）
- 数据的分布式存储能力（存储系统）
- 数据的实时处理能力（流处理引擎）

前两者奠定kafka作为一个消息系统的基础。

主要特点是为超高吞吐量（能做到单机每秒几十万的吞吐量）的实时日志采集、实时数据同步、实时数据计算等场景来设计。适合产生大量数据的互联网服务的数据收集业务。 

![](https://cdn.jsdelivr.net/gh/ad-vancing/pics/2023/202305181531818.png)
[Kafka 不同于 ActiveMQ 和 RabbitMQ 最核心的地方是它的**消息模型**](https://mp.weixin.qq.com/s?__biz=MzU2MTM4NDAwMw==&mid=2247490102&idx=1&sn=68d55b3c5ac74038c76d6837b862a11c&chksm=fc78c51acb0f4c0cd5a1d6ceedb9948f82d48791ab789e9edfd6e83e34fbad1ace5749bee203&scene=178&cur_album_id=1763234202604388353#rd) ——基于Pull的模式来处理消息消费。 

## RocketMQ
是阿里开源的消息中间件，基于Java语言开发，具有高吞吐量、高可用性、适合大规模分布式系统应用的特点，同时还支持分布式事务等特殊场景。RocketMQ思路起源于 Kafka，但并不是Kafka的一个Copy，它对消息的可靠传输及事务性做了优化，目前在阿里集团被广泛应用于交易、充值、流计算、消息推送、日志 流式处理、binglog分发等场景。
https://www.cnblogs.com/xuwc/p/9034352.html

## ZeroMQ
是一个网络编程的Pattern库，将常见的网络请求形式（分组管理，链接管理，发布订阅等）模式化、组件化，简而言之socket之 上、MQ之下。
但只是一个异步消息库，在套接字的基础上提供了类似于消息代理的机制。
使用 ZeroMQ 的话，需要对自己的业务代码进行改造，不利于服务解耦。 

## Pulsar


# 云厂商产品
[Amazon Simple Notification Service (SNS)](https://aws.amazon.com/cn/sns/)

[腾讯云消息队列（Cloud Message Queue，CMQ）](https://cloud.tencent.com/product/cmq?from=20065&from_column=20065)

[阿里云](https://www.aliyun.com/product/ons)



# 设计一个mq
- base   
  一发一存一消费 -> 两次 RPC(（Dubbo 或者 Thrift）) + 消息转储(ArrayBlockingQueue)

- 生产环境的需求  
  如：高可用(服务与消息存储的水平可扩展)和高可靠，性能，一致性
  - rpc通信：  
    可以基于 Netty 来做底层通信，用 Zookeeper、Euraka 等来做注册中心，然后自定义一套新的通信协议（类似 Kafka），也可以基于 AMQP 这种标准化的 MQ 协议来做实现（类似 RabbitMQ）。对比直接用 RPC 框架，这种方案的定制化能力和优化空间更大。
  - 存储结构设计高性能保证：  
    追加写日志文件（数据部分） + 索引文件的方式（很多主流的开源 MQ 都是这种方式）。  
    索引设计上可以考虑稠密索引或者稀疏索引，查找消息可以利用跳转表、二分查找等，还可以通过操作系统的页缓存、零拷贝等技术来提升磁盘文件的读写性能。
      
  - Broker 服务的高可用 & 存储方案的高可用 
    可水平扩展进行集群部署，进一步通过服务自动注册与发现、负载均衡、超时重试机制、发送和消费消息时的 ack 机制来保证。    
    分布式场景下数据复制和一致性方案（类似 Zab、Raft等协议），并实现自动故障转移。   
    引用主流的 DB、分布式文件系统、带持久化能力的 KV 系统，它们都有自己的高可用方案。       
  
    


[参考推荐到点](https://mp.weixin.qq.com/s?__biz=MzU2MTM4NDAwMw==&mid=2247488812&idx=1&sn=1e23afce50441bcf594c001f0965306b&chksm=fc78ca00cb0f4316e4c8583b84556c62574b50adaa8511d932459396944e9babeee9d141086b&scene=178&cur_album_id=1763234202604388353#rd)  





