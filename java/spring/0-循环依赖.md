# 什么是循环依赖？
A依赖B的同时B也依赖了A

# 什么情况下循环依赖可以被处理？
依赖注入的方式不能全是构造器注入的方式（很多博客上说，只能解决setter方法的循环依赖，这是错误的）  
如：A中注入B的方式为setter方法，B中注入A的方式为构造器 是可以被处理；
但 B中注入A的方式为setter方法，A中注入B的方式为构造器？

# Spring是如何解决的循环依赖
前提：
1. 不全是构造器方式的循环依赖
2. 必须是单例

解决循环依赖的问题就是三级缓存，通过三级缓存提前拿到未初始化完全的对象。

在为B中注入A时已经将三级缓存中的工厂取出，并从工厂中获取到了一个对象A放入到了二级缓存中。

## 简单的循环依赖
Spring在创建Bean的时候默认是按照自然排序来进行创建的，第一步Spring会去创建A（Spring默认按照字母排序创建Bean）。

Spring在创建Bean的过程中分为三步:
1. 实例化，new一个对象，对应方法：AbstractAutowireCapableBeanFactory中的createBeanInstance方法
2. 属性注入，为实例化中new出来的对象填充属性，对应方法：AbstractAutowireCapableBeanFactory的populateBean方法
3. 初始化，执行aware接口中的方法，初始化方法，完成AOP代理。对应方法：AbstractAutowireCapableBeanFactory的initializeBean，执行aware接口中的方法，初始化方法，完成AOP代理。

缓存中尝试去获取Bean，整个缓存分为三级：
- Map<String, Object> singletonObjects，一级缓存中存储的是**已经完全创建好了的单例Bean(实例化、初始化都完成)，单例池**；
- Map<String, Object> earlySingletonObjects，**完成实例化，但是还未进行属性注入及初始化的对象**；
- Map<String, ObjectFactory<?>> singletonFactories，提前暴露的**一个单例工厂**，二级缓存中存储的就是从这个工厂中获取到的对象

1. 在完成Bean的实例化后，属性注入之前Spring将Bean包装成一个工厂添加进了三级缓存中；

2. 当**A完成了实例化并添加进了三级缓存**后，就要开始为A进行属性注入了，在注入时发现A依赖了B，转而去实例化B；  

3. 又发现B需要注入A，会去调用getBean(a)，从一级到三级缓存查询A，**此时getBean(a)可以从三级缓存中通过对象工厂拿到A**，把A放入二级缓存，同时删除三级缓存中的A，此时，B已经实例化并且初始化完成，把B放入一级缓存。

   >而且此时注入到B中的A是通过getEarlyBeanReference方法提前暴露出去的一个对象，**还不是一个完整的Bean**。  
getEarlyBeanReference方法，在没有aop情况下啥都没干，**直接将实例化阶段创建的对象A返回了**;  
有 aop 的情况下（对A进行了AOP代理时），getEarlyBeanReference将返回一个代理后的对象，而不是实例化阶段创建的对象，这样就意味着B中注入的A将是一个代理对象而不是A的实例化阶段创建后的对象。

4. 接着继续创建A，顺利从一级缓存拿到实例化且初始化完成的B对象，A对象创建也完成，删除二级缓存中的A，同时把A放入一级缓存，最后，一级缓存中保存着实例化、初始化都完成的A、B对象。

**结论：创建B时，向B中提前注入了一个没有经过初始化的A类型对象**

如果都是用构造器的话，就没法分离这个操作，所以都是构造器的话就无法解决循环依赖的问题了。


[参考](https://blog.csdn.net/qq_41907991/article/details/107164508?spm=a2c6h.12873639.article-detail.6.40ba1f311tue9K)
