[能看懂么](https://blog.csdn.net/qq_41907991/article/details/107164508?spm=a2c6h.12873639.article-detail.6.40ba1f311tue9K)

# 什么是循环依赖？
A依赖B的同时B也依赖了A

# 什么情况下循环依赖可以被处理？
依赖注入的方式不能全是构造器注入的方式（很多博客上说，只能解决setter方法的循环依赖，这是错误的）  
如：A中注入B的方式为setter方法，B中注入A的方式为构造器 是可以被处理；
但 B中注入A的方式为setter方法，A中注入B的方式为构造器？

# Spring是如何解决的循环依赖

## 简单的循环依赖
Spring在创建Bean的时候默认是按照自然排序来进行创建的，第一步Spring会去创建A（Spring默认按照字母排序创建Bean）。

Spring在创建Bean的过程中分为三步:
1. 实例化，new一个对象，对应方法：AbstractAutowireCapableBeanFactory中的createBeanInstance方法
2. 属性注入，为实例化中new出来的对象填充属性，对应方法：AbstractAutowireCapableBeanFactory的populateBean方法
3. 初始化，执行aware接口中的方法，初始化方法，完成AOP代理。对应方法：AbstractAutowireCapableBeanFactory的initializeBean，执行aware接口中的方法，初始化方法，完成AOP代理。

缓存中尝试去获取Bean，整个缓存分为三级：
- singletonObjects，一级缓存中存储的是已经完全创建好了的单例Bean，单例池；
- earlySingletonObjects，完成实例化，但是还未进行属性注入及初始化的对象；
- singletonFactories，提前暴露的一个单例工厂，二级缓存中存储的就是从这个工厂中获取到的对象

在完成Bean的实例化后，属性注入之前Spring将Bean包装成一个工厂添加进了三级缓存中（A完成了实例化并添加进了三级缓存）

当A完成了实例化并添加进了三级缓存后，就要开始为A进行属性注入了，在注入时发现A依赖了B，那么这个时候Spring又会去getBean(b)，然后反射调用setter方法完成属性注入。
因为B需要注入A，所以在创建B的时候，又会去调用getBean(a)，此时getBean可以从缓存（三级缓存singletonFactories）中获取，而且此时注入到B中的A是通过getEarlyBeanReference方法提前暴露出去的一个对象，还不是一个完整的Bean。
（在为B中注入A时已经将三级缓存中的工厂取出，并从工厂中获取到了一个对象放入到了二级缓存中）

getEarlyBeanReference方法，在没有aop情况下啥都没干，直接将实例化阶段创建的对象A返回了;

结论：创建B时，向B中提前注入了一个没有经过初始化的A类型对象

有 aop 的情况下（对A进行了AOP代理时），getEarlyBeanReference将返回一个代理后的对象，而不是实例化阶段创建的对象，这样就意味着B中注入的A将是一个代理对象而不是A的实例化阶段创建后的对象。




