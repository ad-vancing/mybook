io, nio, bio, netty框架

# 同步/异步，阻塞/肥阻塞
>所谓同步/异步，关注的是能不能同时开工。
所谓阻塞/非阻塞，关注的是能不能动。

同步阻塞，不能同时开工，也不能动。只有一条小道，一次只能过一辆车，可悲的是还TMD的堵上了。
同步非阻塞，不能同时开工，但可以动。只有一条小道，一次只能过一辆车，幸运的是可以正常通行。
异步阻塞，可以同时开工，但不可以动。有多条路，每条路都可以跑车，可气的是全都TMD的堵上了。
异步非阻塞，可以工时开工，也可以动。有多条路，每条路都可以跑车，很爽的是全都可以正常通行。

# io
>拿网络IO来说，等待的过程就是数据从网络到网卡再到内核空间。读写的过程就是内核空间和用户空间的相互拷贝。
 所以IO就包括两个过程，一个是等待数据的过程，一个是读写（拷贝）数据的过程。而且还要明白，一定不能包括操作数据的过程。

Stream/IO 是阻塞的，当线程进行读写操作时，线程会被阻塞，数据只能处理一次，不能回退。而NIO是非阻塞的。


## 同步IO
同步IO是指发起IO请求后，必须拿到IO的数据才可以继续执行。
按照程序的表现形式又分为两种：
在等待数据的过程中，和拷贝数据的过程中，线程都在阻塞，这就是同步阻塞IO。
在等待数据的过程中，线程采用死循环式轮询，在拷贝数据的过程中，线程在阻塞，这其实还是同步阻塞IO。

## 非阻塞io
非阻塞IO就是用户线程不参与`读写数据`，即数据已经拷贝到用户空间后，才去通知用户线程，一上来就可以直接操作数据了。
用户线程没有因为IO的事情出现阻塞，这就是常说的非阻塞IO。

非阻塞IO意味着发起IO请求后，可以继续往下执行。说明后续执行不依赖于IO数据，所以它肯定不是同步的。
在IO上，同步和非阻塞是互斥的，所以不存在同步非阻塞IO。

## 异步IO
用户线程的继续执行，和操作系统准备IO数据的过程是同时进行的，因此才叫做异步IO。

按照IO数据的两个过程，又可以分为两种：
1、在等待数据的过程中，用户线程继续执行，在拷贝数据的过程中，线程在阻塞，这就是异步阻塞IO。
用户线程没有参与数据等待的过程，所以它是异步的。但用户线程参与了数据读写的过程，所以它又是阻塞的。合起来就是异步阻塞IO。

2、在等待数据的过程中，和拷贝数据的过程中，用户线程都在继续执行，这就是异步非阻塞IO。
用户线程既没有参与等待过程也没有参与拷贝过程，所以它是异步的。当它接到通知时，数据已经准备好了，它没有因为IO数据而阻塞过，所以它又是非阻塞的。合起来就是异步非阻塞IO。
 
 
 我很晕～～
 

http://www.52im.net/thread-367-1-1.html