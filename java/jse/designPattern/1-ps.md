生产者-消费者模式能简化开发过程，因为它消除了生产者类与消费者类之间的代码依赖性，此外，该模式还将生产数据的过程与使用数据的过程解耦开来以简化工作负载的管理，因为这两个过程在处理数据的速率上有所不同。

# 生产者消费者的几种类型和实现方式
生产者消费者问题有两种类型，一种就是使用某种机制来保护生产者和消费者之间的同步，另外一种和Linux中的管道思路相似。
相对来说第一种类型的处理方式更为通用，大体分为三类具体的实现方式：
经典的wait(),notify()方法；[wait(),notify()的问题](https://www.jianshu.com/p/e29632593057)
await(),signal()方法；
使用阻塞队列（BlockingQueue），比如LinkedBlockingQueue


总的来说，就是能够在适当的时候阻塞"存"和"取"两个操作，以达到控制任务流程的效果。
https://www.cnblogs.com/fankongkong/p/7339848.html

# 使用好处
解耦：避免消费者直接对生产者产生依赖。

并发：生产者和消费者可以是两个独立的并发主体
处理数据的速率不同的兼容

延伸阅读：https://blog.csdn.net/u011109589/article/details/80519863

# 线程池与生产消费者模式
生产者把任务丢给线程池，线程池创建线程并处理任务，如果将要运行的任务数大于线程池的基本线程数就把任务扔到阻塞队列里，这种做法比只使用一个阻塞队列来实现生产者和消费者模式显然要高明很多，因为消费者能够处理直接就处理掉了，这样速度更快，而生产者先存，消费者再取这种方式显然慢一些。

我们的系统也可以使用线程池来实现多生产者消费者模式。比如创建N个不同规模的Java线程池来处理不同性质的任务，比如线程池1将数据读到内存之后，交给线程池2里的线程继续处理压缩数据。线程池1主要处理IO密集型任务，线程池2主要处理CPU密集型任务。

上传附件并处理，用户把文件上传到系统后，系统把文件丢到队列里，然后立刻返回告诉用户上传成功，最后消费者再去队列里取出文件处理。比如调用一个远程接口查询数据，如果远程服务接口查询时需要几十秒的时间，那么它可以提供一个申请查询的接口，这个接口把要申请查询任务放数据库中，然后该接口立刻返回。然后服务器端用线程轮询并获取申请任务进行处理，处理完之后发消息给调用方，让调用方再来调用另外一个接口拿数据。
http://ifeve.com/producers-and-consumers-mode/
