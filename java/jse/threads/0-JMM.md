Java Memory Model
Java内存模型的主要目标: 定义程序中各个变量的访问规则。   
Java线程之间的通信由Java内存模型（本文简称为JMM）控制。  
https://zhuanlan.zhihu.com/p/51613784 

所有变量的存储都在主内存，每条线程还都有自己的工作内存，线程的工作内存中保存了被该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作必须在工作内存完成，而不能直接读取主内存中的变量。不同的线程直接无法访问对方工作内存中的变量，**线程间变量的传递均需要通过主内存来完成**。 
![](https://img-blog.csdnimg.cn/2019031215212525.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpZnV4aWFuZ2Nhb2h1aQ==,size_16,color_FFFFFF,t_70)

线程间通信： 
1. 首先，线程A把本地内存A中更新过的共享变量刷新到主内存中去。 
2. 然后，线程B到主内存中去读取线程A之前已更新过的共享变量。

# Java内存模型Java Memory Model
[JSR133是个什么玩意](https://developer.aliyun.com/article/25339)

描述线程之间如何通过内存(memory)来进行交互（区别于JVM内存模型）。
它描述了一组规则或规范，通过这组规范定义了程序中各个变量（包括实例字段、静态字段和构成数组对象的元素）的访问方式，围绕`原子性、有序性和可见性`展开。
>Java内存模型（Java Memory Model ,JMM）就是一种符合内存模型规范的，屏蔽了各种硬件和操作系统的访问差异的，保证了Java程序在各种平台下对内存的访问都能得到一致效果的机制及规范。目的是解决由于多线程通过共享内存进行通信时，存在的原子性、可见性（缓存一致性）以及有序性问题。

JVM中存在一个主存区（Main Memory或Java Heap Memory），对于所有线程进行共享，而每个线程又有自己的工作内存（Working Memory，实际上是一个虚拟的概念），工作内存中保存的是主存中某些变量的拷贝，线程对所有变量的操作并非发生在主存区，而是发生在工作内存中，而线程之间是不能直接相互访问的，变量在程序中的传递，是依赖主存来完成的。
![](https://img-blog.csdnimg.cn/20190414222017110.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3plbmd4aWFudGFvMTk5NA==,size_16,color_FFFFFF,t_70)

简单说就是`每个线程都有一个工作内存，线程只可以修改自己工作内存中的数据，然后再同步回主内存（除方法中的基本类型本地变量，所有的变量都存储在主内存中），主内存由多个线程共享`。

# JMM的两条规定
1、线程对共享变量的所有操作都必须在自己的工作内存中进行，不能直接从主内存中读写；  
2、不同的线程之间无法直接访问其他线程工作内存中的变量，线程变量值的传递需要通过主内存来完成。

## 内存模型三大特性
### 原子性
>线程是CPU调度的基本单位。CPU有时间片的概念，会根据不同的调度算法进行线程调度。所以在多线程场景下，就会发生原子性问题。因为线程在执行一个读改写操作时，在执行完读改之后，时间片耗完，就会被要求放弃CPU，并等待重新调度。这种情况下，读改写就不是一个原子操作。即存在原子性问题。

JMM保证了Java 内存模型定义的[8 个来完成主内存和工作内存的交互操作](https://juejin.im/post/5cdd07dc518825696125f524#heading-5)具有原子性。  
但是 Java 内存模型允许虚拟机将没有被 volatile 修饰的 64 位数据（long，double）的读写操作划分为两次 32 位的操作来进行，即 load、store、read 和 write 操作可以不具备原子性。

>lock：作用于主内存变量，将该变量标识为一个线程独占的状态
unlock：作用于主内存变量，将独占状态释放
read：作用于主内存变量，将值拷贝到工作内存中
load：作用于工作内存中的变量，将值放到工作内存中的变量副本中
use：作用于工作内存中的变量，将值传给执行引擎
asign：作用于工作内存中的变量，将执行引擎中的值赋给工作内存中的变量
store：作用于工作内存中的变量，将值传给主内存
write：作用于主内存中的变量，将工作内存中返回的值放到主内存变量中
同时还对上述八个操作进行了一些细节的要求，比如read/load、store/write必须成对出现，未执行过lock的变量不能执行unlock操作等。

![](https://www.showdoc.com.cn/server/api/attachment/visitfile/sign/9c4287a5b91378df7913d07b78014b8e)

但是，两个线程同时对 int cnt 进行操作，load、assign、store等这一系列操作整体上看不具备原子性，那么在 线程T1 修改 cnt 并且还没有将修改后的值写入主内存，线程T2 依然可以读入旧值。可以看出，这两个线程虽然执行了两次自增运算，但是主内存中 cnt 的值最后为 1 而不是 2。因此对 int 类型读写操作满足原子性`只是说明 load、assign、store 这些单个操作具备原子性`。

AtomicInteger 能保证多个线程修改的原子性。
除了使用原子类之外，也可以使用 synchronized 互斥锁来保证操作的原子性。它对应的内存间交互操作为：lock 和 unlock，在虚拟机实现上对应的字节码指令为 monitorenter 和 monitorexit。


### 可见性
>在多核CPU，多线程的场景中，每个核都至少有一个L1 缓存。多个线程访问进程中的某个共享内存，且这多个线程分别在不同的核心上执行，则每个核心都会在各自的caehe中保留一份共享内存的缓冲。由于多核是可以并行的，可能会出现多个线程同时写各自的缓存的情况，而各自的cache之间的数据就有可能不同。
在CPU和主存之间增加缓存，在多线程场景下就可能存在缓存一致性问题，也就是说，在多核CPU中，每个核的自己的缓存中，关于同一个数据的缓存内容可能不一致。

JMM保证了当一个线程修改了共享变量的值，其它线程能够立即得知这个修改。
是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值来实现可见性的。

编程时主要有有三种实现可见性的方式：
- volatile，会强制将该变量自己和当时其他变量的状态都刷出缓存。
[volatile的原理和实现机制](https://troywu0.gitbooks.io/spark/content/javaguan_jian_zi.html)
>它是如何保证线程间的可见性的：
它保证load与use必须相邻调用，即要use这个变量，必定先执行read/load，这样每次都能获取到最新的变量值；它又保证asign与store
必须相邻调用，即在工作内存中将该变量改了之后，必定会先同步到主内存中。这样，volatile关键字实现了可见性。
- synchronized，对一个变量执行 unlock 操作之前，必须把变量值同步回主内存。
- final，被 final 关键字修饰的字段在构造器中一旦初始化完成，并且没有发生 this 逃逸（其它线程通过 this 引用访问到初始化了一半的对象），那么其它线程就能看见 final 字段的值。

对前面的线程不安全示例中的 cnt 变量`使用 volatile 修饰，不能解决线程不安全问题，因为 volatile 并不能保证操作的原子性`。


### 有序性
在本线程内观察，所有操作都是有序的。在一个线程观察另一个线程，所有操作都是无序的，无序是因为发生了指令重排序。在 Java 内存模型中，允许编译器和处理器对指令进行重排序，重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。

volatile 关键字通过添加内存屏障的方式来禁止指令重排，即重排序时不能把后面的指令放到内存屏障之前。
也可以通过 synchronized 来保证有序性，它保证每个时刻只有一个线程执行同步代码，相当于是让线程顺序执行同步代码。

总结：Java内存模型通过定义了共享内存系统中多线程程序读写操作行为的规范，使得`多CPU多级缓存导致的一致性问题、CPU时间片机制导致的原子性问题、以及处理器优化和指令重排导致的有序性问题`得以解决。


# 重排序和happens-before规则
在执行程序时为了提高性能，编译器和处理器常常会对指令做重排序。重排序分三种类型：

编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。
指令级并行的重排序。现代处理器采用了指令级并行技术（Instruction-Level Parallelism， ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。
内存系统的重排序。由于处理器使用缓存和读 / 写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。

java 编译器禁止处理器重排序是通过在生成指令序列的适当位置会插入内存屏障（重排序时不能把后面的指令重排序到内存屏障之前的位置）指令来实现的。
[扩展之volatile内存屏障](https://www.cnblogs.com/yuanqinnan/p/11162682.html)

## happens-before
我们无法就所有场景来规定某个线程修改的变量何时对其他线程可见，但是我们可以指定某些规则，这规则就是happens-before。
在JMM中，如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须存在happens-before关系。

因此，JMM可以通过happens-before关系向程序员提供跨线程的内存可见性保证（如果A线程的写操作a与B线程的读操作b之间存在happens-before关系，尽管a操作和b操作在不同的线程中执行，但JMM向程序员保证a操作将对b操作可见）。具体的定义为：
如果一个操作happens-before另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前。
两个操作之间存在happens-before关系，并不意味着Java平台的具体实现必须要按照happens-before关系指定的顺序来执行。如果重排序之后的执行结果，与按happens-before关系来执行的结果一致，那么这种重排序并不非法（也就是说，JMM允许这种重排序）。

- 程序次序规则：线程内的代码能够按先后顺序执行；
- 管程锁定规则：对于同一个锁，unlock先行发生于后面的lock，即unlock了才会lock；
- volatile变量规则：前一个对 Volatile的写操作在后一个volatile的读操作之前，即写完了才会读；
- 传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C。
- 线程启动规则：一个线程内的任何操作必需在这个线程的 start ()调用之后；
- 线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生。
- 线程终止规则：一个线程的所有操作都会在线程终止之前；
- 对象终结规则：一个对象的终结操作必需在这个对象构造完成之后。
[ happens-before规则](https://www.cnblogs.com/yuanqinnan/p/11111788.html)

`当一个变量定义为 volatile 之后，将具备：`
1.保证此变量对所有的线程的可见性，当一个线程修改了这个变量的值，volatile 保证了新值能立即同步到主内存，其它线程每次使用前立即从主内存刷新。但普通变量做不到这点，普通变量的值在线程间传递均需要通过主内存来完成。
2.禁止指令重排序优化。有volatile修饰的变量，赋值后多执行了一个“load addl $0x0, (%esp)”操作，这个操作相当于一个内存屏障（指令重排序时不能把后面的指令重排序到内存屏障之前的位置）。
[适用场景](https://www.jianshu.com/p/5584600d2569)





