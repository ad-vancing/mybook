
在java中，每次程序执行至少启动2个线程。一个是main线程，一个是垃圾收集线程。

# 线程基本方法
`thread.run()`：同步执行，此线程对象不是由”线程规划器“处理，而是由main主线程来调用run()，即必须等run()执行完后才可以执行它下面的代码。  
`thread.start()`：通知”线程规划器“此线程已经准备就绪，等待调用线程对象的run()，即让系统安排一个时间来调用run()。使得其与main线程有异步执行效果。线程对象的构造方法是被main线程调用的，而run方法是被Thread-0的线程调用的，么时候运行多线程代码是由操作系统决定。它是自动调用的方法。  
注意，对于同一个线程，多次调用它的start方法，会出现异常IllegalThreadStateException。
> start()方法是一个 native（本地）方法（就是一个java调用非java代码的接口。一个Native Method是这样一个java的方法：该方法的实现由非java语言实现
> run()方法中的语句与main方法中的语句，不是按调用顺序执行的。线程的调用具有随机性。  

`Thread.concurrentThread()` 获取当前线程（所在的方法正在被哪个线程调用）对象，可以.getName()，getId()取得线程的唯一标识。main方法所在的线程叫main线程。 
this.getName()
Thread.currentThread()与this的差异？  

thread.isAlive() 判断线程是否处于活动状态，即线程已启动且尚未终止（指线程已经启动且尚未终止，即执行.start()方法后，到线程终止的这一段时间）。  

`Thread.sleep(long )` 在指定的毫秒数内让当前线程休眠，需要catch InterruptedException。  

## 关于停止线程：
1.`Thread.stop()` 不安全，废弃，与suspend暂停，reesume恢复开始为过期方法。因为一些清理的工作可能得不到完成，还有会释放锁，导致数据同步问题。
2.`thread.interrupt()` 不会立即终止一个正在运行的线程。给线程打上一个停止的状态标记。  
当run方法完成后线程终止（废话）。  
还有通过抛异常来终止（最好，因为异常可以向上抛，事件得以传播）。
还有使用interrupt()结合return来终止。

`Thread.interrupted()` 判断当前线程（运行thread.interrupted()的线程，在main方法里，则是main线程）是否是中断状态，执行后将清除中断标志（再次调用可能得到false）。
`thread.isInterrupted()` 判断当前线程是否是中断状态，执行后不会清除中断标志（再次调用也得到true）。  

还有一种特殊情况就是，在你中断一个线程时，这个线程恰巧没有在运行，它可能是因为竞争对象的监视器“失败”（即没有争取上）而处于阻塞状态，可能是因为条件不满足而处于等待状态，可能是因为在睡眠中。总之，线程目前没有在执行代码。

由于线程目前没有在执行代码，所以根本就无法去检测这个中断状态，也就是无法响应中断了，这样肯定是不行的。所以设计者们此时选择了抛异常。
所以，一个线程正在运行时，去中断它，是不会抛异常的，只是设置中断状态。此时中断状态就表示了中断。一个线程在没有运行时（阻塞/等待/睡眠），去中断它，会抛出中断异常，同时清除中断状态。此时中断异常就表示了中断。

因此，不管是由于阻塞/等待/睡眠，只要一个线程处于“停止”（即没有在运行）时，此时去中断它，线程会被唤醒，接着同样要去再次获取监视器，然后就收到了InterruptedException异常了，我们可以捕获这个异常并处理它，使线程可以继续正常运行。此时既然已经收到异常了，所以中断状态也就同时给清除了，因为中断异常已经足够表示中断了。


## 关于暂停线程：
`thread.suspend()`暂停，`thread.reesume()`恢复到就绪状态  
缺点：暂停一个有公共同步对象锁的线程，会导致公共同步对象的独占；还有同步问题，如数据还未同步完，它就暂停了。

`Thread.yield()` 当前线程放弃当前CPU资源，放弃后马上进行CPU竞争。  

`thread.setPriority()` 设置线程优先级，1~10，越大优先级越高；
优先级具有继承性，即子线程有父线程（创建了该线程的线程）的优先级；
高优先级的线程总是大部分先执行完，但不代表高优先级将全部先完成；
优先级较高的不一定每一次都先执行完，具有随机性；
具体的与OS相关。 

`thread.setDaemon(true)` 设置守护线程，当进程不存在非守护线程（用户线程）时则守护线程将销魂而后进程销毁。一般都是一些为其他线程提供便利服务的线程。  
当main线程运行结束后，它也自动停止运行了。  

# 多线程同步
同步就是有时候在进行多线程的程序设计中需要实现多个线程共享同一段代码。  

不同步问题的解决
1.不要让多个线程`无序地`访问共享资源，对关键代码进行归结放在一个代码块。
https://www.cnblogs.com/czwbig/p/11127124.html

>当需要判断关键代码的锁是否被某一线程所获取时，可以使用Thread类的静态布尔型方法`holdsLock(o)`来进行测试，其中参数o是与判断的关键代码锁所对应的对象的引用。如果某一线程已进入同
###  修饰代码块时synchronized(this)






## volatile
使用在多线程中，可以感知实例变量被更改了，并可以获取最新的值。也就是用多线程读取共享变量时可以获得最新值使用。  
强制对数据的读写及时影响到主内存，但会有不能及时同步的问题。只是保证从主内存加载到线程工作内存的值是最新的。  
多线程访问它修饰的变量时，不会发生阻塞，同时使得变量在多个线程可见。但不支持原子性。  
原子操作就是计算机在执行指令过程中不可分割的最小指令单元。比如声明变量的操作、给变量直接赋值的操作，这些都是原子操作，这些操作是安全的。在多线程的程序中，一旦将某个关键代码封装成一个原子操作，那么对它们的操作就不会存在不同步的情况。
  
当线程访问它修饰的变量时，强制从公共堆栈中取得变量的值，而不是从线程私有数据栈中获取。  
synchronized会将私有内存和公共内存数据同步，所以synchronized里的变量不需要用volatile。即便是在外面声明的。
![](https://img2018.cnblogs.com/blog/1331583/201908/1331583-20190821102846204-2145817795.png)


## 原子类型
就是一个原子操作可用的类型，它可以在没有锁的情况下做到线程安全。  
如java.util.concurrent.atomic.AtomicInteger，还有AtomicLong  
但还是用synchronized同步吧，因为原子类的方法尽管是原子的，但多个原子方法组成的业务逻辑还是需要同步的。  

ps:有些Java的数据类型也不能保证原子性的特点，因而也会出现不同步的情况，比如长整型和双精度浮点型。JVM是32位的，它只能用临近的两个32位的步长访问一个64位的长整型数据或者一个64位的双精度浮点型数据。这样一来，就有可能出现问题。
比如，一个线程访问了第一个32位以后被阻塞，这时其他线程执行，当该线程再次得到执行去完成访问第二个32位时，这个64位的数据可能已经被其他线程改变。

# 多线程的通信
可以通过while(true)轮询机制检测某共享变量是否达到某个条件，但这样有些浪费cpu资源，间隔时间大了也会不及时。  

每个锁对象都有两个队列————就绪队列、阻塞队列  
就绪队列存储将要获得锁的线程；阻塞队列存储被阻塞的线程。  

##1. 等待/通知机制
wait、notify都是对象锁调用的方法，必须在同步代码里调用。
调用前，当前线程获取了该对象锁，不然会一种运行时异常。  

不必再循环检测共享资源的状态，而是在需要的时候直接唤醒等待队列中的线程就可以了。  

object.wait()使当前正在执行的线程释放该对象锁，进入“预执行队列”中与其他线程竞争锁。  
代码在wait()处停止执行，直到接到通知（之后得到锁的线程调用notify()）后执行后面的代码。  

object.wait(long)若在某时间内没有收到通知，会自动被唤醒。
object.notify()也会使当前正在执行的线程释放锁，进入“预执行队列”中与其他线程竞争锁。
不同的是：
1.当前线程会执行完同步代码再释放锁。  
2.会通知其他处于等待（因wait方法调用而进入等待状态）状态的线程，若有多个等待线程，线程规划器会随机挑一个对其发出通知，并使得该线程获取该对象锁，进入就绪状态。  
运行完后，需要再次调用notify使其他等待状态的线程获取锁。  
如果没有wait状态的线程，则可忽略该方法。    

object.notifyAll()使得所有正在等待队列中等待同一共享资源的“全部”线程进入就绪状态，优先级最高的会执行（也不太确定）。  

### 生产者消费者模式实现
经典的生产者和消费者问题。 对于生产者，在生产者没有生产之前，要通知消费者等待；在生产者生产之后，马上又通知消费者消费；对于消费者，在消费者消费之后，要通知生产者已经消费结束，需要继续生产新的产品以供消费。

假死现象：出现原因————不能保证notify唤醒的是异类（多消费者、多生产者情景下），解决方式是？
条件改变导致出错：使用while  

### 管道
管道流用于在不同线程间直接传送数据，一个线程发送数据到输出管道，另一个线程从输入管道中读取数据。也分为字节流PipedInputStream PipedOutputStream、字符流PipedReader PipedWriter。
## 2.join
它比喻为插队，线程t插到了当前线程的前面，所以必须等线程t执行完后，当前线程才会接着执行。

thread.join() 当前线程（创建并启动子线程的线程）在该方法调用后阻塞，等待子线程对象(调用该方法的)执行完、销毁后再执行后面的代码。
有同步效果，内部使用wait方法实现。
thread.join(long milions) 当前线程等待子线程对象的最长时间，不需要等子线程对象(调用该方法的)执行完。 
注意：join后interrupt会报错  

与Thread.sleep(long milions)的区别：  
join内部调用wait(long milions)，意味着释放了锁，而sleep不释放锁 

源码实现，join方法标有synchronized关键字，所以是同步方法，而且在方法体内调用了从Object类继承来的wait方法。

所以join方法可以这样来解释，当前线程获取到线程对象t的监视器，然后执行t.wait()，使当前线程在线程对象t上等待，当前线程从运行状态进入到等待状态。由于对象t是一个线程，这是非常特殊的，因为线程执行完是会终止的，且在终止时会自动调用notifyAll方法进行通知。

有句话是这样讲的，“鸟之将死，其鸣也哀；人之将死，其言也善”。因此，一个线程都快要死了，是不是应该通知在自己身上等待的其它所有线程，把大伙都唤醒。总不能让所有人都给自己“陪葬”吧，哈哈。

因此，在线程t执行结束后，会自动执行t.notifyAll()来通知所有在t上等待的线程，并把它们全部唤醒。所以当前线程会继续接着执行。 

# ThreadLocal
实现每一个线程都有自己的共享变量（同一个类的静态变量），使得变量在不同线程间有隔离性。  
重写initialValue()方法，设置初始值。  

## InheritableThreadLocal
让子线程从父线程（创建并启动子线程的线程）中取得值。  
重写initialValue()方法，设置初始值。  
重写childValue(Object parentValue)方法，设置变量在子线程中的值。
# Lock锁
>synchronized 粒度有些大，在处理实际问题时存在诸多局限性，比如响应中断等。`Lock提供了比synchronized更广泛的锁操作`，它能以更优雅的方式处理线程同步问题。

如果一个代码块被synchronized关键字修饰，当一个线程获取了对应的锁，并执行该代码块时，其他线程便只能一直等待直至占有锁的线程释放锁。事实上，占有锁的线程释放锁一般会是以下三种情况之一：
1）占有锁的线程执行完了该代码块，然后释放对锁的占有；
2）占有锁线程执行发生异常，此时JVM会让线程自动释放锁；
3）占有锁线程进入 WAITING 状态从而释放锁，例如在该线程中调用wait()方法(还有notify)等。

Case 1 ：在使用synchronized关键字的情形下，假如占有锁的线程由于要等待IO或者其他原因（比如调用sleep方法）被阻塞了，但是又没有释放锁（尽管虚拟机会自动释放线程占有的锁），那么其他线程就只能一直等待，别无他法。这会极大影响程序执行效率。
因此，就需要有一种机制可以不让等待的线程一直无期限地等待下去（比如只等待一定的时间(解决方案：`tryLock(long time, TimeUnit unit)`) 
或者 能够响应中断 (解决方案：`lockInterruptibly()`)），这种情况可以通过 Lock 解决。

Case 2 ：我们知道，当多个线程读写文件时，读操作和写操作会发生冲突现象，写操作和写操作也会发生冲突现象，但是`读操作和读操作不会发生冲突现象`。但是如果采用synchronized关键字实现同步的话，就会导致一个问题，即当多个线程`都只是进行读操作`时，也只有一个线程在可以进行读操作，其他线程只能等待锁的释放而无法进行读操作。因此，需要一种机制来使得当多个线程都只是进行读操作时，线程之间不会发生冲突。
Lock也可以解决这种情况 (解决方案：读锁`ReentrantReadWriteLock`) 。

Case 3 ：我们可以通过Lock得知线程有没有成功获取到锁(解决方案：`ReentrantLock`)，但这个是synchronized无法办到的。

上面提到的三种情形，我们都可以通过Lock来解决，但 synchronized 关键字却无能为力。  

Lock提供了比synchronized更多的功能。但是要注意以下几点：
1）synchronized是Java的关键字，因此是Java的内置特性，是基于JVM层面实现的。而Lock是一个Java接口，是基于JDK层面实现的，通过这个接口可以实现同步访问；
2）采用synchronized方式不需要用户去手动释放锁，当synchronized方法或者synchronized代码块执行完之后，系统会自动让线程释放对锁的占用；而 Lock则必须要用户去手动释放锁(发生异常时，不会自动释放锁)，如果没有主动释放锁，就有可能导致死锁现象。
[lock使用，可重入锁等](https://blog.csdn.net/fuzhongmin05/article/details/63682947)  


## ReentrantLock  
```
Lock lock = new ReentrantLock();
lock.lock();
lock.unlock();
```    
公平锁：线程获取锁的顺序是按照线程加锁的顺序（进入执行状态的顺序，不是start的顺序）分配的，先来先得FIFO。  
Lock lock = new ReentrantLock(isFair);
lock.isFair()判断锁是否公平。  
非公平锁：随机获取锁。  

`lock.getHoldCount()`：查询当前线程保持此锁定的次数，即调用lock()方法的次数。
`lock.getQueueLength()`：正在等待获取此锁释放（处于同步阻塞状态中）的线程个数，看调用时机，可能不会很准。
`lock.hasQueuedThread(t1)`：查询t1线程是否正在等待获取此锁。
`lock.hasQueuedThreads()`：查询是否有线程正在等待获取此锁
`lock.getWaitQueueLength(condition)`：等待与此锁相关的给定条件Condition的线程数，即执行了同一个condition对象的 await()方法的线程个数。
`lock.hasWaiters(condition)`：查询是否有线程正在等待与此锁相关的给定条件Condition，即是否有线程执行了同一个condition对象的 await()方法。

`lock.isHeldByCurrentThread()`：判断当前线程是否获得了锁。
`lock.isLocked()`：查询此锁是否有线程保持着
`lock.tryLock()`：在调用时，锁未被另一个线程持有的情况下，才能获取锁。
`lock.tryLock(long timeout, TimeUnit unit)`：如果锁在给定等待时间内没有被其他线程获取，且当前线程未被中断，也会获取锁。

`lock.isHeldByCurrentThread()`代替lock.lock()：如果线程被interrupt，则抛出InterruptedException异常停止执行。
在线程 wait（以及sleep状态）时，interrupt线程，会抛异常。
`condition.awaitUninterruptibly()`代替 condition.await() ，线程进入wait状态，且被interrupt后不会抛异常。
`condition.awaitUntil(Date deadline)`：当前线程除了可被唤醒外，到deadline时间也会自己醒来。

### Condition
ReentrantLock可以借助 Condition 对象实现等待/通知模式。  
Condition 类可以实现多路通知，一个Lock对象里可以创建多个 Condition 对象（对象监视器）。synchronized就相当于整个Lock对象中只有一个 Condition 对象。
Condition 类也可以实现有选择性地通知，而使用notify方法进行的线程通知，被通知的线程是随机的。  
实现唤醒部分指定线程或实现线程的有序执行，需要使用多个 Condition 对象（对线程进行分组，再唤醒指定组中的线程）
condition.await() 相当于 wait()
condition.await(long million, TimeUnit unit) 相当于 wait(long million)
condition.signalAll() 相当于 notifyAll()
condition.signal() 相当于 notify()
这些方法使用前必须先获得“监视器对象”，即先调用lock.lock()，否则会有IllegalMonitorStateException。同时注意lock.lock()后需要手动释放锁，一般写在finally代码块中。  

  

## 读写锁ReentrantReadWriteLock  
```
ReentrantReadWriteLock rwLock = new ReentrantReadWriteLock();  
rwLock.readLock().lock();
rwLock.readLock().unlock();

```  
读写锁ReentrantReadWriteLock，可以实现在某些不需要操作实例变量的方法中，
分为读操作相关的锁，也称为共享锁；和写操作相关的锁，也叫排他锁。  
多个读锁之间不互斥，但读锁与写锁互斥，写锁和写锁互斥。即多个线程可以同时进行读取操作，但是同一时刻只能允许一个线程进行写操作。
只要出现“写操作”，就是互斥的。 

# 避免同步
同步机制也有其不足的地方，比如，同步的时间代价很高。这是因为，同步机制中线程之间在获得和释放互斥锁的时候需要花费相当的时间，这些时间的消耗会降低程序的性能。因此，当问题中可以确定不需要使用同步机制来解决时，一定不要引入同步方法或者同步代码块。  

对于那些非原子级的对象，也可以通过将其声明为final类型来保证该对象不可改变，从而避免同步。 一个String对象就是原子级对象。  

此外，还可以通过将一些对象声明为不变性(volatile)对象来避免同步，比如当程序中需要频繁地只读访问一个对象时，将其声明为一个不可变对象就可以很好地避免同步发生。

# Concurrent包使用
## java中等待一些线程执行完之后，再去执行别的方法（后者需要使用前者返回的结果）
https://blog.csdn.net/jaryle/article/details/74905379  
https://www.cnblogs.com/bqcoder/p/6089101.html
# Executor线程池
![](https://img2018.cnblogs.com/blog/1331583/201909/1331583-20190903092240969-262197436.png)  


## ExecutorService是Executor的子接口  
旗下有常用的ThreadPoolExecutor实现类
![](https://img2018.cnblogs.com/blog/1331583/201909/1331583-20190903093830544-1081012058.png)  

构造方法：
![](https://img2018.cnblogs.com/blog/1331583/201909/1331583-20190903094755331-1446297377.png)

# 多线程与单例
![](https://img2018.cnblogs.com/blog/1331583/201912/1331583-20191225114328845-1858215344.png)

