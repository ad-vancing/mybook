https://juejin.cn/post/7104985436900032526

[深入 JVM 原理分析 synchronized](https://xie.infoq.cn/article/3376b312abdee0ce0f321efec)

# 锁的分类
- synchronized这种悲观锁
- 期间数据允许其他线程修改的乐观锁
- 转转圈自旋锁


# synchronized 实现原理
synchronized是一个关键字，是基于c++实现的。

## Monitor
每个对象实例都会有一个 Monitor（Monitor 是由 ObjectMonitor 实现，而 ObjectMonitor 是由 C++ 的 ObjectMonitor.hpp 文件实现。），Monitor 可以和对象一起创建、销毁。  
JVM 中的同步是基于进入和退出管程（Monitor）对象实现的。

## 修饰方法时
实例方法上，锁对象是当前的 this 对象；修饰静态方法上，锁对象是方法区中的类对象，锁定的是这个类的所有对象，是一个全局锁。
### ACC_SYNCHRONIZED 标志。
如果设置了**ACC_SYNCHRONIZED标识符**，则会尝试获取锁对象的 monitor 对象，获取成功之后才能执行方法体，线程执行完方法体后，再释放锁对象的 monitor对象。
在此期间，其他线程无法获得锁对象的 monitor 对象。

## 修饰代码块时
由 monitorenter 和 monitorexit 指令来实现同步的。

### monitorenter
线程尝试获取锁对象的 monitor 对象，尝试获取monitor的所有权。
这时 monitor 对象中的 count 会加+1，如果 monitor 已经被其他线程所获取，该线程会被阻塞住，直到 count = 0，再重新尝试获取monitor对象。

>每个线程都有两个ObjectMonitor对象列表，分别为free和used列表，如果当前free列表为空，线程将向全局global list请求分配ObjectMonitorObjectMonitor的owner、WaitSet、Cxq、EntryList这几个属性比较关键。WaitSet、Cxq、EntryList的队列元素是包装线程后的对象-ObjectWaiter；而获取owner的线程，既为获得锁的线程
https://juejin.cn/post/6854573210768900110
 

### monitorexit
该线程释放锁对象的 monitor 对象，这时monitor对象的count便会-1变成0，其他被阻塞的线程可以重新尝试获取锁对象的monitor对象。

## 修饰类，即直接作用一个类。
给 class 加锁和给静态方法加锁是一样的，所有对象公用一把锁。
也是通过monitorenter和monitorexit指令。其区别在于，给对象加锁是一个对象一把锁，而给类加锁是所有对象共用一把锁。

#  jvm对synchronized的优化
## 锁的4种状态
级别从低到高依次为：无锁，偏向锁，轻量级锁和重量级锁状态，这几个状态会随着竞争情况逐渐升级。
在对象中，每个对象在对象头中都有自己的锁标识。

一般情况下当我们 new 出来的初始情况就是无锁状态，也就是没有使用 synchronized 的情况。

### 偏向锁
在大多数情况下，锁不存在多线程竞争，总是由同一线程多次获得，那么此时就是偏向锁。

偏向锁的核心思想是，如果一个线程获得了锁，那么锁就进入偏向模式，此时Mark Word 的结构也变为偏向锁结构，当这个线程再次请求锁时，无需再做任何同步操作，即获取锁的过程，这样就省去了大量有关锁申请的操作，从而也就提供程序的性能。

所以，对于**没有锁竞争的场合**，偏向锁有很好的优化效果，毕竟极有可能连续多次是同一个线程申请相同的锁。   
但是对于锁竞争比较激烈的场合，偏向锁就失效了，因为这样场合极有可能每次申请锁的线程都是不相同的，因此这种场合下不应该使用偏向锁，否则会得不偿失。


### 轻量级锁
引入轻量级锁的主要目的是在**多线程竞争不激烈的情况下**，通过CAS竞争锁，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。
轻量级锁是由偏向锁升级而来，当存在第二个线程申请同一个锁对象时，偏向锁就会立即升级为轻量级锁。注意这里的第二个线程只是申请锁，不存在两个线程同时竞争锁，可以是一前一后地交替执行同步块，即多个线程交替进入同步代码块。
轻量级锁所适应的场景是线程交替执行同步块的情况，如果存在同一时间访问同一锁的情况，就会导致轻量级锁膨胀为重量级锁。

#### 自旋
重量级锁，在互斥状态下，没有得到锁的线程会被挂起阻塞，自旋锁，就是指当一个线程尝试获取某个锁时，如果该锁已被其他线程占用，就一直循环检测锁是否被释放，而不是进入线程挂起或睡眠状态。

自旋锁适用于锁保护的临界区很小的情况，临界区很小的话，锁占用的时间就很短。自旋等待不能替代阻塞，虽然它可以避免线程切换带来的开销，但是它占用了CPU处理器的时间。  
如果**持有锁的线程很快就释放了锁**，那么自旋的效率就非常好，反之，自旋的线程就会白白消耗掉处理的资源，它不会做任何有意义的工作，典型的占着茅坑不拉屎，这样反而会带来性能上的浪费。  
所以说，自旋等待的时间（自旋的次数）必须要有一个限度，如果自旋超过了定义的时间仍然没有获取到锁，则应该被挂起。

在JDK1.6中默认开启。同时自旋的默认次数为10次，可以通过参数-XX:PreBlockSpin来调整。
自适应自旋锁。所谓自适应就意味着自旋的次数不再是固定的，它是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。


### 重量级锁
重量级锁是由轻量级锁升级而来，当同一时间有多个线程竞争锁时，锁就会被升级成重量级锁，此时其申请锁带来的开销也就变大。  
重量级锁一般使用场景会在追求吞吐量，同步块或者同步方法执行时间较长的场景。

## 锁升级过程
```
检测Mark Word里面是不是当前线程ID,如果是,表示当前线程处于偏向锁
如果不是,则使用CAS将当前线程ID替换到Mark Word,如果成功则表示当前线程获得偏向锁,设置偏向标志位1
如果失败,则说明发生了竞争,撤销偏向锁,升级为轻量级锁
当前线程使用CAS将对象头的mark Word锁标记位替换为锁记录指针,如果成功,当前线程获得锁
如果失败,表示其他线程竞争锁,当前线程尝试通过自旋获取锁 for(;;)
如果自旋成功则依然处于轻量级状态
如果自旋失败,升级为重量级锁
```

## 锁粗化
多次加锁操作在JVM内部也是种消耗，如果多个加锁可以合并为一个锁，就可减少不必要的开销。

## 锁消除
删除不必要的加锁操作，如果变量是独属一个线程的栈变量，加不加锁都是安全的，编译器会尝试消除锁
开启锁消除需要在JVM参数上设置`-server -XX:+DoEscapeAnalysis -XX:+EliminateLocks`

## 其他锁优化方法
分段锁

#  其他
父类的同步方法被子类重写后，若没加上 synchronized，则不再是同步方法。  
出现异常，锁自动释放。  

synchronized(string)与String联合使用时，需要注意String常量池带来的一些例外。  
不同对象的String变量都是指向常量池里同一个值时，不同对象的synchronized(string)代码块会变同步。
所以一般不用使用String类型变量作为锁对象。而是new Object，锁object对象。 


# wait和sleep的区别
相同点：线程的状态相同，都是阻塞状态。
不同点：
wait 是 Object 的方法，任何对象都可以直接调用，因为线程只有在同步块中才会占用对象的锁，所以线程**必须在同步块中调用wait()、notify()方法**。  
sleep是Thread的静态方法。  

wait 必须配合 synchronized 关键字一起使用，如果一个对象没有获取到锁直接调用wait会异常，sleep则不需要。
wait 可以通过 notify 主动唤醒；sleep 在休眠时间达到，只能通过打断主动叫醒。
wait 会释放锁，sleep只是会让出CPU并不会释放掉对象锁。

# 线程间的通信 wait notify
wait，notify必须是持有当前对象锁Monitor的线程才能调用。[在sychronized中锁对象Object调用wait时会加入waitSet队列](https://juejin.cn/post/6854573210768900110)  
当一个线程调用任何对象上的wait()方法时便会进入非运行状态，直到另一个线程调用同一个对象上的notify()或notifyAll()方法。
https://blog.csdn.net/suifeng3051/article/details/51863010?locationNum=2


# notify和notifyall的区别
都会使当前线程会执行完同步代码再释放锁，进入“预执行队列”中与其他线程竞争锁。。  
都会通知其他处于等待（因wait方法调用而进入等待状态）状态的线程。

若有多个等待线程，notify（） 线程规划器会随机挑一个对其发出通知，并使得该线程获取该对象锁，进入就绪状态。  
notifyAll()使得所有正在等待队列中等待同一共享资源的“全部”线程进入就绪状态。 

    