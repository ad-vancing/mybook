https://blog.csdn.net/tonytfjing/article/details/47212291

> 虚拟机将描述类的二进制字节流(即.Class字节码文件)加载到内存中，并对其进行验证、准备、解析、初始化的过程，最终生成可以直接被虚拟机使用的Java类型(即已经校验合格且有clinit执行完clinit方法的Class对象)，这就是JVM的类加载机制。  

![](https://img-blog.csdn.net/20150315165523065?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdG9ueXRmamluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

- 按需加载

程序在启动的时候，并不会一次性加载程序所要用的所有class文件，而是根据程序的需要，通过Java的类加载机制（ClassLoader）来动态加载 class、还有 class 中的静态变量和常量到内存（方法区/元空间）当中的，只有class文件被载入到了内存之后，才能被其它class所引用。所以ClassLoader就是用来动态加载class文件到内存当中用的。


# class加载到JVM中到可运行被使用有几个过程
## 装载（loading）
即找到class对应的字节码文件，加载到内存中，生成一个代表该类的 java.lang.Class 对象。  
对于数组类来说，它并没有对应的字 节流，而是由 Java 虚拟机直接生成的。  
对于其他的类来说，Java 虚拟机则需要`借助类加载器`来完 成查找字节流的过程。

## 链接（linking）
是指将创建成的类合并至 Java 虚拟机中，使之能够执行的过程。它可分为验证、准备以及解析三个阶段。  

**验证 Verification**：验证阶段的目的，在于确保被加载类能够满足 Java 虚拟机的约束条件。 对二进制字节流进行校验，只有符合 JVM 字节码规范的才能被 JVM 正确执行。  
下面是一些主要的检查：  
确保二进制字节流格式符合预期（比如是否以 cafe bene 开头）。  
是否所有方法都遵守访问控制关键字的限定。  
方法调用的参数个数和类型是否正确。  
确保变量在使用之前被正确初始化了。  
检查变量是否被赋予恰当类型的值。  
 
**准备 Preparation**：为被加载类的静态字段（静态变量，static 关键字修饰的）分配内存，并初始化（对应数据类型的默认初始值，如 0、0L、null、false 等）。    
除了分配内存外，部分 Java 虚拟机还会在此阶段构造其他跟类层次相关的数据结构，比如说用来实现虚方法的动态绑定的方法表。  
假如有这样一段代码： 
```
public String chenmo = "沉默";
public static String wanger = "王二";
public static final String cmower = "沉默王二";
```
chenmo 不会被分配内存，而 wanger 会；但 wanger 的初始值不是“王二”而是 null。  
需要注意的是，static final 修饰的变量被称作为常量，和类变量不同。常量一旦赋值就不会改变了，所以 cmower 在准备阶段的值为“沉默王二”而不是 null。

**解析 Resolution**：非必须，如果某些字节码使用了符号引用，那么在执行这些字节码之前，需要完成对这些符号引用的解析，解析成为实际引用。  
符号引用以一组符号（任何形式的字面量，只要在使用时能够无歧义的定位到目标即可）来描述所引用的目标。

在编译时，Java 类并不知道所引用的类的实际地址，因此只能使用符号引用来代替。  
比如 com.Wanger 类引用了 com.Chenmo 类，编译时 Wanger 类并不知道 Chenmo 类的实际内存地址，因此只能使用符号 com.Chenmo。  
直接引用通过对符号引用进行解析，找到引用的实际内存地址。

ps：如果符号引用指向一个未被加载的类，或者未被加载类的字段或方法，那么解析将触发这个类的加载（但未必触发这个类的链接以及初始化。）


## 初始化（initializing）  
只有当初始化完成之后，类才正式成为可执行的状态。    
1、为类的静态变量赋予正确的初始值。  
2、执行类的静态代码块。

在准备阶段，类变量已经被赋过默认初始值，而在初始化阶段，类变量将被赋值为代码期望赋的值。  
换句话说，初始化阶段是执行类构造器方法的过程。  
举个例子：`String cmower = new String("沉默王二");`  
上面这段代码使用了 new 关键字来实例化一个字符串对象，那么这时候，就会调用 String 类的构造方法对 cmower 进行实例化。

如果要初始化一个静态字段，我们可以在声明时直接赋值，也可以在静态代码块中 对其赋值。  
如果直接赋值的静态字段被 final 所修饰，并且它的类型是基本类型或字符串时，那么该字段便会 被 Java 编译器标记成常量值（ConstantValue），其初始化直接由 Java 虚拟机完成。除此之外的 直接赋值操作，以及所有静态代码块中的代码，则会被 Java 编译器置于同一方法中，并把它命名为 `clinit`。  


### 只有一次
为标记为常量值的字段赋值，以及执行 < clinit > 方法的过程。Java 虚拟机会通过加锁来确保类的 < clinit > 方法仅被执行一次。    
所以，类的初始化仅会被执行一次，这个特性被用来`实现单例的延迟初始化`。


### 类的初始化何时会被触发呢？
JVM 规范枚举了下述多种触发情况：
1. 当虚拟机启动时，初始化用户指定的主类；
2. 当遇到用以新建目标类实例的 new 指令时，初始化 new 指令的目标类；
3. 当遇到调用静态方法的指令时，初始化该静态方法所在的类；
4. 当遇到访问静态字段的指令时，初始化该静态字段所在的类；
5. 子类的初始化会触发父类的初始化；
6. 如果一个接口定义了 default 方法，那么直接实现或者间接实现该接口的类的初始化，会触发该接口的初始化；
7. 使用反射 API 对某个类进行反射调用时，初始化这个类；
8. 当初次调用 MethodHandle 实例时，初始化该 MethodHandle 指向的方法所在的类。


# Java 核心类库提供的三种类加载器
## BootStrap ClassLoader启动类加载器
是由 C++ 实现的，没有对应的 Java 对象，因此在 Java 中只能用 null 来 指代。  
当JVM启动后，Bootstrap ClassLoader也随着启动，负责加载完核心类库后，并构造Extension ClassLoader和App ClassLoader类加载器。  
在 Java 9 之前，启动类加载器负责加载最为基础、最为重要的类———jre/lib 包下面的 jar 文件下的类（以及由虚拟机参数 -Xbootclasspath 指定的类）。  
是Java类加载层次中最顶层的类加载器，负责加载JDK中的核心类库，如：rt.jar、resources.jar、charsets.jar等

除了启动类加载器之外，其他的类加载器都是 java.lang.ClassLoader 的子类，因此有对应的 Java 对象。这些类加载器需要先由另一个类加载器，比如说启动类加载器，加载至 Java 虚拟机中，方能 执行类加载。
[rt.jar、tools.jar和dt.jar作用](https://blog.csdn.net/qq_36923376/article/details/83477274)

## Extension ClassLoader扩展类加载器
扩展类加载器的父类加载器（不是继承的关系，是一个包含的关系）是启动类加载器。  
它负责加载相对次要、但又通用的类，比如存放在JRE 的 lib/ext 目录下 jar 包中的类（以及由系统变量 java.ext.dirs 指定的类）。  
负责加载Java的扩展类库，默认加载JAVA_HOME/jre/lib/ext/目下的所有jar。  
ExtClassLoader的父类加载器其实是null，只不过在默认的ClassLoader 的 loadClass 方法中，当parent为null时，是交给BootStrapClassLoader来处理的，而且ExtClassLoader 没有重写默认的loadClass方法，所以，ExtClassLoader也会调用BootStrapLoader类加载器来加载，这就导致“BootStrapClassLoader具备了ExtClassLoader父类加载器的功能”。

## App ClassLoader系统类加载器
应用类加载器的父类加载器则是扩展类加载器。  
它负责加载应用程序路径下的类。（这里的应用程 序路径，便是指虚拟机参数 -cp/-classpath、系统变量 java.class.path 或环境变量 CLASSPATH 所 指定的路径。）默认情况下，应用程序中包含的类便是由应用类加载器加载的。

## CustomClassLoader
如果以上三种类加载器不能满足要求的话，程序员还可以自定义类加载器（继承 java.lang.ClassLoader 类），用来读取指定类文件 。  
如tomcat、jboss都会根据j2ee规范自行实现ClassLoader。  
基于自定义的ClassLoader可用于加载非Classpath中（如从网络上下载的jar或二进制）的jar及目录、还可以在加载前对class文件优一些动作，如解密、编码等。

```

/**
 * 自定义一个类加载器，用于将字节码转换为class对象
 * @author louluan
 */
public class MyClassLoader extends ClassLoader {
 
	public Class<?> defineMyClass( byte[] b, int off, int len) 
	{
		return super.defineClass(b, off, len);
	}


/**
 * 使用
 */
public static void main(String[] args) throws IOException {
		//读取本地的class文件内的字节码，转换成字节码数组
		File file = new File(".");
		InputStream  input = new FileInputStream(file.getCanonicalPath()+"\\bin\\samples\\Programmer.class");
		byte[] result = new byte[1024];
		
		int count = input.read(result);
		// 使用自定义的类加载器将 byte字节码数组转换为对应的class对象
		MyClassLoader loader = new MyClassLoader();
		Class clazz = loader.defineMyClass( result, 0, count);
		//测试加载是否成功，打印class 对象的名称
		System.out.println(clazz.getCanonicalName());
```

![](https://img-blog.csdn.net/20150802215303561)

每个 Java 类都维护着一个指向定义它的类加载器的引用，通过 `类名.class.getClassLoader()` 可以获取到此引用；然后通过 `loader.getParent()` 可以获取类加载器的上层类加载器。

## Java 9 的变化
Java 9 引入了模块系统，并且略微更改了上述的类加载器1。扩展类加载器被改名为平台类加载器 （platform class loader）。Java SE 中除了少数几个关键模块，比如说 java.base 是由启动类加载 器加载之外，其他的模块均由平台类加载器所加载。


## 双亲委派模型 避免重复加载
加载过程中会先检查类是否被已加载，**检查顺序是自底向上**，从Custom ClassLoader到BootStrap ClassLoader逐层检查，只要某个classloader已加载就视为已加载此类，保证此类只所有ClassLoader加载一次。而**加载的顺序是自顶向下**，也就是由上层来逐层尝试加载此类。

如果一个类加载器收到了加载类的请求，它会先把请求委托给上层加载器去完成，上层加载器又会委托上上层加载器，一直到最顶层的类加载器；如果上层加载器无法完成类的加载工作时，当前类加载器才会尝试自己去加载这个类。

这个由上至下依次检查的过程，首先由最顶层的类加载器Bootstrap ClassLoader试图加载，如果没找到该类，则把任务转交给Extension ClassLoader试图加载，如果也没找到该类，则转交给AppClassLoader进行加载，如果它也没有找到该类的话，则返回给委托的发起者，由它到指定的文件系统或网络等URL中加载该类。  
如果它们都没有加载到这个类时，则抛出ClassNotFoundException异常。否则将这个找到的类生成一个类的定义，并将它加载到内存当中，最后返回这个类在内存中的Class实例对象。


JVM根据 类名+包名+ClassLoader实例ID 来判定两个类是否相同，是否已经加载过。  
[ClassLoader源码分析](https://blog.csdn.net/djokermax/article/details/81539639)  
主要逻辑在`loadClass(String name, boolean resolve)`方法中。  
里面有个递归调用，当前类加载器如果存在父类加载器，就传入父类加载器然后继续调用该方法，此时会委派给父类加载器加载。



### 为什么使用双亲委托这种模型呢？  
因为这样可以避免重复加载，当父亲已经加载了该类的时候，就没有必要子ClassLoader再加载一次。  
考虑到安全因素，我们试想一下，如果不使用这种委托模式，那我们就可以随时使用自定义的String来动态替代java核心api中定义的类型，这样会存在非常大的安全隐患，而双亲委托的方式，就可以避免这种情况，因为String已经在启动时就被引导类加载器（Bootstrcp ClassLoader）加载，所以用户自定义的ClassLoader永远也无法加载一个自己写的String，除非你改变JDK中ClassLoader搜索类的默认算法。

使用双亲委派模型有一个很明显的好处，那就是 Java 类随着它的类加载器一起具备了一种带有优先级的层次关系，这对于保证 Java 程序的稳定运作很重要。
如果两个类的加载器不同，即使两个类来源于同一个字节码文件，那这两个类就必定不相等——双亲委派模型能够保证同一个类最终会被特定的类加载器加载。

#### 命名空间的作用
除了加载功能之外，类加载器还提供了命名空间的作用。
在 Java 虚拟机中，类的唯一性是由类加载器实例以及类的全名一同确定的。
即便是同一串字节流，经由不同的类加载器加载，也会得到两个不同的类。在大型应用中，我们往往借助这一特性，来运行同一个类的不同版本。

>JVM在搜索类的时候，又是如何判定两个class是相同的呢？  
 JVM在判定两个class是否相同时，不仅要判断两个类名是否相同，而且要判断是否由同一个类加载器实例加载的。只有两者同时满足的情况下，JVM才认为这两个class是相同的。  



# Java中两种手动调用加载class到JVM中的方式
默认会使用调用类的类加载器来进行类加载。
## Class.forName(“className”);
其实这种方法调运的是：`Class.forName(className, true, ClassLoader.getCallerClassLoader())`方法
参数一：className，需要加载的类的名称。
参数二：true，是否对class进行初始化（需要initialize）
参数三：classLoader，对应的类加载器
## ClassLoader.laodClass(“className”);
其实这种方法调运的是：`ClassLoader.loadClass(name, false)`方法
参数一：name,需要加载的类的名称
参数二：false，这个类加载以后是否需要去连接（不需要linking）
## 两种方式的区别
Class.forName()是显示加载类，作用是要求JVM查找并加载指定的类，也就是说JVM会执行该类的静态代码段。
查看com.mysql.jdbc.Driver源码可以发现里面有个静态代码块，在加载后，类里面的静态代码块就执行（主要目的是注册驱动，把自己注册进去），所以主要目的就是为了触发这个静态方法。

forName("")得到的class是已经初始化完成的，加载并实例化JDBC驱动类时用到，因为JDBC驱动程序只有被注册后（将驱注册到DriverManageer上，之后才能通过DriverManager去获取相应的连接）才能被应用程序使用，这就要求驱动程序类必须被初始化，而不单单被加载。  

loadClass("")得到的class是还没有连接的。  

Class.forName除了将类的.class文件加载到JVM中之外，还会对类进行解释，执行类中的static块。而ClassLoader只干一件事，就是将.class文件加载到JVM中，不会执行static块中的内容，只有在NEW Instance（）才会去执行static块。



启动时如果加上如下系统参数，即可跟踪JVM类的加载`-XX:+TraceClassLoading`
```
[Opened C:\Program Files\Java\jdk1.8.0_152\jre\lib\rt.jar]
[Loaded java.lang.Object from C:\Program Files\Java\jdk1.8.0_152\jre\lib\rt.jar]
[Loaded java.util.ArrayList$SubList from C:\Program Files\Java\jdk1.8.0_152\jre\lib\rt.jar]
[Loaded java.util.ListIterator from C:\Program Files\Java\jdk1.8.0_152\jre\lib\rt.jar]
[Loaded java.util.ArrayList$SubList$1 from C:\Program Files\Java\jdk1.8.0_152\jre\lib\rt.jar]
[Loaded DemoMain.TracingClassParamsDemo from file:/D:/GIT-Repositories/GitLab/Demo/out/production/Demo/]
[Loaded java.lang.Class$MethodArray from C:\Program Files\Java\jdk1.8.0_152\jre\lib\rt.jar]
[Loaded java.lang.Void from C:\Program Files\Java\jdk1.8.0_152\jre\lib\rt.jar]
[Loaded java.lang.Shutdown from C:\Program Files\Java\jdk1.8.0_152\jre\lib\rt.jar]
[Loaded java.lang.Shutdown$Lock from C:\Program Files\Java\jdk1.8.0_152\jre\lib\rt.jar]
```
或者  `-verbose:class` JVM 参数，都可打印类加载的先后顺序


# 看到的相关的
![](https://img2020.cnblogs.com/blog/1331583/202006/1331583-20200630094620564-1946726774.png)

# classpath
如果一个类不在classpath下，为什么会抛出ClassNotFoundException异常，如果在不改变这个类路径的前期下，怎样才能正确加载这个类？
classpath是javac编译器的一个环境变量。
它的作用与import、package关键字有关。
package的所在位置，就是设置CLASSPATH当编译器面对import packag这个语句时，它先会查找CLASSPATH所指定的目录，并检视子目录java/util是否存在，然后找出名称吻合的已编译文件（.class文件）。如果没有找到就会报错！ 
动态加载包


# 反射与 Class 类
反射是框架设计的灵魂。
JAVA反射机制————在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；**这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制**。
要想解剖一个类,必须先要获取到该类的字节码文件对象。而解剖使用的就是Class类中的方法，所以先要获取到每一个字节码文件对应的Class类型的对象。

反射就是把java类中的各种成分映射成一个个的Java对象
例如：一个类有：成员变量、方法、构造方法、包等等信息，利用反射技术可以对一个类进行解剖，把个个组成部分映射成一个个对象。

加载的时候：Class对象的由来是将class文件读入内存，并为之创建一个Class对象。其实：一个类中这些成员方法、构造方法、在加入类中都有一个类来描述，反射的原理就在于class对象。
![](https://img-blog.csdn.net/20170513133210763)

Class 类的实例表示正在运行的 Java 应用程序中的类和接口。也就是jvm中有N多的实例每个类都有该Class对象。（包括基本数据类型）
Class 没有公共构造方法。Class 对象是在加载类时由 Java 虚拟机以及通过调用类加载器中的defineClass 方法自动构造的。也就是这不需要我们自己去处理创建，JVM已经帮我们创建好了。

## 获取Class对象的三种方式
1 obj.getClass();
```
Student stu1 = new Student();//这一new 产生一个Student对象，一个Class对象。
Class stuClass = stu1.getClass();//获取Class对象

```
2 任何数据类型（包括基本数据类型）都有一个“静态”的class属性
```
		Class stuClass2 = Student.class;
		System.out.println(stuClass == stuClass2);//判断第一种方式获取的Class对象和第二种方式获取的是否是同一个
```
3 通过Class类的静态方法：forName（String  className）(常用)
```
try {
			Class stuClass3 = Class.forName("fanshe.Student");//注意此字符串必须是真实路径，就是带包名的类路径，包名.类名
			System.out.println(stuClass3 == stuClass2);//判断三种方式是否获取的是同一个Class对象
		} catch (ClassNotFoundException e) {
			e.printStackTrace();

```
在运行期间，一个类，只有一个Class对象产生。


## api
```
// 取得Class
Class<?> aClass = Class.forName("reflect.Student");

// 通过Class生成对象
Student stu = (Student) aClass.newInstance();

// 通过Class取到公开方法数组
Method[] methods = aClass.getMethods();

// 包含了私有和公有方法
Method[] declaredMethods = aClass.getDeclaredMethods();

// 得到指定的方法，第一个参数是需要调用的方法名，第二个是该方法的参数类型的Class
Method say = aClass.getMethod("say", String.class);
// 传入方法的对象，以及要打印的字符串，并调用方法
say.invoke(student, "你好，测试invoke方法");

// 得到指定的方法
Method mySay = aClass.getDeclaredMethod("mySay",null);
// 修改权限，否则不能调用私有方法并报错：IllegalAccessException
mySay.setAccessible(true);
// 传入方法的对象，以及要打印的字符串，并调用方法
mySay.invoke(student);

// 获取私有的字段
Field mySex = aClass.getDeclaredField("mySex");
// 设置权限，允许访问私有字段
mySex.setAccessible(true);
// 私有字段赋值
mySex.set(student, false);


 // 创建私有构造函数，并指定参数的类型
 Constructor<?> declaredConstructor = aClass.getDeclaredConstructor(String.class, int.class, Boolean.class);
 // 设置权限，允许反射
 declaredConstructor.setAccessible(true);
 // 创建实例，并强转成Student对象
 Student 兰陵王 = (Student) declaredConstructor.newInstance("兰陵王", 30, true);
```

ps：泛型用在编译期，编译过后泛型擦除（消失掉）。所以是可以通过反射越过泛型检查的
https://blog.csdn.net/sinat_38259539/article/details/71799078