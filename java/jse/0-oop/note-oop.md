变量

成员变量不赋值时默认为0，局部变量则没有默认值

# 继承
继承是类与类的关系，封装是类与对象，多态也反映类与类

## 子类与父类
### 关于构造函数
1、子类会自动调用父类的无参构造函数。

2、子类TestB会自动寻求调用TestA的无参构造函数，但是此时TestA中只有一个TestA(String s)，
需要在TestA中加上"public TestA(){}"，或者在TestB的构造函数中加上"super("xxx")便不会再寻求调用TestA的无参构造函数而是调用TestA的有参构造函数。

3、因此，从这里我们还应该能看出，当我们在一个类中定义了自己的带参数的构造方法的时候，必须把无参构造函数定义一下！

### this关键字和super关键字的区别
- this表示当前对象：
this.属性     区分成员变量和局部变量
this.()          调用本类的某个方法
this()           表示调用本类构造方法，只能用在构造方法的第一行语句。
this关键字只能出现在非static修饰的代码中
-  super表示父类对象：
super.属性         表示父类对象中的成员变量
super.方法()      表示父类对象中定义的方法
super()               表示调用父类构造方法，可以指定参数，比如super("Tom", 23);
任何一个构造方法的第一行默认是super();
可以写上，如果未写，会隐式调用super();
super()只能在构造方法的第一行使用.
	
 this()和super()都只能在构造的第一行出现，所以只能选择其一，写了this()就不会隐式调用super()。
 

### 初始化顺序
实例化子类的时候，若此类未被加载过，首先加载是父类的类对象，然后加载子类的类对象，接着实例化父类，最后实例化子类，若此类被加载过，不再加载父类和子类的类对象。
接下来是加载顺序，当加载类对象时，首先初始化静态属性，然后执行静态块；当实例化对象时，首先执行构造块（直接写在类中的代码块），然后执行构造方法。
至于各静态块和静态属性初始化哪个些执行，是按代码的先后顺序。属性、构造块（也就是上面的实例块）、构造方法之间的执行顺序（但构造块一定会在构造方法前执行），也是按代码的先后顺序。


# 多态
多态出现的原因：
引用变量有两种类型：
1.编译时的类型，由声明该变量时使用的类型决定Animal（父类）
2.运行时的类型，由实际赋给该变量的类型决定Dog（子类）
它们不一致时，会出现多态。
`Animal obj2=new Dog();`
编译阶段只能调用其编译类型的方法（通常是抽象方法，提供子类重写）
运行时执行运行类型的方法（通常是重写或继承的方法）
注意：obj2的属性并不具备多态，仅仅是编译类定义的属性。

简单点说：同一个引用类型，使用不同的实例而执行不同的操作。

## 多态的表现
1.引用多态：父类的引用可以指向其本类的对象Animal obj1=new Animal();  也可以指向其子类的对象 Animal obj2=new Dog();（向上转型）
但不允许子类的引用指向父类，如 Dog obj3=new Animal();
2.方法多态：父类对象obj1调用父类方法，子类对象obj2调用子类重写或继承的方法。
当子类有一个独有的方法（不是继承或重写的方法）时，不能通过父类的引用调用子类的独有方法，如obj2.bark()会报错，要先强转才行。

自己的理解和多态的具体应用体现：
父类作为方法的形参，方便其他类调用，比如：医生类中定义方法cure(Pet pet)，此时所有继承Pet的子类的对象都可以就医了，具体就医情况不同子类Pig、Dog是不同的，在它们自己的方法中重写，并提供给医生的cure(Pet pet)调用，这样不仅pet们都按自己的特征就医了。
如果不用多态的思想，医生则需要不断地用cure(Dog dog)，cure(Pig pig)···使用方法重载。
当然不是指动物自己决定怎么治疗，不然要医生何用，而是指符合该类动物特点的东西。

## 工厂方法
也是多态的体现
1.父类作为形参，可接收任何子类对象，即上面的例子。
2.父类作为返回值类型，也可接收任何子类对象。
其实说白了，父类就可以当作一个大类型使用。

###  方法重写
子类对父类的方法不满意，重新写方法，但返回值类型、方法名、参数类型以及个数需与父类的方法保持一致（重写遵循"运行期"绑定，看对象的类型来调用方法）。

ps: 方法的重载overload：出现在同类中，方法同名；参数类型或个数不相同；与返回值、与访问修饰符无关（重载遵循"编译期"绑定，看引用的类型来绑定方法）。

方法重写的规则：
两同（方法名、参数列表）、
两小（返回值类型【基本类型和void:子类与父类的返回值类型必须相等；引用类型：子类的返回值类型比父类的辈份相同或更小】、抛出的异常）；
一大（访问权限不能比父类的更严格，因为父类要调用子类重写的方法？）；
两不能（是类还是对象的方法要统一、private方法不能被重写）。
ps: Liskov替换原则，子类对象可以被当成父类对象使用。如果可以降低子类的访问权限，那就违反了这一原则了。[参考](https://blog.csdn.net/xiexingshishu/article/details/53690033)

构造方法不能被继承、重写！！！

继承、方法重写，是多态的实现基础。

### final修饰的，不能被重写 why
 [参考，虽然写的不算好](https://www.cnblogs.com/xiaobingzi/p/10819884.html)
 用final关键字修饰方法，它表示该方法被子类继承，但不能被子类的覆盖。
 这种使用方式主要是从设计的角度考虑，即明确告诉其他可能会继承该类的程序员，不希望他们去覆盖这个方法。
 类中所有的private方法都隐式地指定为是final的，由于无法在类外使用private方法，所以也就无法覆盖它。（private 的方法没必要加 final 因为本身就是不可被覆写。）
 final修饰的类是无法被继承的。它的方法也是final的。
 
 Immutable设计模式




## 泛型
`<? extends T>`表示类型的上界，也就是说，参数化的类型可能是 T 或者 T 的
子类。例如，下面的写法都是合法的赋值语句：
`List<?extends Number> list = new ArrayList<Number>();`
`List<? Extends Number> list = new ArrayList<Integer>(); `// Integer 是 Number 的子类
`List<? Extends Number> list = new ArrayList<Float>(); `// Float 也是 Number 的子类
`<? extends T>`被设计为用来读数据的泛型（只能读取类型为 T 的元素） ，原因如下：
（1）在上面赋值的示例中，对读数据进行分析
1） 不管给 list 如何赋值， 可以保证 list 里面存放的一定是 Number 类型或其子类， 因此，
可以从 list 列表里面读取 Number 类型的值。
2）不能从 list 中读取 Integer，因为 list 里面可能存放的是 Float 值，同理，也不可以从
list 里面读取 Float。
（2）对写数据进行分析
1）不能向 list 中写 Number，因为 list 中有可能存放的是 Float。
2）不能向 list 中写 Integer，因为 list 中有可能存放的是 Float。
3）不能向 list 中写 Float，因为 list 中有可能存放的是 Integer。
从上面的分析可以发现，只能从 List<? extends T> 读取 T，因为无法确定它实际指向列
表的类型，从而无法确定列表里面存放的实际的类型，所以，无法向列表里面添加元素。


`<? super T>`表示类型下界，也就是说，参数化的类型是此类型的超类型（父类型） 。
`List<? super Float>list = new ArrayList<Float>()`
`List<? super Float>list = new ArrayList<Number>(); `// Number 是 Float 的父类
`List<? super Float>list = new ArrayList<Object>(); `// Object 是 Number 的父类
`<? super T>`被设计为用来写数据的泛型（只能写入 T 或 T 的子类类型） ，不能用来读，
分析如下：
（1）读数据
无法保证 list 里面一定存放的是 Float 类型或 Number 类型， 因为有可能存放的是 Object
类型，唯一能确定的是 list 里面存放的是 Object 或其子类，但是无法确定具体子类的类型。
正是由于无法确定 list 里面存放数据的类型，因此，无法从 list 里面读取数据。
（2）写数据
1）可以向 list 里面写入 Float 类型的数据（不管 list 里面实际存放的是 Float、Number
或者 Object， 写入 Float 都是允许的） ； 同理， 也可以向 list 里面添加 Float 子类类型的元素。
2） 不可以向 list 里面添加 Number 或 Object 类型的数据， 因为 list 中可能存放的是 Float
类型的数据。
下面给出两个泛型使用的场景：
```
public class Collections
{
public static <T> void copy(List<? super T> dest, List<? extends T> src)
{
for (int i=0; i<src.size(); i++)
dest.set(i,src.get(i));
}
}
```
