# mysql逻辑架构
![mysql架构图](https://img-blog.csdn.net/20170304104845780?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvUmV0dXJuX1RydWVfaGFuZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

1. 第一层：处理客户端连接、授权认证等。
2. 第二层：服务器层，负责查询语句的**解析、优化、缓存以及内置函数的实现、存储过程**等。
3. 第三层：存储引擎，负责MySQL中数据的存储和提取。MySQL中事务是由存储引擎实现的。MySQL支持事务的存储引擎有InnoDB、NDB Cluster等，其中InnoDB的使用最为广泛；其他存储引擎不支持事务，如MyIsam、Memory等。

每个连接都会在mysql服务端产生一个线程（内部通过线程池管理线程），比如一个select语句进入，mysql首先会在查询缓存中查找是否缓存了这个select的结果集，如果没有则继续执行 解析、优化、执行的过程；否则会之间从缓存中获取结果集。  

MySQL解析查询会创建内部数据结构（解析树），然后对其进行各种优化，包括重写查询，决定表的读取顺序，以及选择合适的索引等。 （用户可以通过特殊的关键字提示优化器，影响它的决策过程。也可以请求优化器解释优化过程的各个因素）

[MySQL原理与实践,一共六篇](https://blog.csdn.net/qq_25827845/article/details/90544530)
 
 
# 存储引擎
mysql数据库支持插件式存储引擎。就是说支持多种存储引擎，甚至用户可以按照自己的需要定制和使用自己的存储引擎。  
mysql5.5之前默认存储引擎是MyISAM，5.5后改为InnoDB。
[MySQL数据库各个版本的区别、以及不同引擎的适用环境](https://blog.csdn.net/ruziwang/article/details/79345180) 

# 索引
是一种优化查询的数据结构。 
如果经常用于count和max操作的字段，可以为其添加索引；
 
## 索引可选的数据结构
常用的有哈希表、完全平衡二叉搜索树、B树、B+树等数据结构。  

哪个数据结构更适合从磁盘中读取数据，或者哪个数据结构能够提高磁盘的IO效率? 

MySQL中的索引是B+树实现的，MySQL为何选择使用B+树？得看看其他数据结构实现的索引的特点。 

[MySQL索引底层数据结构及原理深入分析](https://mp.weixin.qq.com/s?__biz=MzUxNTQyOTIxNA==&mid=2247484041&idx=1&sn=76d3bf1772f9e3c796ad3d8a089220fa&chksm=f9b784b8cec00dae3d52318f6cb2bdee39ad975bf79469b72a499ceca1c5d57db5cbbef914ea&token=585677913&lang=zh_CN#rd)

[数据库索引原理](https://www.cnblogs.com/klb561/p/10666296.html)

### 哈希表  
比如给name字段建立hash索引:   
首先数据库底层会计算name字段各行值对应的hash值作为数组下标，其中可能会有hash冲突，存储对应的那一行数据的地址。  
当直接执行`select * from users where name = 'tom';`的时候，数据库会计算'tom'的hash值，得到数组下标，然后直接从数据中取出数据并拿到锁对应的那一行数据的地址，进而在数据表文件中查询那一行数据。  
但是当执行`select * from users where name > 'tom';`时，索引将不再起作用。  
**哈希表并不是有序的，可以快速的精确查询，但是不支持范围查询**。所以只适合做等值查询，区间查询的效率很低！好像字典里的索引去掉了排序。  

### 二叉树
依次插入1、2、3、4、5...二叉树在某些场景下退化成了链表。  
链表的查找需要从头部遍历，这时候和没加索引从表的第一行遍历没什么太大区别。

>一次磁盘IO的大小,mysql对这个节点大小设置的是16K，用下面这个SQL就是可以查到 show clobal status like 'Innodb_page_size' 。
          

### 红黑树
是一种平衡二叉树，高度会很容易上去，eg:7条记录，树的高度就达到了4层。树的高度过高导致查询效率变慢。查找时树越高遍历次数会越多。

### B-Tree
同样的数据，B树表示的要比平衡二叉搜索树要 "矮",原因在于B树中的**n叉，且一个节点可以存储多个元素**。
![](https://upload-images.jianshu.io/upload_images/10436362-27ab5b6a156acbed.png?imageMogr2/auto-orient/strip|imageView2/2/w/624/format/webp)
```
叶节点具有相同的深度，叶节点的指针为空

所有索引元素不重复

节点中的数据索引从左到右递增排序
```

B-Tree查找大于20 的元素那得多麻烦，先找出第一个节点中大于20的全部元素，接着从根节点去遍历找下一个叶子节点。  
没有指针每次都要从根节点开始查找然后合并，非常慢。

### B+树/多叉平衡树
![](https://upload-images.jianshu.io/upload_images/5959612-40926cd74ad0bc6c.png?imageMogr2/auto-orient/strip|imageView2/2/w/598/format/webp)
B+树是B树的升级版。  
```
非叶子节点不存储data，只存储索引（冗余），可以放更多的索引

叶子节点包含所有索引字段

叶子节点用双向的指针连接，提高区间访问的性能
```
同样的元素，B+树的表示要比B树要 "胖"，原因在于所有的**叶子结点包含了全部元素的信息**，及指向含这些元素记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。  
非叶子节点也会冗余一份所有的中间节点元素，它们是最大（或最小）元素。  

#### B+树作为索引的优势  
存更多的冗余索引了，意味着分叉就更多了，意味着叶子节点就能存储更多的数据了。  
提取叶子节点的一些处于中间位置的数据作为冗余索引，查找的时候从根节点开始查找，先把根节点加载到内存里去，然后在内存里去比对。  
把中间的元素提取出来做冗余元素，为的是查找效率更高。



提高查询索引时的磁盘IO效率，并且可以提高范围查询的效率，并且B+树里的元素也是有序的，叶子节点形成有序链表，便于范围查询。
[参考的这篇博客](https://www.cnblogs.com/blogtech/p/10530794.html)

>可以算一下16K的节点可以存多少对也就是多少个索引，8b+6b=14b，16K /14b=1170个索引，叶子节点有索引有data元素，假设占1K，那一个节点就放16K/1K=16个元素，假设树高是3，所有节点都放满，能放多少数据？可以算一下，1170*1170*16=21902400，2千多万，mysql设置16K的大小，数据就可以存2千多万就已经足够了吧，既能保证一次磁盘IO不要Load太多的数据 又能保证一次load的性能，即便表的数据在几千万的数量也能保证树的高度在一个可控的范围。
可以看一下几千万的数据表是不是加了索引几十毫秒几百毫秒就出结果了，所以就解释了几千万的表精确的使用索引后他的性能依旧比较高。  
>树的高度只有3的情况下就能存储2千多万的数据，即便某一个索引在叶子节点，那也就2、3次磁盘IO就能查找到，当然很快了。而且mysql底层的索引他的根节点，是常驻内存的，直接就放到内存的，查找叶子节点，一个2千万的数据放到B+Tree上面，要查找叶子节点，就只需要2次磁盘IO就搞定了，在内存里比对的时间基本可以忽略。
 


### B+树的结构和操作

#### 数据库插入和删除一条数据的过程在底层的过程


# 索引类型
## 主键索引
对于主健，oracle/sql server/mysql等都会自动建立唯一索引。  
主键索引是唯一索引的特殊类型。`= 唯一索引+ not null`
## 唯一索引
不允许两行具有相同的索引值。  
例外情况是，如果该字段被设置为允许NULL值，则插入该字段的值可以包含多个NULL值。  

>	它们的一些比较：
	(1)对于主健/unique constraint ， oracle/sql server/mysql等都会自动建立唯一索引；
	(2)主键不一定只包含一个字段，所以如果你在主键的其中一个字段建唯一索引还是必要的；
	(3)主健可作外健，唯一索引不可；
	(4)主健不可为空，唯一索引可；
	(5)主健也可是多个字段的组合；
	(6)主键与唯一索引不同的是：
	a.有not null属性；
	b.每个表只能有一个。
	(7)主键索引比普通索引得查询速度快。因为普通索引树上并没有完整得数据，而是先找到主键后，再到主键索引树上去获取所需得数据，这个操作被称为回表。当你没有设主键或者主键突然被删除时，会自动建立一个主键rowid，保证回表等功能的正常运行。  

## 普通索引
由关键字KEY或INDEX定义的索引。唯一任务是加快对数据的访问速度。

## 复合索引
在多个列上建立索引,这种索引叫做复合索引(组合索引)。  
尽量建联合索引，少建单值索引 。  
https://www.cnblogs.com/zjdxr-up/p/8319881.html

## FULLTEXT 全文索引
用于在一篇文章中，检索文本信息的。

# 索引优化
## 最左前缀原则
区分度最高的放在最左边。  
涉及到在建立复合索引的时候，如何安排索引内的字段顺序的问题。
如果我们创建了(username,sex,age)的复合索引，那么其实相当于创建了：
(username,sex,age)，(username,sex)、(username,age)、(username)四个索引，这被称为最佳左前缀特性。
因此我们在创建复合索引时应该将最常用作限制条件的列放在最左边，依次递减。
https://www.cnblogs.com/jiqing9006/p/10130928.html
[使用例子](https://zhuanlan.zhihu.com/p/352589128)

## 覆盖索引
通过复合索引实现。
explain 语句 extra列出现`using index`  
如果执行的语句是 `select ID from T where k between 3 and 5`，这时只需要查 ID 的值，而 ID 的值已经在 k 索引树上了，因此可以直接提供查询结果，不需要回表。也就是说，在这个查询里，索引 k 已经“覆盖了”我们的查询需求，我们称为覆盖索引。

## 索引下推
在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。

# 放弃使用索引而进行全表扫描的情况
1.在没有建索引的情况下，数据库查找某一条数据，就必须进行全表扫描了，对所有数据进行一次遍历，查找出符合条件的记录。
2.where 子句中对字段进行 null 值判断。
3.where 子句中使用!=或<>操作符
4.where 子句中使用 or 来连接条件
5.in 和 not in
6.使用非打头字母搜索
7.在 where 子句中对字段进行表达式操作
8.在where子句中对字段进行函数操作
9.在 where 子句中的“=”左边进行函数、算术运算或其他表达式运算
10.复合索引情况下，使用到该索引中的第一个字段作为条件时才能保证系统使用该索引，否则该索引将不会被使用，并且应尽可能的让字段顺序与索引顺序相一致。
https://blog.csdn.net/qq_36312376/article/details/80983410


# MySQL是如何存储索引和数据的
user表（InnoDB存储引擎）对应两个文件，order表（MYISAM存储引擎）对应3个文件。
.frm文件是存储的是表结构，两个存储引擎都一样。    
而InnoDB的.ibd文件是索引+数据，MYISAM的.MYI（I：index）和.MYD（D：data）文件分别是索引字段的索引结构和数据文件。  
也就是说MYISAM存储引擎的索引和数据是分开的，而InnoDB存储引擎的数据和索引是在一个文件里的。

# 聚簇索引 Clustered index————InnoDB索引实现
将数据存储与索引放到了一块，找到索引也就找到了数据。相对非聚簇索引，使用聚簇索引可以减少一次回表，加快数据访问。目的就是在相同结果集情况下，尽可能减少逻辑IO。  

聚簇索引的数据行实际上存放在索引的叶子页(leaf page)中，“聚簇”代表着数据行和相邻的键值紧凑地存储在一起。  

MYISAM的是非聚集索引，索引和数据是分开存储的。InnoDB的主键索引我们叫做聚集索引。

InnoDB通过主键聚集数据，如果不存在主键，InnoDB会选择唯一的非空索引，如果也没有唯一非空索引，**InnoDB隐式定义一个主键**来作为聚簇索引。一张表中只能存在一个聚簇索引。

ps：非聚簇索引都是辅助索引，像复合索引、前缀索引、唯一索引，辅助索引叶子节点存储的不再是行的物理位置，而是主键值。

>如果涉及到大数据量的排序、全表扫描、count之类的操作的话，还是MyISAM占优势些，因为索引所占空间小，这些操作是需要在内存中完成的。

# 为什么InnoDB表必须有主键，并且推荐使用整型的自增主键?
自增主键可以保证数据顺序增加，如果不是顺序增加，会引起B+Tree叶子节点因为插入导致的数据检索，**页分裂**和保持顺序等消耗，而顺序增加只需要在B+Tree最后叶子节点加入就可以了。

uuid——使用UUId作为主键，数据存储稀疏，这就会出现聚簇索引有可能有比全表扫面更慢。

主键的值是顺序的，所以 InnoDB 把每一条记录都存储在上一条记录的后面。当达到页的最大填充因子时（InnoDB 默认的最大填充因子是页大小的 15/16，留出部分空间用于以后修改），下一条记录就会写入新的页中。一旦数据按照这种顺序的方式加载，主键页就会近似于被顺序的记录填满（二级索引页可能是不一样的）

1.主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小。    
2.索引的维护的主要代价是由于有序性的维护引起的，如果每次插入一条新记录，都是追加操作，都不涉及到挪动其他记录，也不会触发叶子节点的分裂，这样就可以减少索引的维护代价。

>建议在大量插入新行后，选在负载较低的时间段，通过OPTIMIZE TABLE优化表，因为必须被移动的行数据可能造成碎片。使用独享表空间可以弱化碎片












 
