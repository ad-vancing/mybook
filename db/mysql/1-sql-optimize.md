用explain去看一下执行计划

table：表示属于哪张数据表

**type**：最重要的参数，连接类型。从最好到最差的连接类型为const，eq_reg，ref，range，index和ALL。一个好的SQL语句至少要达到range级别。杜绝出现all级别。

**possible_keys**：显示可能应用在这张表中的索引。如果为null，则表示没有可能的索引。

**key**：实际使用的索引名。如果为null，则表示没有使用索引。

key_len：使用的索引的长度，在不损失精确性的情况下，长度越短越好。

ref：表示索引的哪一列被使用了，如果可能的话，是一个常数。

**rows**：显示 MySQL 认为它执行查询时必须检查的行数，是个预估值。

**filtered：** 显示了通过条件过滤出的行数的百分比估计值。
**extra**：详细说明。

## 1.1 排除缓存干扰

8.0以上的版本就不用担心这个问题，如果是8.0之下的版本，记得排除缓存的干扰。

如果我们当前的MySQL版本支持缓存而且我们又开启了缓存，那每次请求的查询语句和结果都会以key-value的形式缓存在内存中的，大家也看到我们的结构图了，一个请求会先去看缓存是否存在，不存在才会走解析器。

执行SQL的时候，记得加上SQL NoCache去跑SQL，这样跑出来的时间就是真实的查询时间了。

## 1.2 **统计的行数就是完全对的么？索引一定会走到最优索引么？**

为啥行数只是个近视值呢？

MySQL中数据的单位都是页，MySQL又采用了采样统计的方法，采样统计的时候，InnoDB默认会选择N个数据页，统计这些页面上的不同值，得到一个平均值，然后乘以这个索引的页面数，就得到了这个索引的基数。

发现explain的结果预估的rows值跟实际情况差距比较大，用analyze table tablename 就可以重新统计索引信息。

MySQL索引可能走错也很好理解，如果走A索引要扫描100行，B所有只要20行，但是他可能选择走A索引，你可能会想MySQL是不是有病啊，其实不是的。

一般走错都是因为优化器在选择的时候发现，走A索引没有额外的代价，比如走B索引并不能直接拿到我们的值，还需要回到主键索引才可以拿到，多了一次回表的过程，这个也是会被优化器考虑进去的。发现走A索引不需要回表，没有额外的开销，所以选了性能低下的。

force index强制走正确的索引。

# 2、覆盖索引

在自己的索引上就查到自己想要的信息，不要回表去主键索引查了。

由于覆盖索引可以减少树的搜索次数，显著提升查询性能，所以使用覆盖索引是一个常用的性能优化手段。

# 3、联合索引

3.1 要思考索引占据的空间。

3.2 最左匹配原则

如果有这样的联合索引，大家也没必要去新建一个商品名称单独的索引了。

3.3 索引下推（官方优化 index condition pushdown）

在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。

# 4、**唯一索引普通索引选择**

## 4.1 change buffer

当需要更新一个数据页时，如果数据页在内存中就直接更新，而如果这个数据页还没有在内存中的话，在不影响数据一致性的前提下，InooDB会将这些更新操作缓存在change buffer中，这样就不需要从磁盘中读入这个数据页了。

在下次查询需要访问这个数据页的时候，将数据页读入内存，然后执行change buffer中与这个页有关的操作，通过这种方式就能保证这个数据逻辑的正确性。

将数据从磁盘读入内存涉及随机IO的访问，是数据库里面成本最高的操作之一，change buffer因为减少了随机磁盘访问，所以对更新性能的提升是会很明显的。

将change buffer中的操作应用到原数据页，得到最新结果的过程称为merge。

除了访问这个数据页会触发merge外，系统有后台线程会定期merge。在数据库正常关闭（shutdown）的过程中，也会执行merge操作。

对于唯一索引来说，所有的更新操作都要先判断这个操作是否违反唯一性约束。

要判断表中是否存在这个数据，而这必须要将数据页读入内存才能判断，如果都已经读入到内存了，那直接更新内存会更快，就没必要使用change buffer了。

因此，唯一索引的更新就不能使用change buffer，实际上也只有普通索引可以使用。

merge的时候是真正进行数据更新的时刻，而change buffer的主要目的就是将记录的变更动作缓存下来，所以在一个数据页做merge之前，change buffer记录的变更越多（也就是这个页面上要更新的次数越多），收益就越大。

对于写多读少的业务来说，页面在写完以后马上被访问到的概率比较小，此时change buffer的使用效果最好，这种业务模型常见的就是账单类、日志类的系统。

假设一个业务的更新模式是写入之后马上会做查询，那么即使满足了条件，将更新先记录在change buffer，但之后由于马上要访问这个数据页，会立即触发merge过程。这样随机访问IO的次数不会减少，反而增加了change buffer的维护代价，所以，对于这种业务模式来说，change buffer反而起到了副作用。

# 5、前缀索引

**可以建立一个区分度很高的前缀索引，达到优化和节约空间的目的。**

可以定义字符串的一部分作为索引。默认地，如果你创建索引的语句不指定前缀长度，那么索引就会包含整个字符串。

使用前缀索引，定义好长度，就可以做到既节省空间，又不用额外增加太多的查询成本。

但是前缀索引，即使你的联合索引已经包涵了相关信息，他还是会回表，因为他不确定你到底是不是一个完整的信息。

## 5.1 **很长的字段，想做索引我们怎么去优化他呢？**

如substring()函数截取掉前面的，然后建立索引；又如身份证都是区域开头的，同区域的人很多，那怎么做良好的区分呢？REVERSE（）函数翻转一下，区分度可能就高了。

只要区分度过高，都可以。但是需要注意调用函数也是一次开销，同时也有一些坑。

### 函数的坑：

1）对索引字段做函数操作，可能会破坏索引值的有序性，因此优化器就决定放弃走树搜索功能。这个时候大家可以用一些取巧的方法，比如 select * from tradelog where id + 1 = 10000 就走不上索引，select * from tradelog where id = 9999就可以。

2）隐式类型转换。select * from t where id = 1 如果id是字符类型的，1是数字类型的，你用explain会发现走了全表扫描，根本用不上索引，为啥呢？

因为MySQL底层会对你的比较进行转换，相当于加了 CAST( id AS signed int) 这样的一个函数，上面说过函数会导致走不上索引。

3）隐式字符编码转换。

如果两个表的字符集不一样，一个是utf8mb4，一个是utf8，因为utf8mb4是utf8的超集，所以一旦两个字符比较，就会转换为utf8mb4再比较。转换的过程相当于加了CONVERT(id USING utf8mb4)函数，用到函数就用不上索引了。

# 6、MySQLflush

redo log总会找个时间去更新到磁盘，这个操作就是flush。

**那什么时候会flush呢？**

1）InnoDB的redo log写满了，这时候系统会停止所有更新操作，把checkpoint往前推进，redo log留出空间可以继续写。

2）系统内存不足，当需要新的内存页，而内存不够用的时候，就要淘汰一些数据页，空出内存给别的数据页使用。如果淘汰的是“脏页”，就要先将脏页写到磁盘。

在更新之前，当内存数据页跟磁盘数据页内容不一致的时候，我们称这个内存页为“脏页”。

内存数据写入到磁盘后，内存和磁盘上的数据页的内容就一致了，称为“干净页“。

3）MySQL认为系统“空闲”的时候，只要有机会就刷一点“脏页”。

4）MySQL正常关闭，这时候，MySQL会把内存的脏页都flush到磁盘上，这样下次MySQL启动的时候，就可以直接从磁盘上读数据，启动速度会很快。

MySQLflush 时会突然卡顿，**怎么做才能把握flush的时机呢？**

innodb_io_capacity这个参数，它会告诉InnoDB你的磁盘能力（设置低了会导致脏页累积），这样InnoDB才能知道需要全力刷脏页的时候，可以刷多快。

在MySQL 8.0中，innodb_flush_neighbors参数的默认值已经是0了，不产生连带制。

# 其他杂的：

select 写法：

1、SELECT语句务必指明字段名称

SELECT*增加很多不必要的消耗（CPU、IO、内存、网络带宽）；

增加了使用覆盖索引的可能性；

当表结构发生改变时，前断也需要更新。

所以要求直接在select后面接上字段名。

2、子查询的优化

通常情况下，需要把子查询优化为join查询，

但在优化时要注意关联键是否有一对多的关系，如果有，是可能会出现重复数据的。所以如果存在一对多关系，则应该使用distinct进行限制。例如：

select [t.id](http://t.id/) from t where [t.id](http://t.id/) in (select k.kid from k);

优化成：

select distinct [t.id](http://t.id/) from t join k on [t.id](http://t.id/) = k.kid;

3、SQL语句中IN包含的值

MySQL对于IN做了相应的优化，即将IN中的常量全部存储在一个数组里面，而且这个数组是排好序的。但是如果数值较多，产生的消耗也是比较大的。再例如：select id from t where num in(1,2,3) 对于连续的数值，能用between就不要用in了；再或者使用连接来替换。

4、区分in和exists、not in和not exists

select * from 表A where id in (select id from 表B)

上面SQL语句相当于

select * from 表A where exists(select * from 表B where [表B.id=表A.id](http://xn--b-e20d.xn--id%3Da-t22r.id/))

区分in和exists主要是造成了驱动顺序的改变（这是性能变化的关键），如果是exists，那么以外层表为驱动表，先被访问，如果是IN，那么先执行子查询。

所以IN适合于外表大而内表小的情况；

EXISTS适合于外表小而内表大的情况。

就是先执行查小表的，内存少放一些。

5、关于not in和not exists，推荐使用not exists，不仅仅是效率问题，not in可能存在逻辑问题。如何高效的写出一个替代not exists的SQL语句？最好使用 join 代替。

原SQL语句：

select colname … from A表 where a.id not in (select b.id from B表)

高效的SQL语句：

select colname … from A表 Left join B表 on a.id = b.id where b.id is null

6、避免索引失效

- 使用单表查询时，相同字段尽量不要用 OR，因为可能导致索引失效，可以使用 UNION 替代；
- 避免在where子句中对字段进行表达式操作（函数）
- 避免隐式类型转换
- 避免在where子句中对字段进行null值判断

对于null的判断会导致引擎放弃使用索引而进行全表扫描。

所以写数据尽可能不要赋值为null。

- 对于联合索引来说，要遵守最左前缀法则

举列来说索引含有字段id、name、school，可以直接用id字段，也可以id、name这样的顺序，但是name;school都无法使用这个索引。所以在创建联合索引的时候一定要注意索引字段顺序，常用的查询字段放在最前面。

- 不建议使用%前缀模糊查询

例如LIKE“%name”或者LIKE“%name%”，这种查询会导致索引失效而进行全表扫描。但是可以使用LIKE “name%”。

那如何查询%name%？——全文索引

[https://www.cnblogs.com/yangyxd/p/15252691.html](https://www.cnblogs.com/yangyxd/p/15252691.html)

- 必要时可以使用force index来强制查询走某个索引

有的时候MySQL优化器采取它认为合适的索引来检索SQL语句，但是可能它所采用的索引并不是我们想要的。这时就可以采用forceindex来强制优化器使用我们制定的索引。

- 注意范围查询语句

对于联合索引来说，如果存在范围查询，比如between、>、<等条件时，会造成后面的索引字段失效。

- 关于JOIN优化

LEFT JOIN A表为驱动表，INNER JOIN MySQL会自动找出那个数据少的表作用驱动表，RIGHT JOIN B表为驱动表

表关联查询时务必遵循 **小表驱动大表** 原则！

j**oin on的字段，类型要一致，demo：[https://blog.csdn.net/yongcto/article/details/44083095](https://blog.csdn.net/yongcto/article/details/44083095)**

- 分表，可根据业务字段尾数中的个位或十位或百位（以此类推）做表名达到分表的目的；
- 分库，可根据业务字段尾数中的个位或十位或百位（以此类推）做库名达到分库的目的；
- 表分区，类似于硬盘分区，可以将某个时间段的数据放在分区里，加快查询速度，可以配合 **分表 + 表分区** 结合使用；

行锁、表锁、间隙锁、同步场景……

# mysql服务连接数设置

[https://www.cnblogs.com/justinyang/p/8947030.html](https://www.cnblogs.com/justinyang/p/8947030.html)


当语句执行时间较长时，通过日志的方式进行记录，这种方式就是慢查询的日志。

1、**临时开启慢查询日志**（如果需要长时间开启，则需要更改mysql配置文件）

set global slow_query_log = on;

**2、临时设置慢查询时间临界点**  查询时间高于这个临界点的都会被记录到慢查询日志中（如果需要长时间开启，则需要更改mysql配置文件）。

set long_query_time = 1;

现在起，所有执行时间超过1秒的sql都将被记录到慢查询文件中（如 /data/mysql/mysql-slow.log）。

**3、设置慢查询存储的方式**

set globle log_output = file;

show variables like ‘%log_output%’

默认是none,我们可以设置为table或者file,如果是table则慢查询信息会保存到mysql库下的slow_log表中

**4、查询慢查询日志的开启状态和慢查询日志储存的位置**

show variables like '%quer%';

slow_query_log : 是否已经开启慢查询

slow_query_log_file : 慢查询日志文件路径

long_query_time :  超过多少秒的查询就写入日志

log_queries_not_using_indexes 如果值设置为ON，则会记录所有没有利用索引的查询(性能优化时开启此项,平时不要开启)

# 慢查询日志分析

mysqldumpslow是mysql安装后就自带的工具，用于分析慢查询日志

mysqldumpslow -t 10 /data/mysql/mysql-slow.log 

显示出慢查询日志中最慢的10条sql