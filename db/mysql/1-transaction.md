# mysql事务怎么实现
https://blog.csdn.net/Baisitao_/article/details/104723795

MySQL事务的ACID四大特性、

undo log和redo log分别实现了原子性和持久性

log持久化的三种方式

数据库并发下的五类问题

四种隔离级别

RR隔离级别下select幻读通过MVCC机制解决

select ... lock in share mode/select ... for update/insert/update/delete的幻读通过间隙锁来解决。



# 事务
要么都做，要么都不做的。
对于同时运行的多个事务, 当这些事务访问数据库中相同的数据时, 如果没有采取必要的隔离机制, 就会导致各种并发问题：  
1. **脏读** :A事务中读取到了B事务中尚未提交的数据。
 
2. **不可重复读** ：同一个事务中两次读取的数据的内容不一致。其他事务对同一条数据update了（提交了），时间上的问题。

3. **幻读**：同一个事务中两次count的数量不一致。其他事务对该表insert或delete了（提交了）。
[幻读的正确理解](https://zhuanlan.zhihu.com/p/360254683)
>幻读，并不是说事务中多次读取获取的结果集不同，幻读更重要的是某次的 select 操作得到的结果集所表征的数据状态无法支撑后续的业务操作。更为具体一些：select 记录不存在，准备插入此记录，但执行 insert 时发现此记录已存在，无法插入，如同产生了幻觉。

## 事务中数据的隔离级别
数据库系统必须具有隔离并发运行各个事务的能力, 使它们不会相互影响, 避免各种并发问题。
`一个事务与其他事务隔离的程度称为隔离级别。` 数据库规定了多种事务隔离级别, 不同隔离级别对应不同的干扰程度, `隔离级别越高, 数据一致性就越好, 但并发性越弱`。

总结：写读是脏读，读写读是不可重复读，where insert where是幻读。

## 事务隔离级别

1.`Serializable` 串行化  
最严格、最安全的级别，可读，不可写。像java中的锁，相当于锁表，对于所有的query，即使是查询，也会加上读锁，避免其他事务对数据的修改。操作数据必须等待另一个事务结束。    
可以解决脏读、不可重复读和幻读，但事务串行执行，资源消耗最大，数据库系统的并发处理能力大大降低,所以它不会被用到生产系统中。

2.`REPEATABLE READ`可重复读（mysql默认）     保证了在同一个事务中多次读取同样记录的结果是一致的（读的都是事务开始时的数据）。因为`只能读取在它开始之前已经提交的事务对数据库的修改，在它开始以后，所有其他事务对数据库的修改对它来说均不可见，避免了“脏读取”和“不可重复读”的情况，但当其他事务往表中新增数据时，有幻读的问题。`   不过mysql的innodb引擎采用了多版本并发控制（MVCC）机制可以解决幻读问题。  
```
  mysql环境做个实验：  
  1、session1启动一个事务`start transaction;`；
  2、执行一条查询语句`SELECT * FROM class WHERE teacher_id=1;`，观察结果;
  3、session2启动一个事务，执行更新或删除`teacher_id=1`的命令，然后执行`commit;`，
  4、在session1 中再次查看`teacher_id=1`行，发现并没有被更新或删除。
这里变体现了“可重复读”，不管别的事物修改或删除了什么，即便是提交了，在当前事务下，重复读取的结果是一样的。
  补充：
  4、session2 delete id =1 的数据后，session1 里 id =1 的数据仍然可见，如果此时 session1 执行 update id =1 的数据成功（affected 1 rows），这个就是幻读问题。
 实际情况是： session1 执行 update id =1 会发生阻塞，只有在 session2 commit之后，才会执行成功（affected 0 rows），这里可见mysql是通过加锁的方式解决了幻读（应该用insert id相等的例子更好）。

```
3.`READ COMMITTED` 读取已提交（oracle默认，开发里常用）  
其他事务对数据库的修改，只要已经提交，其修改的结果就是可见的，与这两个事务开始的先后顺序无关。这种隔离等级避免了脏读，但多次读取的数据结果可能出现不一致的情况，即解决不可重复读和幻读问题。  
可以修改数据库的事务隔离级别`set transaction isolation level read committed;`重复上面的实验，看看有没有不可重复读和幻读问题。


4`Read Uncommitted` 读未提交  
查询可以读取到其他事务正在修改的数据，即使其他事务的修改还没有提交。这种隔离等级哪个问题都不能解决。  

Oracle 支持的 2 种事务隔离级别：READ COMMITED, SERIALIZABLE, Oracle 默认的事务隔离级别为: READ COMMITED 。
Mysql 支持 4 中事务隔离级别. Mysql 默认的事务隔离级别为: REPEATABLE READ。

## mysql 幻读
[SQL 标准中规定的 RR 并不能消除幻读，但是 MySQL 的 RR 可以，靠的就是 Gap 锁。在 RR 级别下，Gap 锁是默认开启的，而在 RC 级别下，Gap 锁是关闭的。](https://joonwhee.blog.csdn.net/article/details/106893197)
 
## mysql一些事务相关的命令
1.查看当前会话（每个数据库连接）隔离级别：`select @@tx_isolation;` 或`select @@transaction_isolation;`； 
2.查看系统当前隔离级别：`select @@global.tx_isolation;`  
3.设置当前会话隔离级别：`set session transaction isolatin level repeatable read;`  
4.设置系统当前隔离级别：`set global transaction isolation level repeatable read;`  
5.命令行，开始事务时：`set autocommit=on;` 或者 `start transaction;`  
6.让当前会话的事务自动提交（更新、插入操作后会自动提交）：`set @@session.autocommit=1;`
7.设置手动提交事务：`set autocommit = 0;` 
8.查看当前事务id：`SELECT TRX_ID FROM INFORMATION_SCHEMA.INNODB_TRX  WHERE TRX_MYSQL_THREAD_ID = CONNECTION_ID();`
表中可以查到正在执行的事务信息。
 
## Multiversion Concurrency Control多版本并发控制技术
它使得大部分支持行锁的事务引擎,不再单纯的使用行锁来进行数据库的并发控制,取而代之的是,把数据库的行锁与行的多个版本结合起来,只需要很小的开销,就可以实现非锁定读,从而大大提高数据库系统的并发性能。  

### 原理
innodb对每一行加上了两个隐含的列，一列存储行被更新的”时间”，另一列存储行被删除的”时间”。   并不是绝对的时间，而是与时间对应的数据库系统的版本号，`每当一个事务开始的时候，innodb都会给这个事务分配一个递增的版本号，所以版本号也可以被认为是事务号`。  对于每一个”查询”语句，innodb都会把这个查询语句的版本号同这个查询语句对应的行的版本号进行对比，然后结合不同的事务隔离等级，来决定是否返回该行。  
每一行数据都可能存在多个版本，那么这些行组合起来得到的结果集的版本就更是不计其数，这就是数据库多版本的由来。MVCC就是通过事务发生的不同的时间点，与数据行的版本来进行对比，从而取回与事务开始的时间点相一致的数据，来实现非阻塞的一致读。

比如对于select语句，只有同时满足了下面两个条件的行，才会被返回:  
`1.行的被修改版本号小于或者等于该事务号；`  
`2.行的被删除版本号要么没有被定义（说明该行没有被删除过），要么大于事务的版本号（说明该行是被该事务后面启动的事务删除的，repeatable read隔离等级下，后开始的事务对数据的影响不应该被先开始的事务看见,所以该行应该被返回）。`  
[深入理解](https://blog.csdn.net/heroqiang/article/details/79024333)

比如INSERT语句，对新插入的行，行的更新版本被修改为该事务的事务号；  
对于删除,innodb直接把该行的被删除版本号设置为当前的事务号,相当于标记为删除,而不是实际删除；  
在更新行的时候,innodb会把原来的行复制一份到回滚段中,并把当前的事务号作为该行的更新版本。  

#### 优缺点
读取数据的时候,innodb几乎不用获得任何锁, 每个查询都通过版本检查,只获得自己需要的数据版本,从而大大提高了系统的并发度。  

为了实现多版本，innodb必须对每行增加相应的字段来存储版本信息，同时需要维护每一行的版本信息，而且在检索行的时候，需要进行版本的比较，因而会降低查询的效率;  
innodb还必须定期清理不再需要的行版本，及时回收空间，这也增加了一些开销。  
另外，数据库执行了大事务情况下，数据库仅是频繁更新，没有插入新数据，也会导致表空间占用越来越大，因为innodb会把被修改数据的前映像存放到称为回滚段的公共表空间中，而且对于索引和表中的行的多个版本，如果innodb来不及purge，或者这些行因为要提供一致读而不能被purge，就会占用越来越多的空间,甚至有可能短时间撑爆你的硬盘。所以应用程序中需要合理控制事务的大小！  
[优化](https://blog.csdn.net/zhangxm_qz/article/details/88196420)

另外，由于innodb的mvcc策略的实施，char数据类型相对于varchar类型几乎没有任何优势，反而varchar列可能节省更多的存储空间，建议使用varchar数据类型。？？？

MVCC由于其实现原理,只支持read committed和repeatable read隔离等级。

#### 禁用MVCC
MVCC本身不支持read uncommitted等级，所以可以通过设置transaction_isolation = read uncommitted 来禁用MVCC。  
但是任何改变innodb默认隔离等级的操作，都会起到innodb_locks_unsafe_for_binlog=off类似的效果，这会导致诸如insert into t select * from t_src 之类的语句不再给源表t_src加锁，也不再使用innodb的间隙锁，从而产生幻读，直接导致binlog中记录的sql语句不能正确的串行化，从而主从数据库的数据不再一致，而且基于binlog的增量备份也不再有效，所以除非不需要记录binlog，否则别这么做。当然我们可以这样做来优化从库的性能，因为从库不需要记录binlog。


参考：https://blog.csdn.net/lemon89/article/details/51477497

# 并发控制 Concurrency control
在多用户环境中，在同一时间可能会有多个用户更新相同的记录，这会产生冲突。这就是并发性问题。
>典型的冲突有：
1.丢失更新：一个事务的更新覆盖了其它事务的更新结果，就是所谓的更新丢失。例如：用户A把值从6改为2，用户B把值从2改为6，则用户A丢失了他的更新。
2.脏读：当一个事务读取其它完成一半事务的记录时，就会发生脏读取。例如：用户A,B看到的值都是6，用户B把值改为2，用户A读到的值仍为6。

为了解决这些并发带来的问题。 我们需要引入并发控制机制。  
mysql采用读写锁来进行并发控制。
两种锁的思想——乐观锁和悲观锁。


## 悲观锁
指的是对数据被外界（包括本系统当前的其他事务，以及来自外部系统的事务处理）修改持保守态度，因此，在整个数据处理过程中，将数据处于锁定状态，比如表锁，行锁。独占锁、java中 synchronized就是悲观锁。
依靠数据库提供的锁机制实现。适用于数据争用严重/重试代价大的场景。  
缺点：
在多线程竞争下，加锁、释放锁会导致比较多的上下文切换和调度延时，引起性能问题。
一个线程持有锁会导致其它所有需要此锁的线程挂起，对长事务而言，这样的开销往往无法承受。
如果一个优先级高的线程等待一个优先级低的线程释放锁会导致优先级倒置，引起性能风险。
[参考悲观锁实践](https://chenzhou123520.iteye.com/blog/1860954)

## 乐观锁
乐观锁假设认为数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则让返回用户错误的信息，让用户决定如何去做。即`冲突检测和数据更新`两步。乐观锁不能解决脏读的问题。ReadCommitted、REPEATABLE READ隔离级别是通过MVCC实现乐观锁的，还有hibernate中@Version注解。  

依靠数据版本记录机制实现。
可以通过使用时间戳（timestamp）字段也可以定义version字段（自增长的整数）作为版本标识,当读取数据时，将版本标识字段的值一同读出，在更新提交的时候检查当前数据库中数据的当前版本标识和自己更新前取到的版本标识进行对比，如果一致则予以更新，否则就是版本冲突返回给用户。
适用于数据争用不严重/重试代价不大/需要相应速度快的场景。
缺点：在高并发的情况下，乐观锁并不适合。因为致数据库会有很多的更新失败，处理异常再次执行的情况。

[乐观锁的实践](https://chenzhou123520.iteye.com/blog/1863407)
>了解下Compare and Swap(CAS)。
CAS是项乐观锁技术，当多个线程尝试使用CAS同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试。CAS是一种非阻塞式的同步方式。

>CAS 操作包含三个操作数 —— 内存位置（V）、预期原值（A）和新值(B)。如果内存位置的值与预期原值相匹配，那么处理器会自动将该位置值更新为新值。否则，处理器不做任何操作。无论哪种情况，它都会在 CAS 指令之前返回该位置的值。（在 CAS 的一些特殊情况下将仅返回 CAS 是否成功，而不提取当前值。）CAS 有效地说明了“我认为位置 V 应该包含值 A；如果包含该值，则将 B 放到这个位置；否则，不要更改该位置，只告诉我这个位置现在的值即可。”这其实和乐观锁的冲突检查+数据更新的原理是一样的。
[参考java对CAS的支持](https://blog.csdn.net/caisongcheng_good/article/details/79916873)

## 锁的粒度
提高并发性的方式就是让锁定的对象更有选择性，只锁定部分数据，而不是所有的资源，这就是锁粒度要考虑的问题。 

### 表锁table-level locking
MySQL数据库的MyISAM引擎支持表锁。
当你对一张表进行修改时，会锁死整张表，其他的请求需要在修改完成释放锁才能继续。

特点：开销小，加锁快;不会出现死锁;锁定粒度大，发生锁冲突的概率最高，并发度最低。
更适合于查询为主的场景。

MySQL最基本的锁策略，开销最小的策略。
MyISAM引擎中表锁分为表共享读锁(Table Read Lock)和表独占写锁(Table Write Lock)。
InnoDB引擎中表锁分为意向共享锁（IS）和意向排他锁（IX）。意向锁是InnoDB自动加的，不需要用户干预。

####表共享读锁Table Read Lock
对于读操作，可以增加读锁，一旦数据表被加上读锁，`其他请求可以对该表再次增加读锁，但是不能增加写锁`。（当一个请求在读数据时，其他请求也可以读，但是不能写，自己也不能写，因为一旦另外一个线程写了数据，就会导致当前线程读取到的数据不是最新的了。这就是不可重复读现象）
[实例](https://www.cnblogs.com/justinyang/p/8886588.html)

#### 表独占写锁Table Write Lock
对于写操作，可以增加写锁，`一旦数据表被加上写锁，这会阻塞其他用户对该表的所有读写操作`。（当一个请求在写数据时，其他请求不能执行任何操作，因为在当前事务提交之前，其他的请求无法看到本次修改的内容。这有可能产生脏读、不可重复读和幻读）

>读锁和写锁都是阻塞锁。读和写是串行的。同时请求的情况下，写进程先获得锁。
只有没有写锁时，其他读取用户才能获得读锁，读锁之间是不相互阻塞的。

#### 操作方式
MyISAM 在执行查询语句(SELECT)前,会自动给涉及的所有表加读锁,在执行更新操作 (UPDATE、DELETE、INSERT 等)前，会自动给涉及的表加写锁，这个过程并不需要用户干预，因此，用户一般不需要直接用LOCK TABLE命令给MyISAM表显式加锁。

如果用户想要显示的加锁可以使用以下命令：
`锁定表：LOCK TABLES tbl_name {READ | WRITE},[ tbl_name {READ | WRITE},…] `
`解锁表：UNLOCK TABLES `
注意：当使用 LOCK TABLES 时,不仅需要一次锁定用到的所有表,而且,同一个表在 SQL 语句中出现多少次,就要通过与 SQL 语句中相同的别名锁定多少次,否则也会出错!
[参考资料](https://www.hollischuang.com/archives/1728)

#### 意向共享锁IS
表示事务准备给数据行加入共享锁，也就是说一个数据行加共享锁前必须先取得该表的IS锁

#### 意向排他锁IX
类似上面，表示事务准备给数据行加入排他锁，说明事务在一个数据行加排他锁前必须先取得该表的IX锁。

### 行级锁row-level locking
InnoDB存储引擎既支持行级锁，也支持表级锁，但默认情况下是采用行级锁。
当你对一张表的某一行数据修改时，会锁死这一行数据，对表中其他的数据没影响。
行级锁可以最大程度地支持并发处理（最大锁开销），InnoDB和XtraDB，还有其他一些存储引擎中实现了行级锁，行级锁只在存储引擎层实现，而MySQL服务器层没有实现。  

特点：开销大，加锁慢;会出现死锁;锁定粒度最小,发生锁冲突的概率最低，并发度也最高。
适合于大量按索引条件并发更新少量不同的数据，同时又有并发查询的应用。

```
需要明确的指定主键，才会执行行级锁，否则执行的为表锁。
比如：
select * from job_info where id = 1 for update;  
那么上面这句，为行级锁。

而 select * from job_info where job_name = 'test' for update;
这句，就变成了表锁了

```

### 页级锁page-level locking
开销和加锁时间界于表锁和行锁之间;会出现死锁;锁定粒度界于表锁和行锁之间，并发度一般。
BDB 存储引擎。
#### 共享锁shared locks
也称为读锁，读锁允许多个连接可以同一时刻并发的读取同一资源,互不干扰。但任何事务都不能对数据进行修改（获取数据上的排他锁），直到已释放所有共享锁。
在查询语句后面增加`LOCK IN SHARE MODE`，Mysql会对查询结果中的每行都加共享锁。

#### 排它锁exclusive locks
也称为写锁，一个写锁会阻塞其他的写锁或读锁，保证同一时刻只有一个连接可以写入数据，同时防止其他用户对这个数据的读写。
在查询语句后面增加`FOR UPDATE`，Mysql会对查询结果中的每行都加排他锁。




## 死锁 
1. 多个事务不同顺序锁定资源时，会产生死锁， 
2. 多个事务同时锁定同一个资源，产生死锁。 
InnoDB目前处理死锁的方法是，将持有最小行级排他锁的事务进行回滚（相对比较简单的死锁回滚方法） 
越复杂的系统，越能检测到死锁的循环依赖，并立即返回一个错误，否则会导致出现非常慢的查询。
[参考资料1](https://www.2cto.com/database/201508/429967.html?honqdu=nr8b03)
[参考资料2](https://www.jianshu.com/p/95a0d10eb881)