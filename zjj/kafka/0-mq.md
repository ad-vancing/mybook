>MQ工作方式

MQ如何解决分布式事务

消息幂等性如何解决



# 什么是MQ
消息队列（Message Queue，简称MQ），从字面意思上看，本质是个队列，FIFO先入先出，只不过队列中存放的内容是message而已。
主要用途：不同进程Process/线程Thread之间通信。

## 什么场景适合使用消息队列
消息队列中间件是分布式系统中重要的组件，主要解决应用解耦，异步消息，流量削锋等问题，实现高性能，高可用，可伸缩和最终一致性架构。

### 系统解耦，方便扩展
如果某个系统A产出一份核心数据，可能下游无数的其他系统都需要这份数据来实现各种业务逻辑。
然后如果要是某个下游系统突然宕机了呢？系统A的调用代码里是不是会抛异常？那系统A的同学会收到报警说异常了，结果他还要去care是下游哪个系统宕机了。所以在实际的系统架构设计中，如果全部采取直接调用下游系统发送数据这种系统耦合的方式，会严重的影响上下游系统的开发和维护效率。

系统A可以把自己的一份核心数据发到MQ里， 通过Pub/Sub 发布订阅消息模型实现一对多通信，即广播。下游哪个系统感兴趣自己去消费即可，不需要了就取消数据的消费。

![图](https://upload-images.jianshu.io/upload_images/13589387-95c9134d8b5257bf?imageMogr2/auto-orient/strip|imageView2/2/w/769/format/webp)
[Kafka、ActiveMQ、RabbitMQ、RocketMQ 有什么优缺点？](https://blog.csdn.net/ThinkWon/article/details/104588612)

结合项目情况：将订单数据推送给大数据分析平台，用于实时监控、星火数据同步

### 异步调用提高响应效率
如果有一个系统调用链路，是系统A调用系统B，一般耗时20ms；系统B调用系统C，一般耗时200ms；系统C调用系统D，一般耗时2s
因为引入了系统C调用系统D这个步骤，导致最终链路执行时间是2秒多，直接将链路调用性能降低了10倍，这就是导致链路执行过慢的罪魁祸首。
如果业务流程支持异步化的话，是不是就可以考虑把系统C对系统D的调用抽离出去做成异步化的，不要放在链路中同步依次调用。

就像点个外卖，并不需要在你支付的一瞬间立马给你找好骑手

实现思路就是系统A -> 系统B -> 系统C，直接就耗费220ms后直接成功了，系统C就是发送个消息到MQ中间件里，由系统D消费到消息之后慢慢的异步来执行这个耗时2s的业务处理。

结合项目情况：亲情网下单流程较长，通过MQ拆分为异步调用，缩短响应时长

### 利用消息缓存实现流量削峰
写入MQ的速度可以尽可能地快，而处理消息的速度可以适当调整（或快、或慢）。很多场景下，不会立即处理消息，这是，可以在MQ中存储message，并在某一时刻再进行处理。

假设你有一个系统，平时正常的时候每秒可能就几百个请求，系统部署在8核16G的机器的上，正常处理都是ok的，每秒几百请求是可以轻松抗住的。
但是在高峰期一下子来了每秒钟几千请求，瞬时出现了流量高峰，此时你的选择是要搞10台机器，抗住每秒几千请求的瞬时高峰吗？
如果瞬时高峰每天就那么半个小时，接着直接就降低为了每秒就几百请求，如果你线上部署了很多台机器，那么每台机器就处理每秒几十个请求就可以了，这不是有点浪费机器资源吗？

此时我们就可以在应用前端加入消息队列，平时每秒几百请求可以轻松接收消息，到了瞬时高峰期，一下涌入每秒几千的请求，就可以积压在MQ里面，然后那一台机器慢慢的处理和消费。这个短暂的高峰期积压是 ok 的，因为等高峰期过了，再消费一段时间，MQ里积压的数据就消费完毕了。

如果业务场景允许异步削峰，高峰期积压一些请求在MQ里，然后高峰期过了，后台系统在一定时间内消费完毕不再积压的话，那就很适合用这种技术方案。
一般在秒杀活动中应用广泛：1.可以控制活动人数，超过此一定阀值的订单直接丢弃2.可以缓解短时间的高流量压垮应用(应用程序按自己的最大处理能力获取订单)。

结合项目情况：对于大量订单数据同步（流量等订单）？

## 使用消息队列存在的问题
- 系统可用性降低  
MQ 可能挂掉，导致整个系统崩溃
- 复杂性变高  
如何保证消息队列的高可用、怎么保证不发重复消息、不漏发消息，保证消息没有重复消费、不漏消费？怎么处理消息丢失的情况？怎么保证消息传递的顺序性？
- 一致性问题  
A 系统处理完了直接返回成功了，人都以为你这个请求就成功了；但是问题是，要是 BCD 三个系统那里，BD 两个系统写库成功了，结果 C 系统写库失败了，数据就不一致了。

所以消息队列实际是一种非常复杂的架构，引入它有很多好处，但是也得针对它带来的坏处做各种额外的技术方案和架构来规避掉，做好之后，你会发现系统复杂度提升了一个数量级，也许是复杂了 10 倍。但是关键时刻还是得用的。

# 不同消息队列产品的比较
目前使用较多的消息队列有ActiveMQ，RabbitMQ，ActiveMQ，ZeroMQ，Kafka，MetaMQ，RocketMQ。  
大部分都支持集群化、高可用部署架构、消息高可靠支持。  
对于MQ来说，网络传输只是它的一部分，更多需要处理的是消息存储、路由、Broker服务发现和查找、事务、消费模式 （ack、重投等）、集群服务等。

![](https://www.javazhiyin.com/wp-content/uploads/2020/04/java3-1587280402.png)


## Kafka
来自linkedin，主要特点是基于Pull的模式来处理消息消费，为超高吞吐量的实时日志采集、实时数据同步、实时数据计算等场景来设计。  
0.8开始提供了HA 机制，就是 replica 副本机制。  
不支持事务，适合产生大量数据的互联网服务的数据收集业务。  
Kafka 自身服务和消费者都需要依赖 Zookeeper。  
在大数据领域中配合实时计算技术（比如Spark Streaming、Storm、Flink）使用的较多。但是在传统的MQ中间件使用场景中较少采用。

## RabbitMQ
是使用Erlang语言开发的开源消息队列系统，基于`AMQP协议`来实现。RabbitMQ、Kafka 使用自己的协议。  
AMQP的主要特征是面向消息、队列、路由（包括点对点和发布/订 阅）、可靠性、安全。  
支持 AMQP（二进制），STOMP（文本），MQTT（二进制），HTTP（里面包装其他协议）等协议。  
更多用在企业系统内，对数据一致性、稳定性和可靠性要求很高的场景，对性能和吞吐量的要求还在其次。中小型公司使用RabbitMQ的比较多。
同时有非常完善便捷的后台管理界面可以使用。还支持集群化、高可用部署架构、消息高可靠支持，功能较为完善。
RabbitMQ的开源社区很活跃，较高频率的迭代版本，来修复发现的bug以及进行各种优化。结合erlang语言本身的并发优势，性能较好，但是不利于做二次开发和维护。
缺点：是基于erlang语言开发的，所以导致较为难以分析里面的源码，也较难进行深层次的源码定制和改造，毕竟需要较为扎实的erlang语言功底才可以。
在有大量消息堆积的情况下性能会下降。

>AMQP，即Advanced Message Queuing Protocol，高级消息队列协议，是应用层协议的一个开放标准，为面向消息的中间件设计。消息中间件主要用于组件之间的解耦，消息的发送者无需知道消息使用者的存在，反之亦然。 AMQP的主要特征是面向消息、队列、路由（包括点对点和发布/订阅）、可靠性、安全。 RabbitMQ是一个开源的AMQP实现，服务器端用Erlang语言编写，支持多种客户端，如：Python、Ruby、.NET、Java、JMS、C、PHP、ActionScript、XMPP、STOMP等，支持AJAX。用于在分布式系统中存储转发消息，在易用性、扩展性、高可用性等方面表现不俗。

## ActiveMQ 
ActiveMQ 和 RabbitMQ 都是AMQP 的一种具体实现，具体是基于STOMP协议。  
AcitveMQ 和 RabbitMQ 都支持 持久性或非持久性的信息交付。  
默认情况下，消息会存储到磁盘中，可以保证消息队列重启时数据的一致，避免消息的丢失。它们还支持同步和异步发送消息，前者对延迟有实质性影响。为了保证交付，这些代理使用消息确认，这也导致巨大的延迟代价。

老牌消息队列处理服务，已经在很多产品中得到应用，实现了JMS1.1规范，可以和spring-jms轻松融合，实现了多种协议，不够轻巧（源代码比RocketMQ多），对队列数较多的情况支持不好。

缺点：它的队列，只支持简单的JSON格式文本，对于JSON嵌套类的格式文本，一旦消息提交到服务器后，消费端程序无法及时取到消息。
服务器时不时产生拥堵，有时候几分钟，有时候十几分钟，消费端才会拿到数据。

## RocketMQ
是阿里开源的消息中间件，基于Java语言开发，具有高吞吐量、高可用性、适合大规模分布式系统应用的特点，同时还支持分布式事务等特殊场景。RocketMQ思路起源于 Kafka，但并不是Kafka的一个Copy，它对消息的可靠传输及事务性做了优化，目前在阿里集团被广泛应用于交易、充值、流计算、消息推送、日志 流式处理、binglog分发等场景。
https://www.cnblogs.com/xuwc/p/9034352.html
## ZeroMQ
是一个网络编程的Pattern库，将常见的网络请求形式（分组管理，链接管理，发布订阅等）模式化、组件化，简而言之socket之 上、MQ之下。
但只是一个异步消息库，在套接字的基础上提供了类似于消息代理的机制。
使用 ZeroMQ 的话，需要对自己的业务代码进行改造，不利于服务解耦。 













