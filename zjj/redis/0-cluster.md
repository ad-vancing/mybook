# Redis 的集群模式参考
https://juejin.cn/post/6844903981148274701

https://blog.csdn.net/saisai_in_csdn/article/details/106484724

https://zhuanlan.zhihu.com/p/424759752

# 主从模式
[一主N从配置文件的方式实现主从库的分离](https://blog.csdn.net/cuipeng0916/article/details/53704629)  
**一主多从。读写分离**。    
数据库分为两类，一类是主数据库（master），另一类是从数据库(slave）。  
主数据库可以进行读写操作，当写操作导致数据变化时会自动将数据同步给从数据库。而从数据库一般是只读的，并接受主数据库同步过来的数据。  

>为什么要采用读写分离的方式呢？  
如果不管是主库还是从库，都能接收客户端的写操作，那么，一个直接的问题就是：如果客户端对同一个数据（例如k1）前后修改了三次，每一次的修改请求都发送到不同的实例上，在不同的实例上执行，那么，这个数据在这三个实例上的副本就不一致了（分别是v1、v2和v3）。在读取这个数据的时候，就可能读取到旧的值。  
如果我们非要保持这个数据在三个实例上一致，就要涉及到加锁、实例间协商是否完成修改等一系列操作，但这会带来巨额的开销，当然是不太能接受的。

## 主从库同步过程
主库生成RDB文件和传输RDB文件。

主库将数据同步给从库的过程中，主库不会被阻塞，仍然可以正常接收请求。期间发生的写操作，主库会在内存中用专门的**replication buffer**，记录，之后再发送给从库。

为了避免主库同步数据的压力，使用级联的方式（使用 replicaof ），让从库a与其他从库建立下一个级别的主从关系，继续数据的同步。

>一旦主从库完成了全量复制，它们之间就会一直维护一个网络连接，主库会通过这个连接将后续陆续收到的命令操作再同步给从库，这个过程也称为**基于长连接的命令传播**，可以避免频繁建立连接的开销。

### 主从库间网络断了怎么办
Redis 2.8开始，网络断了之后，主从库会采用增量复制的方式继续同步，只会把主从库网络断连期间主库收到的命令，同步给从库。

当主从库断连后，主库会把断连期间收到的写操作命令，写入replication buffer，同时也会把这些操作命令也写入**repl_backlog_buffer**这个缓冲区。  
repl_backlog_buffer是一个环形缓冲区，主库会记录自己写到的位置，从库则会记录自己已经读到的位置。 

偏移量 master_repl_offset - slave_repl_offset 用于衡量主从库的数据差。  
主从库的连接恢复之后，从库首先会给主库发送psync命令，并把自己当前的slave_repl_offset发给主库，主库会判断自己的master_repl_offset和slave_repl_offset之间的差距。

>如果从库的读取速度比较慢，就有可能导致从库还未读取的操作被主库新写的操作覆盖了，这会导致主从库间的数据不一致。可以调整repl_backlog_size这个参数。  
>计算公式是：缓冲空间大小 = 主库写入命令速度 * 操作大小 - 主从库间网络传输命令速度 * 操作大小。在实际应用中，考虑到可能存在一些突发的请求压力，我们通常需要把这个缓冲空间扩大一倍，即repl_backlog_size = 缓冲空间大小 * 2，这也就是repl_backlog_size的最终值。

## 缺陷
主机宕机，宕机前有部分数据未能及时同步到从机(从库中还是可以读数据)，切换IP后还会引入数据不一致的问题，降低了系统的可用性。   
主从切换需要人工干预。  

# Sentinel（哨兵）模式/哨兵集群模式  
[哨兵模式配置，新建sentinel.conf文件](https://blog.csdn.net/cuipeng0916/article/details/53726092)   
[参考](https://www.cnblogs.com/kevingrace/p/9004460.html) 
主从复制的自动版？一主，三从，三哨兵。    
主从库实例运行的同时，哨兵作为Redis进程也在运行。主要是三个任务：**监控、选主（选择主库）和通知**。  
`redis-sentinel sentinel1.conf`

当哨兵监测到 master 宕机，会自动将 slave 切换成 master ，然后通过发布订阅模式通知其他的从服务器，修改配置文件，让它们切换主机。  
可以降低Redis集群的运维开销。

## 哨兵如何监控 redis 实例
1)：每个Sentinel以每秒钟一次的频率向它所知的Master/Slave以及其他 Sentinel 实例发送一个 PING 命令，检测它们是否仍然在线运行。

2)：如果一个实例（instance）距离最后一次有效回复 PING 命令的时间超过 down-after-milliseconds 选项所指定的值（要保证所有哨兵实例的配置是一致的）， 则这个实例会被 Sentinel 标记为**主观下线**。

3)：如果一个Master被标记为主观下线，标记它的哨兵会给其他哨兵发送is-master-down-by-addr命令，其他哨兵以每秒一次的频率确认Master的确进入了主观下线状态（投票）。
>在判断主库是否下线时，不能由一个哨兵说了算，只有大多数的哨兵实例，都判断主库已经“主观下线”了，主库才会被标记为“客观下线”

4)：当有足够数量的 Sentinel（大于等于配置文件指定的值：quorum）在指定的时间范围内确认Master的确进入了主观下线状态， 则Master会被标记为**客观下线** 。

5)：在一般情况下， 每个 Sentinel 会以每 10 秒一次的频率向它已知的所有Master，Slave发送 INFO 命令

6)：当Master被 Sentinel 标记为客观下线时，Sentinel 向下线的 Master 的所有 Slave 发送 INFO 命令的频率会从 10 秒一次改为每秒一次 ，若没有足够数量的 Sentinel 同意 Master 已经下线， Master 的客观下线状态就会被移除。

8)：若 Master 重新向 Sentinel 的 PING 命令返回有效回复， Master 的主观下线状态就会被移除。

主观下线：Subjectively Down，简称 SDOWN，指的是当前 Sentinel 实例对某个redis服务器做出的下线判断。

客观下线：Objectively Down， 简称 ODOWN，指的是多个 Sentinel 实例在对Master Server做出 SDOWN 判断，并且通过 SENTINEL之间交流后得出Master下线的判断。然后开启failover

## 脑裂
某个master所在机器突然脱离了正常的网络，跟其他slave机器不能连接，但是实际上master还运行着，此时哨兵可能就会认为master宕机了，然后开启选举，将其他slave切换成了master，这个时候，集群里就会有两个master，也就是所谓的脑裂

误判一般会发生在集群网络压力较大、网络拥塞，或者是主库本身压力较大的情况下。

## 哨兵选举新master的因素
有四个因素影响。

1. 筛选。看网络连接状态，如果与哨兵连接断开的比较久down-after-milliseconds，或者断开次数超过了某个阈值，就直接失去了选举权。
2. 打分。首先看谁的**优先级**高，这个在配置文件里可以设置（slave-priority 100），数值越小优先级越高。  
如果优先级相同，就看谁从master中复制的数据最多（**复制偏移量slave_repl_offset**最大）  
在优先级和复制进度都相同的情况下，选择**实例id**最小的那个  

## 谁来完成故障转移？
三个sentinel节点必须要通过某种机制达成一致，在Redis中采用了**Raft算法**（少数服从多数）选出“哨兵领导者”来实现这个功能。  
确认客观下线后哨兵就可以给其他哨兵发送命令，表明希望由自己来执行主从切换，并让所有其他哨兵进行投票。这个投票过程称为“Leader选举”。因为最终执行主从切换的哨兵称为Leader，投票过程就是确定Leader。
>想成为Leader的哨兵，要满足两个条件：第一，拿到半数以上的赞成票；第二，拿到的票数同时还需要大于等于哨兵配置文件中的quorum值。以3个哨兵为例，假设此时的quorum设置为2，那么，任何一个想成为Leader的哨兵只要拿到2张赞成票，就可以了。

选出Sentinel Leader之后，由Sentinel Leader向某个节点发送slaveof no one命令，让它成为独立节点。  
然后向其他节点发送replicaof x.x.x.x xxxx（本机服务），让它们成为这个节点的子节点，故障转移完成。

>如果哨兵集群只有2个实例，此时，一个哨兵要想成为Leader，必须获得2票，而不是1票。所以，如果有个哨兵挂掉了，那么，此时的集群是无法进行主从库切换的。因此，通常我们至少会配置3个哨兵实例。

### 哨兵与其他角色的通信
哨兵实例之间可以相互发现，要归功于Redis提供的pub/sub机制，也就是发布/订阅机制。   
哨兵只要和主库建立起了连接，就可以在主库上发布消息了，比如说发布它自己的连接信息（IP和端口）。同时，它也可以从主库上订阅消息，获得其他哨兵发布的连接信息。当多个哨兵实例都在主库上做了发布和订阅操作后，它们之间就能知道彼此的IP地址和端口。

哨兵向主库发送INFO命令，主库接受到这个命令后，就会把从库列表返回给哨兵。哨兵就可以根据从库列表中的连接信息，和每个从库建立连接，并在这个连接上持续地对从库进行监控。

如果出现了主从库切换，哨兵还需要完成把新主库的信息告诉客户端。   
每个哨兵实例也提供pub/sub机制，客户端可以从哨兵订阅消息。哨兵提供的消息订阅频道有很多，不同频道包含了主从库切换过程中的不同关键事件，如switch-master事件。  有了这些事件通知，客户端不仅可以在主从切换后得到新主库的连接信息，还可以监控到主从库切换过程中发生的各个重要事件。这样，客户端就可以知道主从切换进行到哪一步了，有助于了解切换进度。
有了这些事件通知，客户端不仅可以在主从切换后得到新主库的连接信息，还可以监控到主从库切换过程中发生的各个重要事件。这样，客户端就可以知道主从切换进行到哪一步了，有助于了解切换进度。                                                                                         


## 缺陷
可以实现高可用，但主从切换的过程中会丢失数据。    
>由于所有的写操作都是先在Master上操作，然后同步更新到Slave上，所以从Master同步到Slave机器有一定的延迟，当系统很繁忙的时候，延迟问题会更加严重，Slave机器数量的增加也会使这个问题更加严重。

没有解决 master 写的压力，写操作无法负载均衡；存储能力受到单机的限制。   

# 分片模式
横向扩展（scale out）/水平扩展，3.0版本提供了一个名为Redis Cluster的方案，用于实现切片集群。
>ps ：之前业界已经有了一些切片集群的方案，例如基于客户端分区的ShardedJedis，基于代理的Codis、Twemproxy等。

启动多个Redis实例组成一个集群，然后按照一定的规则，把收到的数据划分成多份，每一份用一个实例来保存,实现了 Redis 的分布式存储。  

随着用户或业务规模的扩展，保存大量数据的情况通常是无法避免的。而切片集群，就是一个非常好的解决方案。

[redis集群(redis-cluster)的搭建](https://juejin.im/post/6844903592105623560)

## 数据切片后，在多个实例之间如何分布
集群的每个节点负责一部分**hash slot槽**，每个 key 通过 CRC16 校验后对 16384 取模来决定放置到哪个槽。    

cluster create命令创建集群后，Redis会自动把16384（Redis集群最大节点个数）个哈希槽平均分布在集群实例上。例如，如果集群中有N个实例，那么，每个实例上的槽个数为16384/N个。 
>也可以使用cluster meet命令手动建立实例间的连接，形成集群，再使用cluster addslots命令，指定每个实例上的哈希槽个数。 

在redis集群中提供了下面的命令来计算当前key应该属于哪个slot
`redis> cluster keyslot key1`

注意，实例和哈希槽的对应关系并不是一成不变的，最常见的变化有两个：
- 在集群中，实例有新增或删除，Redis需要重新分配哈希槽；
- 为了负载均衡，Redis需要把哈希槽在所有实例上重新分布一遍。

## Redis 集群要增加分片，槽的迁移怎么保证无损
缓存怎么做扩容  
- 如果Redis被当做缓存使用，使用`一致性哈希实现动态扩容缩容`。
>一致性hash算法
一致性哈希算法是为了解决桶数量变化后，各个键值对应的桶都发生变化，造成缓存雪崩。

- 如果Redis被当做一个持久化存储使用，必须使用`固定的keys-to-nodes映射关系`，节点的数量一旦确定不能变化。否则的话(即Redis节点需要动态变化的情况），必须使用可以在运行时进行数据再平衡的一套系统，而当前只有Redis集群可以做到这样。



## 客户端怎么确定想要访问的数据在哪个实例上
客户端和集群实例建立连接后，实例就会把哈希槽的分配信息发给客户端客户端收到哈希槽信息后，会把哈希槽信息缓存在本地。当客户端请求键值对时，会先计算键所对应的哈希槽，然后就可以给相应的实例发送请求了。

### 重定向机制  
如果实例和哈希槽的对应关系变化了，客户端给一个实例发送数据读写操作时，这个实例上并没有相应的数据，那么，这个实例就会给客户端返回MOVED命令响应结果（哈希槽所在的新实例的信息），这个结果中就包含了新实例的访问地址，客户端要再给这个新实例发送操作命令，同时更新客户端缓存。

如果部分数据没有迁移完成，客户端就会收到一条ASK报错信息，也收到了最新实例地址。此时，客户端需要给新实例发送ASKING命令，然后再发送操作命令。 
>ASK命令的作用只是让客户端能给新实例发送一次请求，而不像MOVED命令那样，会更改本地缓存，让后续所有命令都发往新实例。

## 缺陷
资源隔离性较差，容易出现相互影响的情况。  
数据通过异步复制,不保证数据的强一致性。

# 其他模式
![](https://img-blog.csdnimg.cn/dc91a19c03d14267ab9203fa337f25da.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAc3VuX2xt,size_20,color_FFFFFF,t_70,g_se,x_16)

![](https://pic3.zhimg.com/80/v2-8a70cdc990cac13618a3fae438fe0b9a_1440w.jpg)

每个一节点组对应数据sharding的一个分片。

## proxy 型集群(中心化的)
Twemproxy 是一个 Twitter 开源的一个 redis 和 memcache 快速/轻量级代理服务器；Twemproxy 是一个快速的单线程代理程序，支持 Memcached ASCII 协议和 redis 协议。
特点：
多种 hash 算法：MD5、CRC16、CRC32、CRC32a、hsieh、murmur、Jenkins
支持失败节点自动删除
后端 Sharding 分片逻辑对业务透明，业务方的读写方式和操作单个 Redis 一致
缺点：
增加了新的 proxy，需要维护其高可用。
failover 逻辑需要自己实现，其本身不能支持故障的自动转移可扩展性差，进行扩缩容都需要手动干预

## Gossip protocol 也叫 Epidemic Protocol （流行病协议）
在节点数量有限的网络中，每个节点都会“随机”（不是真正随机，而是根据规则选择通信节点）与部分节点通信，经过一番杂乱无章的通信后，每个节点的状态在一定时间内会达成一致。 






# 为什么是让缓存失效，而不是更新缓存


# 更新缓存的几种设计模式

>>如果你是Redis中高级用户，还有HyperLogLog、Geo、Pub/Sub可供使用。
如果你说还玩过Redis Module，像BloomFilter，RedisSearch，Redis-ML，面试官得眼睛就开始发亮了？

>Redis 到底是怎么实现“附近的人”
使用方式
GEOADD key longitude latitude member [longitude latitude member ...]
将给定的位置对象（纬度、经度、名字）添加到指定的key。其中，key为集合名称，member为该经纬度所对应的对象。在实际运用中，当所需存储的对象数量过多时，可通过设置多key(如一个省一个key)的方式对对象集合变相做sharding，避免单集合数量过多。
成功插入后的返回值：
(integer) N
其中N为成功插入的个数。

回收进程如何工作的？

一个客户端运行了新的命令，添加了新的数据。

Redi检查内存使用情况，如果大于maxmemory的限制, 则根据设定好的策略进行回收。



# redis通讯协议
RESP 是redis客户端和服务端之前使用的一种通讯协议；RESP 的特点：实现简单、快速解析、可读性好



## 数据库
0-15一个16个库，默认使用第0号库。  
redis不支持自定义数据库名，也不支持为每个库设置不同的密码。  
数据库之间也不是完全隔离，`FLUSHALL`命令可以清空一个redis实例中所有库的数据。  
所以这些数据库更像是一种命名空间，不适合存储不同应用程序的数据，可以存储不同环境如测试、生产环境的数据。  

# 单机服务 
轻量级，一个空redis实例内存只有1MB左右。  

第一个小数点后的数字是偶数的版本是稳定版  
redis-benchmark 是redis性能测试工具  
redis-check-aof 是AOF文件修复工具  
redis-check-dump 是RDB文件检查工具  

生产环境推荐使用脚本启动redis，使得redis能随系统自动运行。  
将redis源代码目录utils里的redis_init_script脚本，拷贝到/etc/init.d目录中，重命名文件为redis_6379。  
新建/etc/redis目录存放配置文件（6379.conf），新建/var/redis/6379文件夹存放redis持久化文件。  

shutdown停止服务时，redis收到SHUTDOWN命令后会先断开所有客户端连接，然后根据配置执行持久化，最后完成退出。  
使用`kill`也可以正常停止redis服务。  


