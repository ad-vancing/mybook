# Redis设计实现
https://www.w3cschool.cn/hdclil/qkd72cqm.html

Redis 数据库中的每个键值对的键和值都是一个对象。

Redis 共有字符串、列表、哈希、集合、有序集合五种类型的对象， 每种类型的对象至少都有两种或以上的编码方式， 不同的编码可以在不同的使用场景上优化对象的使用效率。

服务器在执行某些命令之前， 会先检查给定键的类型能否执行指定的命令， 而检查一个键的类型就是检查键的值对象的类型。

Redis 的对象系统带有引用计数实现的内存回收机制， 当一个对象不再被使用时， 该对象所占用的内存就会被自动释放。

Redis 会共享值为 0 到 9999 的字符串对象。

对象会记录自己的最后一次被访问的时间， 这个时间可以用于计算对象的空转时间
————————————————
版权声明：本文为CSDN博主「雨承认」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/qq_52286612/article/details/122050942


# Redis 键和值结构组织
```
https://cloud.tencent.com/developer/article/1690533
https://www.jianshu.com/p/915c7a396d68
https://www.jianshu.com/p/160fb0f73841
https://cloud.tencent.com/developer/article/1862812
```
为了实现从键到值的快速访问，Redis使用了一个O(1)复杂度的哈希表来保存所有键值对。

一个哈希表是由多个哈希桶组成的数组，每个哈希桶中保存了键值对数据。哈希桶中的entry元素中保存key和value指针，分别指向了实际的键和值。 

![图](https://img2022.cnblogs.com/blog/1331583/202210/1331583-20221030205851161-748126873.png)

Redis解决哈希冲突的方式，就是链式哈希。就是指同一个哈希桶中的多个元素用一个链表来保存，它们之间依次用指针连接。

## rehash操作
问题：哈希冲突链上的元素只能通过指针逐一查找再操作。如果哈希表里写入的数据越来越多，哈希冲突可能也会越来越多，这就会导致某些哈希冲突链过长，进而导致这个链上的元素查找耗时长，效率降低。

rehash也就是增加现有的哈希桶数量，让逐渐增多的entry元素能在更多的桶之间分散保存，减少单个桶中的元素数量，从而减少单个桶中的冲突。

为了使rehash操作更高效，Redis默认使用了两个全局哈希表：哈希表1和哈希表2。一开始，当你刚插入数据时，默认使用哈希表1，此时的哈希表2并没有被分配空间。  
随着数据逐步增多，Redis开始执行rehash，这个过程分为三步：  
1. 给哈希表2分配更大的空间，例如是当前哈希表1大小的两倍；
2. 把哈希表1中的数据重新映射并拷贝到哈希表2中；
3. 释放哈希表1的空间。

## 渐进式 rehash
rehash过程看似简单，但是第二步涉及大量的数据拷贝，如果一次性把哈希表1中的数据都迁移完，会造成Redis线程阻塞，无法服务其他请求。此时，Redis就无法快速访问数据了。

为了避免这个问题，Redis采用了渐进式rehash。

就是在第二步拷贝数据时，Redis仍然正常处理客户端请求，每处理一个请求时，从哈希表1中的第一个索引位置开始，顺带着将这个索引位置上的所有entries拷贝到哈希表2中；等处理下一个请求时，再顺带拷贝哈希表1中的下一个索引位置的entries。

这样就巧妙地把一次性大量拷贝的开销，分摊到了多次处理请求的过程中，避免了耗时操作，保证了数据的快速访问。



# Redis 中 Hash 对象的扩容流程

# Redis 的 Hash 对象的扩容流程在数据量大的时候会有什么问题吗

# Redis 核心对象redisObject  
所有的 Redis 对象都有这个结构头
![](https://pic2.zhimg.com/80/v2-db1ff7d98baff8a43af96e01bc683265_1440w.jpg)
不同的对象具有不同的类型 type(4bit)，

同一个类型的 type 会有不同的存储形式encoding(4bit)，

为了记录对象的 LRU 信息，使用了 24 个 bit 来记录 LRU 信息。

每个对象都有个引用计数，当引用计数为零时，对象就会被销毁，内存被回收。

ptr 指针将指向对象内容 (body) 的具体存储位置。

# Redis支持的几种数据类型
值的底层实现:  
![图](https://img2022.cnblogs.com/blog/1331583/202210/1331583-20221030205122443-128517040.png)

## string
最基本的数据类型，二进制安全的字符串。  
可以是String也可以是数字。一般做一些复杂的计数功能的缓存，还可以存储json化的对象，甚至是图片（二进制数据）。  


### string底层结构
Redis 中的字符串叫着「SDS」，也就是**简单动态字符串** Simple Dynamic String。它的结构是一个带长度信息的字节数组。  
```
struct SDS<T> {
	T capacity; // 数组容量   使用泛型表示的
	T len; // 数组长度      使用泛型表示的 
	byte flags; // 特殊标识位，不理睬它
	byte[] content; // 数组内容   字节数组
}
```
>使用了范型 T，为什么不直接用 int 呢 ？
这是因为当字符串比较短时，len 和 capacity 可以使用 byte 和 short 来表示，Redis 为了对内存做极致的优化，不同长度的字符串使用不同的结构体来表示。

采用预分配冗余空间的方式来减少内存的频繁分配，一般要高于实际字符串长度 len。  
一个字符串类型的值能存储的最大容量是512M。  

Redis 规定字符串的长度不得超过 512M 字节。创建字符串时 len 和 capacity 一样长，不会多分配冗余空间，这是因为绝大多数场景下我们不会使用 append 操作来修改字符串。？？？？

Redis 的字符串有两种存储方式，在长度特别短时，使用 emb 形式存储(embeded)，当长度超过 44 时，使用 raw 形式存储 。


## list
按照添加顺序保持顺序的字符串列表。  
内部是**双向链表 + 压缩列表**。获取头部或尾部的topn会比较快。插入数据的速度也不会受已有数据数量的影响。   
可以做简单的消息队列的功能。不同方向插入、弹出即可。  
另外可以用列表类型存储id列表，利用分片获取命令，做基于redis的分页功能。  
（评论按时间排序分页：根据list按照插入顺序排序的特点，利用range方法实现分页；  
   评论按点赞数排序分页：根据zSet特性，score为点赞数、member为评论，利用range方法实现分页）  

### 压缩列表
压缩列表实际上类似于一个数组，数组中的每一个元素都对应保存一个数据。和数组不同的是，压缩列表在表头有三个字段zlbytes、zltail和zllen，分别表示列表长度、列表尾的偏移量和列表中的entry个数；压缩列表在表尾还有一个zlend，表示列表结束。

省空间而且也能避免一些内存碎片。

>压缩列表和双向链表都会记录表头和表尾的偏移量。这样一来，对于List类型的LPOP、RPOP、LPUSH、RPUSH这四个操作来说，它们是在列表的头尾增删元素，这就可以通过偏移量直接定位，所以它们的复杂度也只有O(1)，可以实现快速操作。  
既然它的POP/PUSH效率很高，一般将它主要用于FIFO队列场景，而不是作为一个可以随机读写的集合来使用。

## hash
注意不能嵌套其他的数据类型（其他的也是），字段值只能是字符串。
内部是**哈希表 + 压缩列表**。

一般存放的是结构化的对象，使用对象类型:对象id构成键名，使用字段表示对象属性，字段值存放属性值。比较方便的操作其中的某个字段。不然使用多个string类型存储一个对象的不同属性会不好管理。
也可以存映射关系，如搭建博客网站时用散列类型存储文章缩略名slug和id之间的映射关系。
在做单点登录的时候，用这种数据结构存储用户信息，以cookieId作为key，设置30分钟为缓存过期时间，能很好的模拟出类似session的效果。

除了string类型，一个Redis实例最多能存放（2^32-1）个元素。

## sorted set：已排序的字符串集合。  
内部是**跳表 + 压缩列表**。  
与普通集合相比，多了一个权重参数score,集合中的元素能够按score进行排列。可以做排行榜应用，取TOP N操作。  

### 跳表
有序链表只能逐一查找元素，导致操作起来非常缓慢，于是就出现了跳表。

跳表在链表的基础上，增加了多级索引，通过索引位置的几个跳转，实现数据的快速定位。

类似于一个可以二分查找的链表，可以用平衡树替换。

这个查找过程就是在多级索引上跳来跳去，最后定位到元素。这也正好符合“跳”表的叫法。当数据量很大时，跳表的查找复杂度就是O(logN)。

## set：无序的字符串集合，不存在重复的元素。 
内部是**哈希表 + 整数数组**。     
最方便的是可以进行交集、并集、差集等运算。    
可以存储标签。可以利用集合类型优势的场景。  

# 使用过Redis做异步队列？
*不要使用redis去做消息队列，这不是redis的设计目标。*
答：一般使用list结构作为队列，rpush生产消息，lpop消费消息。当lpop没有消息的时候，要适当sleep一会再重试。
https://zhuanlan.zhihu.com/p/344269737

可不可以不用sleep呢？

list还有个指令叫blpop，在没有消息的时候，它会阻塞住直到消息到来。如果对方追问能不能生产一次消费多次呢？使用pub/sub主题订阅者模式，可以实现1:N的消息队列。

如果对方追问pub/sub有什么缺点？

在消费者下线的情况下，生产的消息会丢失，得使用专业的消息队列如RabbitMQ等。

如果对方追问redis如何实现延时队列？

我估计现在你很想把面试官一棒打死如果你手上有一根棒球棍的话，怎么问的这么详细。但是你很克制，然后神态自若的回答道：使用sortedset，拿时间戳作为score，消息内容作为key调用zadd来生产消息，消费者用zrangebyscore指令获取N秒之前的数据轮询进行处理。到这里，面试官暗地里已经对你竖起了大拇指。但是他不知道的是此刻你却竖起了中指，在椅子背后。

# Redis内存模型
used_memory：Redis分配器分配的内存总量（单位是字节），包括使用的虚拟内存（即swap）；Redis分配器后面会介绍。used_memory_human只是显示更友好。

used_memory_rss**：**Redis进程占据操作系统的内存（单位是字节），与top及ps命令看到的值是一致的；除了分配器分配的内存之外，used_memory_rss还包括进程运行本身需要的内存、内存碎片等，但是不包括虚拟内存。

mem_fragmentation_ratio**：**内存碎片比率，该值是used_memory_rss / used_memory的比值。

mem_allocator**：**Redis使用的内存分配器，在编译时指定；可以是 libc 、jemalloc或者tcmalloc，默认是jemalloc；截图中使用的便是默认的jemalloc。


# 常见性能问题和解决方案？
(1) Master最好不要做任何持久化工作，如RDB内存快照和AOF日志文件
(2) 如果数据比较重要，某个Slave开启AOF备份数据，策略设置为每秒同步一次
(3) 为了主从复制的速度和连接的稳定性，Master和Slave最好在同一个局域网内
(4) 尽量避免在压力很大的主库上增加从库
(5) 主从复制不要用图状结构，用单向链表结构更为稳定，即：Master <- Slave1 <- Slave2 <- Slave3...
这样的结构方便解决单点故障问题，实现Slave对Master的替换。如果Master挂了，可以立刻启用Slave1做Master，其他不变。
[Redis 性能问题分析（好文推荐）](https://mp.weixin.qq.com/s?__biz=MzI4Njc5NjM1NQ==&mid=2247491923&idx=1&sn=09526c6ee214ee4179500d13282ed5f0&chksm=ebd5de7fdca25769d0c6b7af5b51b13c7238c72cbf35a35a01173344b6ae5d69985334bbb86d&scene=21#wechat_redirect)

[大量数据插入，Redis如何尽可能快的处理数据](http://www.redis.cn/topics/mass-insert.html)

[阿里云Redis混合存储典型场景：如何轻松搭建视频直播间系统](https://developer.aliyun.com/article/582487)

[高级深入一点](https://zhuanlan.zhihu.com/p/28073983)

# Redis内存划分
数据
作为数据库，数据是最主要的部分；这部分占用的内存会统计在used_memory中。

进程本身运行需要的内存
Redis主进程本身运行肯定需要占用内存，如代码、常量池等等；这部分内存大约几兆，在大多数生产环境中与Redis数据占用的内存相比可以忽略。这部分内存不是由jemalloc分配，因此不会统计在used_memory中。

缓冲内存
缓冲内存包括客户端缓冲区、复制积压缓冲区、AOF缓冲区等；其中，客户端缓冲存储客户端连接的输入输出缓冲；复制积压缓冲用于部分复制功能；AOF缓冲区用于在进行AOF重写时，保存最近的写入命令。在了解相应功能之前，不需要知道这些缓冲的细节；这部分内存由jemalloc分配，因此会统计在used_memory中。

内存碎片
内存碎片是Redis在分配、回收物理内存过程中产生的。例如，如果对数据的更改频繁，而且数据之间的大小相差很大，可能导致redis释放的空间在物理内存中并没有释放，但redis又无法有效利用，这就形成了内存碎片。内存碎片不会统计在used_memory中。