Redis集群时分布式锁的问题（主节点锁信息未同步至从节点，主宕机）
Redis分布式锁中加锁与解锁的详细细节询问，过期如何续命
Redis实现分布式锁中，过期时间如何设置的（估计是在问NX和PX如何保持一致性）
https://www.jianshu.com/p/fb9993d1b27e
https://juejin.im/post/6844903717641142285

Redis的主键争用问题如何解决了解Redis事务的CAS操作吗
		
[基本介绍与服务](https://segmentfault.com/a/1190000019828543)

# remote dictionary server远程字典服务器  
C语言开发的  
TCP协议读写  
数据都存储在内存中，可达到10万个键值读写每秒。  
支持持久化。    
还可以限定数据占用的最大内存空间，数据量达到空间限制后会按一定的规则自动淘汰不需要的键。  
[Redis 服务器是一个事件驱动程序](https://www.javazhiyin.com/62931.html)  
[Redis教程](https://www.redis.net.cn/tutorial/3524.html)

# 适用场景
1. 会话缓存（Session Cache）/Session共享(单点登录) 
用Redis缓存会话比其他存储（如Memcached）的优势在于：Redis提供持久化。当维护一个不是严格要求一致性的缓存时，如果用户的购物车信息全部丢失，大部分人都会不高兴的，现在，他们还会这样吗？ 幸运的是，随着 Redis 这些年的改进，很容易找到怎么恰当的使用Redis来缓存会话的文档。甚至广为人知的商业平台Magento也提供Redis的插件。

2. 全页缓存（FPC）
除基本的会话token之外，Redis还提供很简便的FPC平台。回到一致性问题，即使重启了Redis实例，因为有磁盘的持久化，用户也不会看到页面加载速度的下降，这是一个极大改进，类似PHP本地FPC。 再次以Magento为例，Magento提供一个插件来使用Redis作为全页缓存后端。 此外，对WordPress的用户来说，Pantheon有一个非常好的插件 wp-redis，这个插件能帮助你以最快速度加载你曾浏览过的页面。

3. 队列 
可以利用列表类型键实现队列，并支持阻塞读取。
Reids在内存存储引擎领域的一大优点是提供 list 和 set 操作，这使得Redis能作为一个很好的消息队列平台来使用。Redis作为队列使用的操作，就类似于本地程序语言（如Python）对 list 的 push/pop 操作。 如果你快速的在Google中搜索“Redis queues”，你马上就能找到大量的开源项目，这些项目的目的就是利用Redis创建非常好的后端工具，以满足各种队列需求。例如，Celery有一个后台就是使用Redis作为broker，你可以从这里去查看。

4. 排行榜/计数器 
Redis在内存中对数字进行递增或递减的操作实现的非常好。集合（Set）和有序集合（Sorted Set）也使得我们在执行这些操作的时候变的非常简单，Redis只是正好提供了这两种数据结构。所以，我们要从排序集合中获取到排名最靠前的10个用户–我们称之为“user_scores”，我们只需要像下面一样执行即可： 当然，这是假定你是根据你用户的分数做递增的排序。如果你想返回用户及用户的分数，你需要这样执行： ZRANGE user_scores 0 10 WITHSCORES Agora Games就是一个很好的例子，用Ruby实现的，它的排行榜就是使用Redis来存储数据的，你可以在这里看到。

5. 发布/订阅 
最后（但肯定不是最不重要的）是Redis的发布/订阅功能。发布/订阅的使用场景确实非常多。我已看见人们在社交网络连接中使用，还可作为基于发布/订阅的脚本触发器。
用redis实现的聊天室就是用Redis的发布/订阅功能来建立的。

Redis还提供的高级工具
像慢查询分析、性能测试、Pipeline、事务、Lua自定义命令、Bitmaps、HyperLogLog、发布/订阅、Geo等个性化功能。


# Redis的优点
1. 速度快，因为数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)
2. 支持丰富数据类型，支持string，list，set，sorted set，hash
3. 支持事务，`操作都是原子性`，所谓的原子性就是对数据的更改要么全部执行，要么全部不执行
4. 丰富的特性：可用于缓存，消息，按key设置过期时间，过期后将会自动删除

# redis快的原因
- 纯内存操作
- 数据结构简单
- 单线程操作，避免了频繁的上下文切换

## Redis 真的是单线程吗
主要是指Redis的网络IO和键值对读写是由一个线程来完成的，其他功能，比如持久化、异步删除、集群数据同步等，其实是由额外的线程执行的

## Redis为什么用单线程
Redis利用队列技术将并发访问变为串行访问，消除了传统数据库串行控制的开销。

主要是多线程编程模式面临的共享资源的并发访问控制问题。  

对于一个多线程的系统来说，在有合理的资源分配的情况下，可以增加系统中处理请求操作的资源实体，进而提升系统能够同时处理的请求数，即吞吐率。

刚开始增加线程数时，系统吞吐率会增加，但是，再进一步增加线程时，系统吞吐率就增长迟缓了，有时甚至还会出现下降的情况。

瓶颈在于，系统中通常会存在被多线程同时访问的共享资源，比如一个共享的数据结构。当有多个线程要修改这个共享资源时，为了保证共享资源的正确性，就需要有额外的机制进行保证，而这个额外的机制，就会带来额外的开销。

## 单线程Redis为什么那么快
通常来说，单线程的处理能力要比多线程差很多，但是Redis却能使用单线程模型达到每秒数十万级别的处理能力，这是为什么呢？其实，这是Redis多方面设计选择的一个综合结果。

Redis采用了多路复用机制，使其在网络IO操作中能并发处理大量的客户端请求，实现高吞吐率。

[为什么Redis 单线程却能支撑高并发？](https://mp.weixin.qq.com/s?__biz=MzI4Njc5NjM1NQ==&mid=2247488320&idx=1&sn=2b8f1ffc06553d1e43419bc1958c61d1&chksm=ebd62c6cdca1a57af0dfbbe4ac41da68d894ac2913028929b0b65329811d76786c9113308046&scene=21#wechat_redirect)

### 多路复用机制
socket网络模型本身支持非阻塞模式。  
避免了accept()和send()/recv()潜在的网络IO操作阻塞点。

### Linux中的IO多路复用机制——select/epoll机制
这里“多路”指的是多个网络连接，“复用”指的是复用同一个线程。

在Redis只运行单线程的情况下，该机制允许内核中，同时存在多个监听套接字和已连接套接字。内核会一直监听这些套接字上的连接请求或数据请求。一旦有请求到达，就会交给Redis线程处理，这就实现了一个Redis线程处理多个IO流的效果。

![图](https://img2022.cnblogs.com/blog/1331583/202210/1331583-20221030220635604-1202929986.png)  

为了在请求到达时能通知到Redis线程，select/epoll提供了基于事件的回调机制，即针对不同事件的发生，调用相应的处理函数。select/epoll一旦监测到FD上有请求到达时，就会触发相应的事件。

redis-client在操作的时候，会产生具有不同事件类型的socket。在服务端，有一段I/0多路复用程序，将其置入队列之中。然后，文件事件分派器，依次去队列中取，转发到不同的事件处理器中。
>多路复用主要有三种技术：select，poll，epoll。根据Redis实际运行的操作系统，选择相应的多路复用实现。    
>epoll是最新的也是目前最好的多路复用技术。
                                                      
![redis线程模型](https://img-blog.csdn.net/20180531085855659)

类似于一个医生（相当于Redis单线程）有了分诊台（处理这些诊断前的工作，类似于Linux内核监听请求），给人看病会提高不少效率。

# Redis 和 Memcache 的区别
Memcached仅支持简单的key-value结构的数据，而redis常用的数据类型主要有五种：String、Hash、List、Set和Sorted Set    

Redis是单线程，memcached是多线程。

内存管理机制不同

memcached是不支持数据持久化操作

Memcached本身并不支持分布式，因此只能在客户端通过像一致性哈希这样的分布式算法来实现Memcached的分布式存储。  

与客户端之间通信的应用协议不一样
Redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求
![](https://user-gold-cdn.xitu.io/2018/4/18/162d7773080d4570?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

## Redis与Memcached的选择
终极策略： 使用Redis的String类型做的事，都可以用Memcached替换，以此换取更好的性能提升； 除此以外，优先考虑Redis。

## redis和memcached 的内存管理的区别
Redis和Memcached均使用了自身设计的内存管理机制，但是实现方法存在很大的差异。 
 
Memcached默认使用Slab Allocation机制管理内存，其主要思想是按照预先规定的大小，将分配的内存分割成特定长度的块以存储相应长度的key-value数据记录，以完全解决内存碎片问题。  

Redis的内存管理主要通过源码中zmalloc.h和zmalloc.c两个文件来实现的。Redis为了方便内存的管理，在分配一块内存之后，会将这块内存的大小存入内存块的头部。

https://zhuanlan.zhihu.com/p/355844361

# Redis持久化方式
[10分钟彻底理解Redis的持久化机制：RDB和AOF](https://mp.weixin.qq.com/s?__biz=MzI4Njc5NjM1NQ==&mid=2247489359&idx=1&sn=30367a57e57aa107511be22cf41e8c18&chksm=ebd62863dca1a175197409337f22b532177a392b4fe9f289fdf416617a462f376e44663c5290&scene=21#wechat_redirect)

RDB 做镜像全量持久化，AOF 做增量持久化。

## RDB（默认开启）
Redis DataBase  
在指定的时间间隔的在某个时间点**对内存数据进行快照存储**到磁盘中，创建一个dump.rdb临时文件（二进制），持久化的过程结束了，再用这个临时文件替换上次的快照文件。  
>需要注意的是，**每次快照持久化都会将主进程的数据库数据复制一遍**，导致内存开销加倍，若此时内存不足，则会阻塞服务器运行，直到复制结束释放内存；都会将内存数据完整写入磁盘一次，所以如果数据量大的话，而且写操作频繁，必然会引起大量的磁盘I/O操作，严重影响性能，并且最后一次持久化后的数据可能会丢失。

### 怎么进行快照
Redis提供了两个命令来生成RDB文件，分别是save和bgsave。  
- save：在主线程中执行，会导致阻塞；
- bgsave：由主线程fork生成一个子进程，专门用于写入RDB文件，避免了主线程的阻塞，这也是Redis RDB文件生成的**默认配置**。

可以通过Redis的**save指令**来配置RDB快照生成的时机，比如配置10分钟就生成快照，也可以配置有1000次写入就生成快照，也可以多个规则一起实施。这些规则的定义就在Redis的配置文件中，你也可以通过Redis的CONFIG SET命令在Redis运行时设置规则，不需要重启Redis。

### 生成快照时还能操作数据吗
用bgsave时，主线程的确没有阻塞，可以正常接收请求，但是，为了保证快照完整性，它只能处理读操作，因为不能修改正在执行快照的数据。  

为了快照而暂停写操作，肯定是不能接受的。所以这个时候，Redis就会借助操作系统提供的**写时复制技术（Copy-On-Write, COW）**，在执行快照的同时，正常处理写操作。

如果主线程对这些数据也都是读操作，那么，主线程和bgsave子进程相互不影响。但是，如果主线程要修改一块数据，那么，这块数据就会被复制一份，生成该数据的副本。然后，bgsave子进程会把这个副本数据写入RDB文件，而在这个过程中，主线程仍然可以直接修改原来的数据。

这既保证了快照的完整性，也允许主线程同时对数据进行修改，避免了对正常业务的影响。

### RDB 优点　　
1. 只有一个文件dump.rdb，文件紧凑，体积小，网络传输快，适合全量复制，方便持久化。 　　
2. 容灾性好，一个文件可以保存到安全的磁盘。 　　
3. 性能最大化，fork子进程来完成写操作，让主进程继续处理命令，所以是IO最大化。(使用单独子进程来进行持久化，主进程不会进行任何IO操作，保证了redis的高性能) 
4. 相对于数据集大时，恢复速度比AOF快很多，启动效率更高。 

### RDB 缺点： 　　
1. 耗时(fork这个过程会阻塞主线程，主线程的内存越大，阻塞时间越长)
2. RDB文件需要满足特定格式，兼容性差（如老版本的Redis不兼容新版本的RDB文件）
3. 不够实时持久化导致数据安全性低(RDB是间隔一段时间进行持久化，如果持久化之间redis发生故障，会发生数据丢失。所以这种方式**更适合数据要求不严谨的时候**。（因为这个原因，AOF持久化成为主流）

可以查看Redis的latest_fork_usec指标值，获取最近一次fork的耗时。

## AOF
Append-only file  
写后日志，“写后”的意思是Redis是先执行命令，把数据写入内存，然后才记录日志，因为不能记错误的命令。  
是可识别的纯文本，它的内容就是一个个的**Redis标准命令**，是redis命令请求协议的格式，记录每次对服务器写的操作（读操作不记录），保存为aof文件。  
当服务器重启的时候会根据日志从头到尾全部执行一遍以完成数据的恢复工作。包括flushDB清空当前数据库也会执行。  

### 如果突然机器掉电会怎样？
取决于aof日志sync属性的配置，如果不要求性能，在每条写指令时都sync一下磁盘，就不会丢失数据。  
但是在高性能的要求下每次都sync是不现实的，一般都使用定时sync，比如1s1次，这个时候最多就会丢失1s的数据。

### AOF优点： 　　
1. 数据安全，支持秒级持久化。aof持久化可以配置appendfsync属性，有always，每进行一次命令操作就记录到aof文件中一次。 　　
2. 通过append模式写文件，即使中途服务器宕机，可以通过redis-check-aofAOF文件修复工具解决数据一致性问题。 　　
3. AOF机制的rewrite模式。(AOF文件没被rewrite之前（文件过大时会对命令进行合并重写），可以删除其中的某些命令（比如误操作的flushall清空一个redis实例中所有库的数据）) 

### AOF缺点： 　　
1. AOF文件比RDB文件大，且恢复速度慢。  
2. 对性能影响大。  
3. 数据集大的时候，比rdb启动效率低。  

### AOF配置
要开启AOF，需要在配置文件中配置：`appendonly yes`

AOF常用的配置项，以及默认值：
```
appendonly no：是否开启AOF
appendfilename "appendonly.aof"：AOF文件名
dir ./：RDB文件和AOF文件所在目录
appendfsync everysec：fsync持久化策略
no-appendfsync-on-rewrite no：AOF重写期间是否禁止fsync；如果开启该选项，可以减轻文件重写时CPU和硬盘的负载（尤其是硬盘），但是可能会丢失AOF重写期间的数据；需要在负载和安全性之间进行平衡
auto-aof-rewrite-percentage 100：文件重写触发条件之一
auto-aof-rewrite-min-size 64mb：文件重写触发提交之一
aof-load-truncated yes：如果AOF文件结尾损坏，Redis启动时是否仍载入AOF文件
```

### fsync持久化策略
>如果刚执行完一个命令，还没有来得及记日志就宕机了，那么这个命令和相应的数据就有丢失的风险。  
AOF日志也是在主线程中执行的，如果在把日志文件写入磁盘时，磁盘写压力大，就会导致写盘很慢，进而导致后续的操作也无法执行了。  
怎么平衡？

在Redis中对AOF调用write写入后，通过appendfsync选项来控制调用fsync将其写到磁盘上的时间。  
下面appendfsync的三个设置项，安全强度逐渐变强。  
1.  `no` os控制的写回：Redis不会主动调用fsync去将AOF日志内容同步到磁盘，所以这一切就完全依赖于操作系统的调试了。对大多数Linux操作系统，是每30秒进行一次fsync，将缓冲区中的数据写到磁盘上。  

2.  `everysec`每秒写回，Redis会默认每隔一秒进行一次fsync调用，将缓冲区中的数据写到磁盘。但是当这一次的fsync调用时长超过1秒时，Redis会采取延迟fsync的策略，再等一秒钟。也就是在两秒后再进行fsync，这一次的fsync就不管会执行多长时间都会进行。这时候由于在fsync时文件描述符会被阻塞，所以当前的写操作就会阻塞。所以结论就是，在绝大多数情况下，Redis会每隔一秒进行一次fsync。在最坏的情况下，两秒钟会进行一次fsync操作。这一操作在大多数数据库系统中被称为group commit，就是组合多次写操作的数据，一次性将日志写到磁盘。  

3.  `always`同步写回，每一次写操作都会调用一次fsync，这时数据是最安全的，当然，由于每次都会执行fsync，所以其性能也会受到影响。

可以根据系统对高性能和高可靠性的要求，来选择使用哪种写回策略了。总结一下就是：想要获得高性能，就选择No策略；如果想要得到高可靠性保证，就选择Always策略；如果允许数据有一点丢失，又希望性能别受太大影响的话，那么就选择Everysec策略。

### 重写机制 使得AOF文件的体积不至于过大
AOF rewrite。  
其功能就是重新生成一份AOF文件，新的AOF文件中一条记录的操作只会有一次，而不像一份老文件那样，可能记录了对同一个值的多次操作。  
比如当一个键值对被多条写命令反复修改时，AOF文件会记录相应的多条命令。但是，在重写的时候，是根据这个键值对当前的最新状态，为它生成对应的写入命令。这样一来，一个键值对在重写日志中只用一条命令就行了，而且，在日志恢复时，只用执行这条命令，就可以直接完成这个键值对的写入了。

和AOF日志由主线程写回不同，重写过程是由后台线程bgrewriteaof来完成的，这也是为了避免阻塞主线程，导致数据库性能下降。

和RDB类似，也是fork一个进程(bgrewriteaof)，直接遍历数据，写入新的AOF临时文件。  

在写入新文件的过程中，所有的写操作日志还是会写到原来老的AOF文件中，同时还会记录在内存缓冲区中。 
 
当重完操作完成后，会将所有缓冲区中的日志一次性写入到临时文件中。然后调用原子性的rename命令用新的AOF文件取代老的AOF文件。  

默认触发是当aof文件大小是上次重写后大小的一倍且文件大于64M时触发。

## redis 持久化策略选择
- 一般情况下，只要使用默认开启的RDB即可，因为相对于AOF，RDB便于进行数据库备份，DB的开销并相比AOF日志要低很多，并且恢复数据集的速度也要快很多。  
- 在单机环境下（对于个人开发者，这种情况可能比较常见），如果可以接受分钟级别的数据丢失，选择RDB对Redis的性能更加有利；如果只能接受秒级别的数据丢失，应该选择AOF。
- 如果Redis中的数据完全丢弃也没有关系（只希望你的数据在服务器运行的时候存在，只是用来做缓存的话），那么无论是单机，还是主从架构，都可以不进行任何持久化。
- 也可以同时开启两种持久化方式, 在 redis 实例重启时，使用 RDB 持久化文件重新构建内存，再使用 AOF 重放近期的操作指令来实现完整恢复重启之前的状态。不过Redis本身的机制是 AOF持久化开启且存在AOF文件时，优先加载AOF文件；AOF关闭或者AOF文件不存在时，加载RDB文件；加载AOF/RDB文件城后，Redis启动成功； AOF/RDB文件存在错误时，Redis启动失败并打印错误信息。
>Redis 4.0 中提出了一个混合使用AOF日志和内存快照的方法。简单来说，内存快照以一定的频率执行，在两次快照之间，使用AOF日志记录这期间的所有命令操作。
>这样一来，快照不用很频繁地执行，这就避免了频繁fork对主线程的影响。而且，AOF日志也只用记录两次快照间的操作，也就是说，不需要记录所有操作了，因此，就不会出现文件过大的情况了，也可以避免重写开销。

注意：开启持久化缓存机制，对性能会有一定的影响，特别是当设置的内存满了的时候，更是下降到几百reqs/s。

```
数据不能丢失时，内存快照和AOF的混合使用是一个很好的选择；
如果允许分钟级别的数据丢失，可以只使用RDB；
如果只用AOF，优先使用everysec的配置选项，因为它在可靠性和性能之间取了一个平衡。
```

# Redis内存回收策略
[Redis的内存淘汰策略](https://mp.weixin.qq.com/s?__biz=MzI4Njc5NjM1NQ==&mid=2247489594&idx=2&sn=80da83e6eb0d7a340bee6517c3d31258&chksm=ebd62716dca1ae005751ee605a8f3204e6d43a058d46bb4348b38a979126ae2d61f1818386d9&scene=21#wechat_redirect)

Redis的内存回收策略主要体现在两个方面。

## 删除到达过期时间的键对象的删除策略
> Q:到期后的键都会自动被删除吗？  
> Q:redis expire怎么实现的？

有以下几种删除策略：  
- 定时删除  
在设置键的过期时间的同时，创建一个定时器(timer)， 让定时器在键的过期时间来临时、立即执行对键的删除操作。  
对cpu是最不友好。而且目前redis事件处理器对时间事件的处理方式–无序链表，查找一个key的时间复杂度为O(n),所以并不适合用来处理大量的时间事件。  

- 定期删除
redis默认每隔一段时间（默认100ms）随机检查expires字典的一部分键，有过期key则删除。但redis并不是检查将所有的key，而是`随机抽取`进行检查(如果每隔100ms,全部key进行检查，redis可能会卡死)。
因此，如果只采用定期删除策略，会导致很多key到时间没有删除。   
>定期删除策略由 activeExpireCucle 函数实现。
有一个全局变量 current_db 会记录当前 activeExpireCycle 函数检查的进度，并且下一次 函数执行时，接着上一次的进度进行处理。如，当前 activeExpireCycle 函数执行到了 10， 讲 current_db = 10；然后下一次函数执行时，从 current_db 取到 10 继续执行。
当所有的数据库键都被检查完时， current_db = 0。


- 惰性删除    
所有读写数据库的 Redis 命令在执行之前都会调用 exipreIfNeeded 函数对输入键进行检查，会检查一下这个key（如果设置了过期时间）是否过期，如果过期了此时就会删除该键，如果没有过期，就返回该键。　  
浪费内存。dict字典和expires字典都要保存这个键值的信息。

在兼顾CPU和内存的的考虑下，redis默认采用的是`定期删除+惰性删除策略`，所以到期后的键不一定会被删除。

集群模式下，从服务器不会去过期 key，它会等待 master 去过期 key，当 master 过期 key (或由于 LRU 算法驱逐)，它会生成一个 DEL 命令发送给所有的从服务器。    
但这样会导致一些从服务器有时内存中存在逻辑上已经过期的 key。  通过逻辑时钟记录一下本该过期的或等待 master DEL 命令 的 key）。通过这种方式，从节点避免了返回一个已经过期的键。  

>Q:每个键设置多长时间的生存时间？  
设置得太长，在内存有限的情况下可能会导致内存占满。   
设置太短，可能导致缓存命中率低导致大量内存闲置。  
实际开发过程中会比较难为缓存设置合理的生存时间，一般是通过限制redis最大内存使用量，并让redis按照一定的规则淘汰不需要的缓存键，这样来利用redis缓存系统。  


## 内存达到 maxmemory 后的淘汰机制
配置文件redis.conf中`maxmemory`参数来限制redis最大可用内存（单位字节），主要为了避免Redis内存超过操作系统内存，从而导致服务器响应变慢甚至死机的情况。当Redis 内存数据集大小上升到一定大小的时候，就会施行数据淘汰策略。
`maxmemory-policy`指定超出内存后的删除规则，直到redis占用内存小于限制内存。  

支持运行时通过命令动态修改内存大小：`config set maxmemory 2GB`  

有以下几种淘汰策略：  
```
# MAXMEMORY POLICY: how Redis will select what to remove when maxmemory
# is reached. You can select among five behaviors:
# 
# volatile-lru -> remove the key with an expire set using an LRU algorithm
# allkeys-lru -> remove any key according to the LRU algorithm
# volatile-random -> remove a random key with an expire set
# allkeys-random -> remove a random key, any key
# volatile-ttl -> remove the key with the nearest expire time (minor TTL)
# noeviction -> don't expire at all, just return an error on write operations
```
1. volatile-lru：从已设置过期的数据集中挑选最少使用的key淘汰。
这种情况一般是把redis既当缓存，又做持久化存储的时候才用。不推荐。
2. allkeys-lru：直接移除最近最少使用的key。
3. volatile-random：从已设置过期的数据集中随机淘汰。不推荐。
4. allkeys-random：从数据集中随机淘汰。
5. volatile-ttl：从已设置过期的数据集中挑选，越早过期的越优先被淘汰。不推荐。
6. noeviction（默认的）：当内存不足时，新写入操作会报错。
[LFU算法](https://mp.weixin.qq.com/s?__biz=MzI4Njc5NjM1NQ==&mid=2247489594&idx=2&sn=80da83e6eb0d7a340bee6517c3d31258&chksm=ebd62716dca1ae005751ee605a8f3204e6d43a058d46bb4348b38a979126ae2d61f1818386d9&scene=21#wechat_redirect)

redis淘汰数据时还会同步到aof

### 使用策略选择
- 如果数据呈现幂律分布，也就是一部分数据访问频率高，一部分数据访问频率低，则使用allkeys-lru 　　
- 如果数据呈现平等分布，也就是所有的数据访问频率都相同，则使用allkeys-random

# 由于并发量大而导致的缓存问题
https://zhuanlan.zhihu.com/p/346651831

## 缓存穿透
缓存中没有对应数据，还需要去存储系统中查询数据。  
### 有几种情况，怎么解决
- 对应数据**根本不存在**  
1)如果查询存储系统的数据没有找到，则直接设置一个特定值存到缓存中。之后读取缓存时就会获取到这个特定值，直接返回空值，就不会继续访问存储系统了。    
2)把已存在数据的key存放在**布隆过滤器**中。当有新的请求时，先到布隆过滤器中查询是否存在，如果不存在该条数据直接返回；如果存在该条数据再查询缓存查询存储系统。

- 缓存数据时生成耗时较长  
1)限制分页的数量，最大分页就到100页。    
2)后台作业定时更新缓存，而不是在访问页面时生成缓存数据。这样可以按照一定策略定时更新缓存，不会对存储系统较大的瞬时压力。

## 缓存击穿
当一个热点的Key过期时，因为访问这个缓存key 的请求量较大，多个请求同时发现缓存过期，因此多个请求会同时访问数据库来查询最新数据，并且回写缓存，这样会造成应用和数据库的负载增加，性能降低，由于并发较高，甚至会导致数据库被压死。  
### 解决
- 分布式锁
每个key同时只有一个线程去查询后端服务，其他线程没有获得分布式锁的权限，因此只需要等待即可

- 软过期
不使用缓存服务提供的过期时间，由业务程序判断是否过期并更新。

## 缓存雪崩
大规模的key失效  
第一种可能是Redis宕机，第二种可能是采用了相同的过期时间。

### 发生了缓存雪崩，有没有什么兜底的措施？
1、在原有的失效时间上加上一个随机值，比如1-5分钟随机。这样就避免了因为采用相同的过期时间导致的缓存雪崩。

2、使用熔断机制。当流量到达一定的阈值时，就直接返回“系统拥挤”之类的提示，防止过多的请求打在数据库上。至少能保证一部分用户是可以正常使用，其他用户多刷新几次也能得到结果。

3、提高数据库的容灾能力，可以使用分库分表，读写分离的策略。

4、为了防止Redis宕机导致缓存雪崩的问题，可以搭建Redis集群，提高Redis的容灾性。


>Q:如果有大量的key需要设置同一时间过期，一般需要注意什么？
如果大量的key过期时间设置的过于集中，到过期的那个时间点，redis可能会出现短暂的卡顿现象。一般需要在时间上加一个随机值，使得过期时间分散一些。

# 缓存预热
缓存预热就是系统上线后，将相关的缓存数据直接加载到缓存系统。
这样就可以避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题！用户直接查询事先被预热的缓存数据！

## 实现缓存预热思路
目的就是在系统上线前，将数据加载到缓存中。  
1、直接写个缓存刷新页面，上线时手工操作下；  
2、数据量不大，可以在项目启动的时候自动进行加载；

# 缓存重建
https://www.cnblogs.com/wajika/p/6599889.html

# 布隆过滤器的原理
https://developer.aliyun.com/article/773205#slide-15

可以解决网页 URL 去重、垃圾邮件识别、大集合中重复元素的判断和缓存穿透等问题。  
eg1 : 数据库使用BloomFilter来减少不存在的行或列的磁盘查找。避免代价高昂的磁盘查找会大大提高数据库查询操作的性能。  
eg2 :业务场景中判断用户是否阅读过某视频或文章，比如抖音或头条，当然会导致一定的误判，但不会让用户看到重复的内容。  


是由一个固定大小的二进制向量或者位图（bitmap）和一系列映射函数组成的。

查询某个变量的时候我们只要看看这些点是不是都是 1 就可以大概率知道集合中有没有它了

如果这些点有任何一个 0，则被查询变量一定不在；
如果都是 1，则被查询变量很可能存在

## Redis 中的 BloomFilter


Redis 提供的 bitMap 可以实现布隆过滤器，另外Redis 官方提供的布隆过滤器到了 Redis 4.0 提供了插件功能之后才正式登场。布隆过滤器作为一个插件加载到 Redis Server 中，给 Redis 提供了强大的布隆去重功能。
                             
### 在已安装 Redis 的前提下，安装 RedisBloom
`redis-server --loadmodule /path/to/rebloom.so   #运行redis时加载布隆过滤器模块`

#### 使用
bf.add 添加元素到布隆过滤器  
bf.exists 判断元素是否在布隆过滤器  
bf.madd 添加多个元素到布隆过滤器，bf.add 只能添加一个  
bf.mexists 判断多个元素是否在布隆过滤器  

# Redis事务
事务具有原子性，一个事务中的一系列的操作要么全部成功，要么一个都不做。这也就是事务的四大特性，也就是我们常说的ACID。
redis事务：可以一次执行多个命令，本质是一组命令的集合。一个事务中的所有命令都会序列化，按顺序地串行化执行而不会被其它命令插入，不许加塞，也不会改去执行其它客户端的命令请求。

## Redis 最简单的事务实现方式
使用 MULTI 和 EXEC 命令将事务操作包围起来。
redis先将属于一个事务的多个命令一起发送给服务器，然后再依次执行这些命令。  
`MULTI`标记一个事务的开始，告知服务器接下来的命令都属于同一个事物，后面的命令都会被加入等待执行的事务队列中。
`EXEC`执行事务队列中的所有命令，并保证不会被其他命令插入，当事务里所有命令都执行完后，返回每个命令的返回值。  
![](https://img-blog.csdn.net/20161216211303499?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY3VpcGVuZzA5MTY=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

## 回滚 
`discard`取消事务，放弃本次事务的操作，放弃之后那些命令并没有执行。有点像回滚。
![](https://img-blog.csdn.net/20161216211658298?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY3VpcGVuZzA5MTY=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

但是，若出现执行出错的情况，所有命令都将不执行。
![](https://img-blog.csdn.net/20161216212134227?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY3VpcGVuZzA5MTY=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)
这个就像关系型数据库中的事务的一致性，要么一起成功，要么一起失败。

## 事务的非一致性
![](https://img-blog.csdn.net/20161216213406854?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY3VpcGVuZzA5MTY=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)
发现正确的命令执行了，而那些执行失败的命令是没有执行的。
与上一个例子相比，好比是java的运行时异常和非运行时异常一个意思。所以实例3中事务都回滚了，但是实例4中的部分成功，部分失败。

**redis对事务是部分支持的，如果是在入队时报错，那么都不会执行；在非入队时报错，那么成功的就会成功执行。**

## redis监控“锁”
若出现某条命令需要先获取上一条命令返回值才能继续执行的情况时，由于redis事务中每个命令的返回值都是最后一起返回的，这种情况不能“将上一条命令”与该命令都加入到事务中，而是获取“上一条命令”返回值后再使用事务，并采用类似“锁”的监控机制，在执行事务前防止获取的返回值被改变造成脏读。  

- `WATCH`命令可以监控一个或多个键，监控一直持续到`EXEC`命令，一旦其中有一个被其他客户端改动，之后的事务便不会执行，同时返回Nullmulti-bulk应答以通知调用者事务执行失败。
案例一：
![](https://img-blog.csdn.net/20161216224210885?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY3VpcGVuZzA5MTY=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)
在watch银行卡余额时然后将余额修改成200，在开启事务去修改余额，发现事务执行失败，因为这个时候在事务执行之前余额已经被其他人修改过了，所以事务执行失败了。

>若`WATCH`监控一个设置了生存时间的键，该键到期自然死亡后，WATCH并不会被认为该键被改变。

- `UNWATCH`取消监控 
案例二：
![](https://img-blog.csdn.net/20161216225315670?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY3VpcGVuZzA5MTY=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

## LUA脚本
在事务的基础上，如果我们需要在服务端一次性的执行更复杂的操作（包含一些逻辑判断），则lua就可以排上用场了。

## redis事务三大特性：
- 单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命-令请求所打断。
- 没有隔离级别的概念：队列中的命令没有提交之前都不会实际的被执行，因为事务提交前任何指令都不会被实际执行，也就不存在”事务内的查询要看到事务里的更新，在事务外查询不能看到”这个让人万分头痛的问题
- 不保证原子性：redis同一个事务中如果有一条命令执行失败，其后的命令仍然会被执行，没有回滚

## 延迟重启(delayed restarts)
一个节点崩溃后，先不立即重启它，而是等待一段时间再重启，这段时间应该大于锁的有效时间(lock validity time)。这样的话，这个节点在重启前所参与的锁都会过期，它在重启后就不会对现有的锁造成影响。

# 假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？
使用keys指令可以扫出指定模式的key列表。
如果这个redis正在给线上的业务提供服务，那使用keys指令会有什么问题？
因为redis是单线程的。keys指令会导致线程阻塞一段时间，线上服务会停顿，直到指令执行完毕，服务才能恢复。
这个时候可以使用scan指令，scan指令可以无阻塞的提取出指定模式的key列表，但是会有一定的重复概率，在客户端做一次去重就可以了，但是整体所花费的时间会比直接用keys指令长。
不过，增量式迭代命令也不是没有缺点的： 举个例子， 使用 SMEMBERS 命令可以返回集合键当前包含的所有元素， 但是对于 SCAN 这类增量式迭代命令来说， 因为在对键进行增量式迭代的过程中， 键可能会被修改， 所以增量式迭代命令只能对被返回的元素提供有限的保证 。
???

使用过Redis做异步队列么，你是怎么用的？
一般使用list结构作为队列，rpush生产消息，lpop消费消息。当lpop没有消息的时候，要适当sleep一会再重试。
如果对方追问可不可以不用sleep呢？list还有个指令叫blpop，在没有消息的时候，它会阻塞住直到消息到来。
如果对方追问能不能生产一次消费多次呢？使用pub/sub主题订阅者模式，可以实现1:N的消息队列。
如果对方追问pub/sub有什么缺点？在消费者下线的情况下，生产的消息会丢失，得使用专业的消息队列如rabbitmq等。
如果对方追问redis如何实现延时队列？
使用sortedset，拿时间戳作为score，消息内容作为key调用zadd来生产消息，消费者用zrangebyscore指令获取N秒之前的数据轮询进行处理。






常见的性能问题有哪些？该如何解决？
主服务器写内存快照，会阻塞主线程的工作，当快照比较大时对性能影响是非常大的，会间断性暂停服务，所以主服务器最好不要写内存快照。
Redis 主从复制的性能问题，为了主从复制的速度和连接的稳定性，主从库最好在同一个局域网内。

Redis常见性能问题和解决方案：
(1) Master最好不要写内存快照，如果Master写内存快照，save命令调度rdbSave函数，会阻塞主线程的工作，当快照比较大时对性能影响是非常大的，会间断性暂停服务。

(2) 如果数据比较重要，某个Slave开启AOF备份数据，策略设置为每秒同步一次

(3) 为了主从复制的速度和连接的稳定性，Master和Slave最好在同一个局域网内

(4) 尽量避免在压力很大的主库上增加从库

(5) 主从复制不要用图状结构，用单向链表结构更为稳定，即：Master <- Slave1 <- Slave2 <- Slave3...这样的结构方便解决单点故障问题，实现Slave对Master的替换。如果Master挂了，可以立刻启用Slave1做Master，其他不变。



支持的Java客户端都有哪些？官方推荐用哪个？
Redisson、Jedis、lettuce等等，官方推荐使用Redisson。
Jedis与Redisson对比有什么优缺点？
答：Jedis是Redis的Java实现的客户端，其API提供了比较全面的Redis命令的支持；Redisson实现了分布式和可扩展的Java数据结构，和Jedis相比，功能较为简单，不支持字符串操作，不支持排序、事务、管道、分区等Redis特性。Redisson的宗旨是促进使用者对Redis的关注分离，从而让使用者能够将精力更集中地放在处理业务逻辑上。


如何做内存优化？

尽可能使用散列表（hashes），散列表（是说散列表里面存储的数少）使用的内存非常小，所以你应该尽可能的将你的数据模型抽象到一个散列表里面。比如你的web系统中有一个用户对象，不要为这个用户的名称，姓氏，邮箱，密码设置单独的key,而是应该把这个用户的所有信息存储到一张散列表里面.

Pipeline有什么好处，为什么要用pipeline？
答：可以将多次IO往返的时间缩减为一次，前提是pipeline执行的指令之间没有因果相关性。使用redis-benchmark进行压测的时候可以发现影响redis的QPS峰值的一个重要因素是pipeline批次指令的数目。

假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？
答：使用keys指令可以扫出指定模式的key列表。

对方接着追问：如果这个redis正在给线上的业务提供服务，那使用keys指令会有什么问题？

这个时候你要回答redis关键的一个特性：redis的单线程的。keys指令会导致线程阻塞一段时间，线上服务会停顿，直到指令执行完毕，服务才能恢复。这个时候可以使用scan指令，scan指令可以无阻塞的提取出指定模式的key列表，但是会有一定的重复概率，在客户端做一次去重就可以了，但是整体所花费的时间会比直接用keys指令长。







# 缓存策略（了解）
最常用的————Cache-Aside  
读取：
失效：应用程序先从cache取数据，没有得到，则从数据库中取数据，成功后，放到缓存中。
命中：应用程序从cache中取数据，取到后返回。
更新：先把数据存到数据库中，成功后，再让缓存失效。

Read/Write-Through
1.应用要读数据和更新数据都直接访问缓存服务
2.缓存服务同步的将数据更新到数据库
这个模式出现脏数据的概率就比较低，但是就强依赖缓存了，对缓存服务的稳定性有较大要求，另外，增加新缓存节点时还会有初始状态空数据问题。

Write-Behind-Caching
1.应用要读数据和更新数据都直接访问缓存服务
2.缓存服务异步的将数据更新到数据库（通过异步任务）
这个模式的特点就是速度很快，效率会非常高，但是数据的一致性比较差，还可能会有数据的丢失情况，实现逻辑也较为复杂。




# redis-cli操作
http://redisdoc.com/string/setnx.html

https://www.redis.net.cn/order/3543.html

大小写不敏感 
`config set requirepass 123456`设置密码
`auth 123456`授权密码
`./redis-server` 服务启动
`$ redis-cli PING` 如果连接正常会受到PONG的回复，用来测试客户端与redis的连接是否正常（也可以直接`> PING`）。 
`$ redis-cli -h 127.0.0.1 -p 6379`  进入交互模式  
`> select [index]`选择索引数据库，index为索引值名，如：`select 1`。
`shutdown`表示关闭redis服务
`exit`、` quit` 表示退出redis连接


## 管理命令
```
`dbsize`返回当前数据库 key 的数量。
`info` 返回当前 redis 服务器状态和一些统计信息。
`info memory`Redis 内存使用情况查看
`monitor` 实时监听并返回redis服务器接收到的所有请求信息。
`shutdown` 把数据同步保存到磁盘上，并关闭redis服务。
`config get parameter` 获取一个 redis 配置参数信息。（个别参数可能无法获取）
`config set parameter value` 设置一个 redis 配置参数信息。（个别参数可能无法获取）
`config resetstat` 重置 info 命令的统计信息。（重置包括：keyspace 命中数、
`keyspace` 错误数、 处理命令数，接收连接数、过期 key 数）
`debug object key `获取一个 key 的调试信息。
`debug segfault` 制造一次服务器当机。
`flushdb` 删除当前数据库中所有 key,此方法不会失败。小心慎用
`flushall` 删除全部数据库中所有 key，此方法不会失败。小心慎用
```

## 工具命令
```
`redis-server`Redis 服务器的 daemon 启动程序
`redis-cli`Redis 命令行操作工具。当然，你也可以用 telnet 根据其纯文本协议来操作
`redis-benchmark`Redis 性能测试工具，测试 Redis 在你的系统及你的配置下的读写性能
`redis-benchmark -n 100000 –c 50` 模拟同时由 50 个客户端发送 100000 个 SETs/GETs 查询
`redis-check-aof`更新日志检查
`redis-check-dump`本地数据库检查
```

## 配置
`CONFIG SET ...`命令可以在不重启服务的情况下动态修改redis配置，如日志级别loglevel，是否开启持久化等，但也不支持所有的配置项。
`CONFIG GET ...`命令查看当前配置情况。  

## 过期时间
```
`expire key seconds`：设置 key 在 n 秒后过期；
`pexpire key milliseconds`：设置 key 在 n 毫秒后过期；
`expireat key timestamp`：设置 key 在某个时间戳（精确到秒）之后过期；
`pexpireat key millisecondsTimestamp`：设置 key 在某个时间戳（精确到毫秒）之后过期；

`TTL`获取该键还有多久时间被删除，返回-1表示该键已不存在，或没有为该键设置生存时间。`PTTL`以毫秒为单位返回剩余时间。    
`PERSIST`取消生存时间设置，使得永久有效。使用SET、GETSET命令为键赋值时也会清除生存时间设置。其他如HSET、ZREM、LPUSH只对键值操作的命令不影响键的生存时间。
```
## 键值获取
`EXISTS (键名)`判断一个键是否存在，存在则返回1，否则0。  
`DEL (键名，多个键空格隔开)`删除键，返回值是删除的个数。
可以通过管道实现通配删除：`redis-cli KEYS "user:*" | xargs redis-cli DEL`删除所有以"user："开头的键。或者`redis-cli DEL 'redis-cli KEYS "user:*"'`  

`TYPE (键名)`获得键值的数据类型。  

`STRLEN (键名)`获得键值的长度（中文的话，计算的是utf-8编码后的长度）。不存在，返回0。

查看当前库有哪些键`KEYS  (pattern)`：
![clipboard.png](/img/bVbu3zv)
支持`*`、`?`、`[]`、`\x`(表示匹配字符x，如匹配问好，就 `KEYS \?`)  
需要遍历所有键，当数据量多时，不建议使用。  

>Redis中海量数据的正确操作方式
利用SCAN系列命令（SCAN、SSCAN、HSCAN、ZSCAN）完成数据迭代。

### SCAN系列命令注意事项
SCAN的参数没有key，因为其迭代对象是DB内数据；
返回值都是数组，第一个值都是下一次迭代游标；
时间复杂度：每次请求都是O(1)，完成所有迭代需要O(N)，N是元素数量；
可用版本：version >= 2.8.0；

## 键值设置
https://www.javazhiyin.com/62931.html
### string类型值
`SET (键名) (值)` 赋字符串类型值。项目中键的命名有个建议是`对象类型:对象id：对象属性` 
`GET (键名)` 当键不存在时会返回空。  

`MSET (键名) (值)` 可以设置多个键值。
`MGET (键名)` 当键不存在时会返回空。 
![clipboard.png](/img/bVbu3FT)

`SETNX `是『SET if Not eXists』(如果不存在，则 SET)的简写。

虽然没有整数类型，但也提供了用于整数操作的命令，如`INCR`：
![clipboard.png](/img/bVbu3zm)
常用于统计文章访问量等。  

`INCRBY (键名) (步长)`递增非1的情况使用。如果要递增浮点数，使用`INCRBYFLOAT`。
同样，`INCR`都可以换为`DECR`实现递减。

`APPEND (键名) (带双引号的字符串)`实现向键值末尾追加。若键不存在，则相当于在null里追加。

### hash类型值
`HSET 键名 字段名 字段值`  用来给hash类型数据赋值即插入（返回1），也可能是更新（返回0）。
`HSETNX 键名 字段名 字段值`与上面的区别是如果字段已经存在，不会执行返回0。
`HGET 键名 字段名`
`HMSET 键名 (字段名1 字段值1) (字段名2 字段值2) (字段名3 字段值3)...`
`HMGET 键名 (字段名1) (字段名2) (字段名3)`  同时获取多个字段值
`HGETALL 键名` 获取所有键值
`HEXISTS 键名 字段名`判断一个字段是否存在，存在则返回1，否则（以及键不存在时）返回0。  

`HINCRBY 键名 字段名 步长`使指定字段的字段值增加指定的整数。不存在的键会自动被建立。

`HDEL 键名 字段名1 2 3`可以删除一个或多个字段，返回删除字段的个数。  

`HKEYS 键名` 或 `HVALS 键名` 分别获取该键的所有字段名和所有字段值。  
`HLEN 键名` 获得该键名的字段数。  

### list类型值
`LPUSH 键名 值1 值2...` 从左侧插入数据，`RPUSH`表示从右侧插入。返回该键的元素数量。  
`LPOP 键名` 从列表左侧弹出一个元素。`RPOP`表示从右侧弹出。
`LLEN 键名` 返回列表中元素的个数。不存在返回0。
`LRANGE 键名 起始索引 结尾索引` 从左往右，获取列表分片，起始从0开始，而且包含两端的元素。索引为负值，如-1表示右边的第一个元素。  
`LRANGE 键名 0 -1`可以获取列表中所有元素，另外若”起始索引“位置比”结尾索引“位置靠后，会返回空列表；”结尾索引“大于实际索引范围则会返回到列表最右边的元素为止。  
`LTRIM 键名 起始索引 结尾索引`删除指定索引范围外的所有元素。  

`LREM 键名 个数 值` 当”个数“>0时，会删除从左边数前"个数"个值为"值"的元素； 当”个数“=0时，会删除所有值为"值"的元素；当”个数“<0时，会删除从右边数前"个数"的绝对值个值为"值"的元素。返回实际删除的元素个数。

`LINDEX 键名 索引` 获取指定索引（从0开始，负数表示从右边开始计算最右是-1）的元素值。
`LSET 键名 索引 值` 设置指定索引的元素值。
`LINSERT 键名 BEFORE|AFTER pivot value` 从左到右找到值为pivot的元素，然后根据第二个参数BEFORE|AFTER将value插入到该值的前或后面。返回最后列表的元素的个数。

`RPOPLPUSH source destination` 从源列表RPOP一个元素，然后LPUSH到目标列表。返回这个元素的值。相当于一个队列操作。源和目标列表可以是同一个列表。

### set类型值
`SADD 键名 元素1 元素2...`增添一个或多个元素，键不存在自动创建。返回成功加入元素的个数。
`SREM 键名 元素1 元素2...`删除一个或多个元素，返回删除成功的个数。  
`SPOP 键名` 从集合中随机弹出一个元素。

`SMEMBERS 键名`返回集合中所有元素。
`SRANDMEMBER 键名`随机从集合中获取一个元素。后面也可以加数字表示返回该数字个元素，分正、负、以及大于集合数的情况。
ps:这种“随机”对每一个元素并不是平等的。首先是随机选一个桶，然后在桶里随机选元素。没有哈希冲突的元素被选中的几率要大于有哈希冲突的。  

`SCARD 键名` 获取集合中元素个数。
`SISMEMBER 键名 元素` 判断元素是否在集合中。存在返回1，不存在或键不存在时返回0。

`SDIFF 键1 键2 键3...`多集合的差集运算。使用`SDIFFSTORE 键0 键1 键2 ...`将结果集存储在键0中。
`SINTER 键1 键2 键3...`多集合的交集运算。`SINTERSTORE、SUNIONSTORE`类似。
`SUNION 键1 键2 键3...`多集合的并集运算。

###  sorted set类型值
`ZADD 键名 score1 元素1 score2 元素2 ...`增加元素，返回新增元素个数（不包括重复覆盖的）。 
`ZSCORE 键名 元素` 获取元素的score。
`ZRANGE 键名 start stop `返回按score从小到大排序后在指定索引区间里（包含两端） 的元素。加上`WITHSCORES`也会返回元素的score。另外从大到小，使用`ZREVRANGE`。

`ZRANGEBYSCORE 键名 minScore maxScore` 返回指定score范围里的元素。也可带`WITHSCORES`，以及`LIMIT offset count`，还可以指定不包含端点值，还可以使用`-inf、+inf`表示负无穷、正无穷。同样也有`ZREVRANGEBYSCORE`，先maxScore再minScore。  

`ZINCRBY 键名 increment 元素` 增加某个元素的score，返回最后该元素的分数。元素不存在时，会初始化为0再加。  

`ZCARD、ZCOUNT、ZREM、ZREMRANGEBYRANK、ZREMRANGEBYSCORE、ZRANK`以及一些集合运算命令

#### 排序
redis提供了对列表、集合、有序集合（忽略score）类型键的排序命令`SORT`。  
可以对数字排序，还有指定`ALPHA`参数实现字典排序。  
`DESC`实现倒序。 
`LIMIT offset count`实现返回值的指定范围（跳过前offset个元素，获取count个元素）。  

`BY`参数后面加参考键（字符串类型或hash类型键的某个字段`键名->字段名`），命令将对“每个元素的值替换参考键中第一个*（可以是键名带*，可以是字段名带*）并获取其值后的值”排序。  
若得到的值相同，则会再比较元素本身的值再排序。  
当参考键不带*时（常量键名，与元素值无关），或改参考键不存在时，命令不会执行排序操作。  

## Redis 管道 Pipeline
在某些场景下我们在一次操作中可能需要执行多个命令，而如果我们只是一个命令一个命令去执行则会浪费很多网络消耗时间，如果将命令一次性传输到 Redis中去再执行，则会减少很多开销时间。但是需要注意的是 pipeline中的命令并不是原子性执行的，也就是说管道中的命令到达 Redis服务器的时候可能会被其他的命令穿插







