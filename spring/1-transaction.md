https://mp.weixin.qq.com/s?__biz=MzIyNjAzODEyMg==&mid=2247484763&idx=1&sn=f81b9fbdf26049e407fe78306014c654&source=41#wechat_redirect

# Spring声明式事务实现原理

声明式事务成为可能，主要得益于Spring AOP。使用一个事务拦截器，在方法调用的前后/周围进行事务性增强（advice），来驱动事务完成。

Spring团队建议注解标注在类上而非接口上。
只有public方法支持事务。

https://blog.csdn.net/qq_33369905/article/details/105828921

# Spring 事务的传播属性

针对方法嵌套调用时事务的创建行为定义了七种事务传播机制，分别是:
## PROPAGATION_REQUIRED（Spring默认）
如果外部方法没有开启事务的话，Propagation.REQUIRED（默认就是）修饰的内部方法会新开启自己的事务，且Propagation.REQUIRED（默认就是）修饰的内部方法之间开启的事务相互独立，互不干扰。
如果外部方法开启事务并且指定为Propagation.REQUIRED(默认就是)，所有Propagation.REQUIRED修饰的内部方法和外部方法均属于同一事务 ，只要一个方法回滚，整个事务均回滚。

## PROPAGATION_SUPPORT
支持当前事务。如果当前有事务，就参与进来，如果没有，就以非事务的方式运行。

## PROPAGATION_MANDATORY
如果当前方法没有事务存在，就抛出异常。

## PROPAGATION_REQUIRES_NEW
总是使用一个独立的物理事务用于每一个受影响的逻辑事务范围，从来不参与到一个已存在的外围事务范围。
这样安排的话，底层的事务资源是不同的，因此，可以独立地提交或回滚。
外围事务不会被内部事务的回滚状态影响。
这样一个独立的内部事务可以声明自己的隔离级别，超时时间和只读设置，并不继承外围事务的特性。

## PROPAGATION_NOT_SUPPORTED
不支持当前事务。总是以非事务方式运行。

## PROPAGATION_NEVER
如果当前有事务存在，就抛出异常。

## PROPAGATION_NESTED
使用同一个物理事务，但带有多个保存点，可以回滚到这些保存点，可以认为是**部分回滚**，这样一个内部事务范围触发了一个回滚，外围事务能够继续这个物理事务，尽管有一些操作已经被回滚。
典型地，它对应于JDBC的保存点，所以只对JDBC事务资源起作用。

生成一个保存点就是生成一个数据镜像。然后无论经过了什么sql操作，只要使用回滚至此保存点的命令即可恢复至创建保存点的数据状态。


# 脏读
一个事务修改了一行数据但没有提交，第二个事务可以读取到这行被修改的数据，如果第一个事务回滚，第二个事务获取到的数据将是无效的。

# 不可重复读
一个事务读取了一行数据，第二个事务修改了这行数据，第一个事务重新读取这行数据，将获得到不同的值。

# 幻读
一个事务按照一个where条件读取所有符合的数据行，第二个事务插入了一行数据且恰好也满足这个where条件，第一个事务再以这个where条件重新读取，将会获取额外多出来的这一行。

总结：写读是脏读，读写读是不可重复读，where insert where是幻读。

[mysql 事务](https://segmentfault.com/a/1190000019684584)


# Spring事务不生效的原因
1、是否是数据库引擎设置不对造成的。比如我们最常用的mysql，引擎MyISAM，是不支持事务操作的。需要改成InnoDB才能支持
2、入口的方法必须是public，否则事务不起作用（这一点由Spring的AOP特性决定的，理论上而言，不public也能切入，但spring可能是觉得private自己用的方法，应该自己控制，不应该用事务切进去吧）。另外 final 方法 和 static 方法不能aop生效。
3、Spring的事务管理默认只对出现运行期异常(java.lang.RuntimeException及其子类)进行回滚。
4、确认你的类是否被代理了（因为spring的事务实现原理为AOP，只有通过代理对象调用方法才能被拦截，事务才能生效）
5、确保你的业务和事务入口在同一个线程里，否则事务也是不生效的
6、非事务方法this.调用本类中的事务方法。
  
