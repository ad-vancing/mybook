# 继承
1、子类会自动调用父类的无参构造函数。子类中写不写都可以。

2、如果子类有个无参构造器（如子类TestB），那么父类也需要有，否则编译出错。
因为子类TestB会自动寻求调用TestA的无参构造函数，但是此时TestA中只有一个TestA(String s)，
需要在TestA中加上无参构造器，或者在TestB的构造函数中加上"super("xxx")显式地调用父类的构造方法，便不会再寻求调用TestA的无参构造函数。
ps：super()与this()调用构造方法都必须出现在构造方法的第一行。

3、因此，从这里我们还应该能看出，当我们在一个类中定义了自己的带参数的构造方法的时候，必须把无参构造函数定义一下！


# 多态


# static 
子类不能覆盖父类的静态方法，除非子类也是静态方法，但是没有多态。。。
在使用对象调用静态方法时，其实是调用编译时类型的静态方法。
main方法必须是静态的原因：静态方法可以不通过对象调用，而是在类加载时即可调用。
它修饰的代码块，只在类加载时被执行一次（相对应的动态代码块，在生成对象时运行）。

##  static 与执行顺序
执行顺序：静态代码块—主程序—非静态代码块—构造函数（调用了有参就不再调用无参）—一般方法。
由于静态初始化块只在类加载时执行一次，所以当再次创建对象时并未执行静态初始化块。
（创建类的实例时，会再次执行非静态代码块和构造方法。）

##  static 子类与执行顺序
加入了子类以后，执行顺序有了新的变化，是父类的静态代码块—子类的静态代码块—主程序。
这一部分都是执行一次，与建立多少对象没有关系。
第二部分new了一个父类对象，并调用了方法。执行了它的非静态代码块—构造函数—一般方法。
第三部分new了一个子类的对象，并调用了方法。执行顺序为父类的非静态代码块—父类的无参构造函数，然后是子类的非静态代码块—子类构造函数—子类的方法。
https://www.cnblogs.com/coodream2009/p/5496474.html

# 类的实例化顺序

先静态：父静态 > 子静态
优先级：父类 > 子类 静态代码块 > 非静态代码块 > 构造函数