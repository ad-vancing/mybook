[锁](https://tech.meituan.com/2018/11/15/java-lock.html)

# Lock机制的实现
https://blog.csdn.net/weixin_40388441/article/details/115707839


# Lock接口有哪些实现类，使用场景
可重入锁 ReentrantLock：表示重入锁，它是唯一一个实现了 Lock 接口的类。
ReentrantReadWriteLock 实现了 ReadWriteLock 接口：读写锁分成两个锁，一个锁是读锁，一个锁是写锁。读锁与读锁之间是共享的，读锁与写锁之间是互斥的，写锁与写锁之间也是互斥的。

StampedLock： stampedLock 是 JDK8 引入的新的锁机制，可以简单认为是读写锁的一个改进版本，读写锁虽然通过分离读和写的功能使得读和读之间可以完全并发，但是读和写是有冲突的，如果大量的读线程存在，可能会引起写线程的饥饿。stampedLock 是一种乐观的读策略，使得乐观锁完全不会阻塞写线程。

# Synchronized和Lock的区别
Lock类实际上是一个接口，我们在实例化的时候实际上是实例化实现了该接口的类Lock lock = new ReentrantLock();。
加锁，和释放锁都是在try-finally。这样的好处是在任何异常发生的情况下，都能保障锁的释放。

Lock类提供了丰富的加锁的方法和对加锁的情况判断。主要有

实现锁的公平：按照线程加锁的顺序来获取锁
获取当前线程调用lock的次数，也就是获取当前线程锁定的个数：当前线程调用lock方法的次数。一般一个方法只会调用一个lock方法，但是有可能在同步代码中还有调用了别的方法，那个方法内部有同步代码。这样，getHoldCount()返回值就是大于1。
获取等待锁的线程数：getQueueLength()方法来得到等待锁释放的线程的个数。
查询指定的线程是否等待获取此锁定：hasQueuedThread(Thread thread)查询该Thread是否等待该lock对象的释放。
查询是否有线程等待获取此锁定：是否有线程在等待锁释放即hasQueuedThreads()。
查询当前线程是否持有锁定：是否当前线程持有锁即isHeldByCurrentThread()。
判断一个锁是不是被线程持有：判断一个锁是不是被一个线程持有，即isLocked()。
加锁时如果中断则不加锁，进入异常处理
尝试加锁，如果该锁未被其他线程持有的情况下成功：tryLock()方法来进行尝试加锁，只有该锁未被其他线程持有的基础上，才会成功加锁。

配合Condition类来实现wait/notify机制。

# 公平锁和非公平锁的区别
- 公平锁
多个线程按照申请锁的顺序去获得锁，线程会直接进入队列去排队，永远都是队列的第一位才能得到锁。

优点：所有的线程都能得到资源，不会饿死在队列中。
缺点：吞吐量会下降很多，队列里面除了第一个线程，其他的线程都会阻塞，cpu唤醒阻塞线程的开销会很大。

- 非公平锁
多个线程去获取锁的时候，会直接去尝试获取，获取不到，再去进入等待队列，如果能获取到，就直接获取到锁。

优点：可以减少CPU唤醒线程的开销，整体的吞吐效率会高点，CPU也不必取唤醒所有线程，会减少唤起线程的数量。
缺点：你们可能也发现了，这样可能导致队列中间的线程一直获取不到锁或者长时间获取不到锁，导致饿死。