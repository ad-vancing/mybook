https://www.cnblogs.com/Tu9oh0st/p/11165905.html

# 缓存不一致问题
如果一个变量在多个CPU中都存在缓存（一般在多线程编程时才会出现），那么就可能存在缓存不一致的问题。  

有两个线程A，B；初始的时候分别从主存中读取i的值，然后放在各自所在的CPU高速缓存中，然后线程A进行+1操作，然后把i最新的值写入到主存。  
此时线程B的高速缓存中i的值还是0，进行+1操作，i的值为1.然后线程B把i的值写入到内存。最终i的值是1，而不是2。


## 2种解决方法：
1）通过在总线加LOCK#锁的方式（效率低下）  
2）通过缓存一致性协议————MESI协议保证了每个缓存中使用的共享变量的副本是一致的。它核心的思想是：当CPU写数据时，如果发现操作的变量是共享变量，即在其他CPU中也存在该变量的副本，会发出信号通知其他CPU将该变量的缓存行置为无效状态，因此当其他CPU需要读取这个变量时，发现自己缓存中缓存该变量的缓存行是无效的，那么它就会从内存重新读取。

# volatile关键字的作用：
用于表示可以被多个线程异步修改的成员变量。这样其实通过主内存就实现了线程之间的通信。

一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义：  
1）保证了**不同线程对这个变量进行操作时的可见性**，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。  
2）禁止进行指令重排序。

>指令重排序：编译器或运行时环境为了优化程序性能而采取的对指令进行重新排序执行的一种手段。

3)原子性：对单个volatile的读和写具有原子性，但是对volatile++这种复合的计数操作不具有原子性。不能用于线程安全计数器。 因为volatile++这种操作，实质上是由一个读取-修改-写入操作序列组成的组合操作。

从JMM内存语义上来讲，当写一个volatile变量的时候，JMM会把该线程的对应的本地缓存中的共享变量值立即刷新到主内存中。当读一个volatile共享变量时候，JMM会把该线程对应的本地缓存置为无效，也就是上面缓存一致性说的会把该CPU线程对应的缓存行至为无效。直接从主存中读取。


# volatile的原理和实现机制
volatile是如何保证可见性和禁止指令重排序的？
**lock前缀指令**

lock前缀指令实际上相当于一个内存屏障（**内存栅栏**），内存屏障会提供保证：    
1）它会强制将对缓存的修改操作立即写入主存；  
2）如果是写操作，它会导致其他CPU中对应的缓存行无效。

>什么是内存屏障？内存屏障，是一个CPU的指令，在程序运行时，为了提高执行的性能，编译器和处理器会对指令进行重排序，JMM为了保证不同不同编译器和CPU上有相同的结果，通过插入特定类型的内存屏障来禁止特定类型的编译器的重排序和处理器的重排序，插入一条内存屏障告诉编译器和CPU；不管什么指令都不能对这条内存屏障进行指令的重排序。



![](https://img2018.cnblogs.com/blog/1331583/201908/1331583-20190821102846204-2145817795.png)

# volatitle的使用条件

1. 对变量的写操作不依赖当前值，如多线程对共享变量执行i++操作，是无法通过volatile保证结果的正确性的；

2. 该变量没有包含在具有其他变量的不变式中

# 用到的volatile关键字的场景
- 在高并发的场景中，通过一个boolean类型的变量控制开关按钮，控制代码的逻辑开关（立即生效的开关）

- 懒汉单例的应用中double check检查防止进行重排序
  



# 锁和volatile关键字的对比
功能上锁比volatile更强大，可以保证操作的原子；而可伸缩性和执行的性能上volatile比锁更有优势。  
volatile可以看成一种"程度较轻的synchronized"，与synchronized 块相比，volatile变量的使用所需的编码较少，并且运行开销比较小。  
但是不能保证原子性，需要结合一些技术来保证，比如CAS。并发包下面的原子类，**可重入锁的实现就是通过volatile结合CAS来实现的**。

# volatile和synchronized的区别
volatile本质是在告诉jvm当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取； synchronized则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。  
volatile仅能使用在变量级别；synchronized则可以使用在变量、方法、和类级别的  
volatile仅能实现变量的修改可见性，不能保证原子性；而synchronized则可以保证变量的修改可见性和原子性  
volatile不会造成线程的阻塞；synchronized可能会造成线程的阻塞。  
volatile标记的变量不会被编译器优化；synchronized标记的变量可以被编译器优化