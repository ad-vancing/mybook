# Java中switch都可以支持哪些数据类型

在JDK1.5之前,switch循环只支持**byte short char int**四种数据类型；
JDK1.5 在switch循环中增加了**枚举类**与byte short char int的**包装类**,对四个包装类的支持是因为java编译器在底层手动进行拆箱,而对枚举类的支持是因为枚举类有一个**ordinal**方法,该方法实际上是一个int类型的数值；
jdk1.7开始支持**String**类型,但实际上String类型有一个hashCode算法,结果也是int类型.而byte short char类型可以在不损失精度的情况下向上转型成int类型.**所以总的来说,可以认为switch中只支持int**。


# catch  Throwable 与 Exception 有啥区别

如 StackOverflowError 和 OutOfMemoryError 都不属于 Exception 的子类。

# i++ 和 ++i 的区别

i++：从局部变量表取出 i 并压入操作栈(load memory)，然后对局部变量表中的 i 自增 1(add&store memory)，将操作栈栈顶值取出使用，最后，使用栈顶值更新局部变量表，如此线程从操作栈读到的是自增之前的值。
++i：先对局部变量表的 i 自增 1(load memory&add&store memory)，然后取出并压入操作栈(load memory)，再将操作栈栈顶值取出使用，最后，使用栈顶值更新局部变量表，线程从操作栈读到的是自增之后的值。


# &和&&的区别

&运算符有两种用法：(1)按位与；(2)逻辑与。&&运算符是短路与运算。

逻辑与跟短路与的差别是非常巨大的，虽然二者都要求运算符左右两端的布尔值都是true整个表达式的值才是true。&&之所以称为短路运算是因为，如果&&左边的表达式的值是false，右边的表达式会被直接短路掉，不会进行运算。很多时候我们可能都需要用&&而不是&，例如在验证用户登录时判定用户名不是null而且不是空字符串，应当写为：username != null &&!username.equals("")，二者的顺序不能交换，更不能用&运算符，因为第一个条件如果不成立，根本不能进行字符串的equals比较，否则会产生NullPointerException异常。注意：逻辑或运算符（|）和短路或运算符（||）的差别也是如此。


# 两个对象的 hashCode()相同，则 equals()也一定为 true吗？

`equals ==> hashCode相等`
equals是hashCode相等的充分条件，hashCode相等是equals的必要条件（从数学课上我们知道它的逆否命题：hashCode不相等也不会equals），但是它的逆命题——hashCode相等一定equals以及否命题——不equals时hashCode不等都不成立！！！

ps:最好把hashCode与equals之间没有强制关系，以及根据（没有语法约束力的）规范的角度，应当做到…这两层意思都说出来！

## hashcode()方法

默认返回的是内存地址生成的一个 int 值（虚拟机的实现不同，可能有出入），也就是说默认的hashcode是唯一的（因为内存地址唯一）。

> 1、不同的对象，哈希值一般不同；
2、而如果equals判断不相等的两个对象，其hashCode可以相同（只不过会发生哈希冲突，应尽量避免）
3、如果重写了Object的hashcode方法，那么hashcode的生成规则是由子类自己决定，与内存地址就无关了（只是与当前对象的内存地址无关了，其实质还是通过对象的某些字段的内存地址生成的int值）。
> 

## equals()方法

默认是用==实现的，会比较对象的引用是否指向同一块内存地址。
重写后可以比较两个对象是否内容相同（尽管地址不一样）。
**此方法被重写后，同时也需要重写hashCode方法**（尤其在Set这种存放不重复元素的集合里，最后使得不同地址但内容相同的元素不能再加进去了），以维护hashCode常规协定（相等对象哈希码相等）。
API手册对这两个方法的重写有说明，重写原则：

> 1 成对重写。即：当我们需要重写一个类的equals方法时就应当连同重写hashcode
2 一致性。即:当两个对象equals比较为true时，hashcode方法返回的数字应当相等。
反之亦然。虽然反之不是必须的，但是应当尽量保证两个对象hashcode值相等时，equals方法比较为true，否则这样的对象在作为key元素在HashMap中使用时会产生链表，降低HashMap查询性能。
3 稳定性。即:当参与equals比较的属性没有发生变化的前提下，多次调用hashcode方法返回的数字必须相同。
> 

重写了equals方法（hashCode方法也同时被重写）的类：
String、Math、包装类、java API提供的类基本都重写了。

hashCode方法的主要作用是为了配合基于散列的集合一起正常运行，这样的散列集合包括HashSet、HashMap以及HashTable。

## 重写了equals却没有重写hashcode，会有什么问题？

要用到hashcode作为比较的条件的时候才会有问题，比方说对象作为map的Key等。

因为**hashCode() 在散列表（Java集合中本质是散列表的类，如HashMap，Hashtable，HashSet）中才有用，在其它情况下没用。所以，非散列表环境下没什么问题。**
在散列表中hashCode() 的作用是获取对象的散列码，进而确定该对象在散列表中的位置。

- Hash表存储元素的过程
    
    首先根据被存储的元素来计算出HashCode值，然后根据计算出的HashCode值和数组的长度进行计算出存储的下标；如果该下标位置没有元素，则直接存储。如果有元素，直接用equals方法将被存入的元素和已有的元素进行对比，若结果为真则放弃储存。如果为假，则以链表的形式进行存储。
    

可能导致：

1) HashSet中有重复元素；

2)**相同内容的一个对象，在取出时为null，或者 contain（）得到错误结果；**

虽然两个对象内容相同，但是由于没有重写HashCode方法，导致默认调用Object类的HashCode方法，返回了对象的地址，而两个对象虽然内容是相同，但是地址不同，那么新的对象就去一个不存在bucket里寻找，自然是返回null。

3)更进一步的后果就是这部分无法触达的对象无法回收，导致**内存泄漏**。


# 深拷贝浅拷贝
|  | 基本类型 | 不可变引用类型（final修饰的） | 普通引用类型 |
| --- | --- | --- | --- |
| 浅拷贝（clone方法） | 属性值拷贝 | 新的内存空间，新的引用(复制值理解) | 引用拷贝（一处修改，多处改变） |
| 深拷贝 | 属性值拷贝 | 新的内存空间，新的引用(复制值理解) | 新的内存空间，新的引用(复制值理解) |
[https://segmentfault.com/a/1190000039079070](https://segmentfault.com/a/1190000039079070)

# 如何实现深度clone

1、需要自己定义一个方法，把对象的属性逐条复制，这才是深复制。
把被拷贝对象中的所有引用类型也都实现深拷贝，最后逐层拷贝实现引用地址是新的而不是用的同一个。

2、利用serializable实现深拷贝，这种方式的原理在于通过IO流的方式先将序列化后的对象写进IO流中，再取出来实现深拷贝。这种方式下所有涉及到的类都必须实现Serializable接口

# java中**只存在值传递，只存在值传递！！！**

然而我们经常看到对于对象（数组，类，接口）的传递似乎有点像引用传递，可以改变对象中某个属性的值。

但是不要被这个假象所蒙蔽，**实际上这个传入函数的值是对象引用的拷贝，即传递的是引用的地址值，所以还是按值传递。**

# Java序列化的方式
将数据对象转换为二进制流的过程称为对象的序列化（Serialization）。反之，将二进制流恢复为数据对象的过程称为反序列化（Deserialization）。  
为了节约存储空间和网络带宽，序列化后的二进制流又要尽可能小。  
序列化常见的使用场景是RPC框架的数据传输。  
常见的序列化方式有三种：  
## Java原生序列化
通过实现Serializable接口来实现该类对象的序列化，这个接口非常特殊，没有任何方法，只起标识作用.Java序列化保留了对象类的元数据（如类、成员变量、继承类信息等），以及对象数据等，兼容性最好，但不支持跨语言，而且性能一般。
## Hessian 序列化
## Json序列化
JSON 序列化就是将数据对象转换为 JSON 字符串。在序列化过程中抛弃了类型信息，所以反序列化时只有提供类型信息才能准确地反序列化。相比前两种方式，可读性比较好，方便调试。
## 其他
ProtoBuff，适合做数据存储或 RPC 数据交换格式。

## 安全
序列化通常会通过网络传输对象 ， 而对象中往往有敏感数据，所以序列化常常成为黑客的攻击点，攻击者巧妙地利用反序列化过程构造恶意代码，使得程序在反序列化的过程中执行任意代码。 Java 工程中广泛使用的 Apache Commons Collections 、Jackson 、 fastjson 等都出现过反序列化漏洞。如何防范这种黑客攻击呢？有些对象的
敏感属性不需要进行序列化传输 ，可以加 transient 关键字，避免把此属性信息转化为序列化的二进制流。如果一定要传递对象的敏感属性，可以使用对称与非对称加密方式独立传输，再使用某个方法把属性还原到对象中。应用开发者对序列化要有一定的安全防范意识 ， 对传入数据的内容进行校验或权限控制，及时更新安全漏洞，避免受到攻击。

