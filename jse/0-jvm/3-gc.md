https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/gc01/index.html
![](https://segmentfault.com/img/remote/1460000039044660/view)
# 什么时候进行垃圾回收
虚拟机判定内存不够时会中断代码的运行，此时gc才进行垃圾回收。  
`System.gc();`只是起一个通知的作用，通知垃圾回收器进行回收。  
垃圾回收回收的是无任何引用的对象占据的内存空间而不是对象本身!  
缺点：不能精确的回收内存。

[通过一个案例认知JVM 的内存管理/回收和进程上内存的关系](https://segmentfault.com/a/1190000040050819?utm_source=sf-homepage)

https://www.cnblogs.com/insist-bin/p/11147460.html

https://blog.csdn.net/xingxing43/article/details/8513252

https://blog.csdn.net/gong_xucheng/article/details/12838201

https://www.cnblogs.com/jianyungsun/p/6911380.html

# 垃圾回收在哪进行
Java的内存分配原理与C/C++不同，C/C++每次申请内存时都要malloc进行系统调用，而系统调用发生在内核空间，每次都要中断进行切换，这需要一定的开销，而Java虚拟机是先一次性分配一块较大的空间，然后每次new时都在该空间上进行分配和释放，减少了系统调用的次数，节省了一定的开销，这有点类似于内存池的概念；二是有了这块空间过后，如何进行分配和回收就跟GC机制有关了。

**Java堆和方法区**是线程共享，是GC的所关注的部分。

java提供了系统级线程跟踪储存空间的分配情况，在jvm空闲时，检查并释放那些可释放的储存空间。

>java一般内存申请有两种：静态内存和动态内存。  
编译时就能够确定的内存就是静态内存，即内存是固定的，系统一次性分配，比如int类型变量；    
动态内存分配就是在程序执行时才知道要分配的存储空间大小，比如java对象的内存空间。  
>根据上面我们知道，java栈、程序计数器、本地方法栈都是线程私有的，线程生就生，线程灭就灭，栈中的栈帧随着方法的结束也会撤销，内存自然就跟着回收了。所以这几个区域的内存分配与回收是确定的，我们不需要管的。但是java堆和方法区则不一样，我们只有在程序运行期间才知道会创建哪些对象，所以这部分内存的分配和回收都是动态的。一般我们所说的垃圾回收也是针对的这一部分。



# 什么样的对象会被回收？
垃圾，不再被引用的对象。
## 判定对象是否存活(不再被使用)。
- 引用计数算法  
给对象中添加一个引用计数器，每当一个地方应用了对象，计数器加1；当引用失效，计数器减1；当计数器为0表示该对象已死、可回收。
但是它很难解决两个对象之间相互循环引用的情况。  

- 可达性分析算法  
通过一系列称为`GC Roots`的对象作为起点，从这些节点开始向下搜索，搜索所走过的路径称为`引用链`，当一个对象到GC Roots没有任何引用链相连（即对象到GC Roots不可达），则证明此对象已死、可回收。

在主流的商用程序语言（如我们的Java）的主流实现中，都是通过可达性分析算法来判定对象是否存活的。 
### Java中可以作为GC Roots的对象
- 虚拟机栈（栈帧中的局部变量区，也叫做局部变量表）中引用的对象。
- 方法区中的类静态属性引用的对象。
- 方法区中常量引用的对象。
- 本地方法栈中JNI(Native方法)引用的对象。

### 要宣判一个对象死亡，至少需要经历两次标记阶段
对于可达性分析算法而言，未到达的对象并非是“非死不可”的，若要宣判一个对象死亡，至少需要经历两次标记阶段。  
1. 如果对象在进行可达性分析后发现没有与 GCRoots 相连的引用链，则该对象被第一次标记并进行一次筛选，筛选条件为是否有必要执行该对象的 finalize 方法，若对象没有覆盖 finalize 方法或者该 finalize 方法是否已经被虚拟机执行过了，则均视作不必要执行该对象的finalize方法，即该对象将会被回收。反之，若对象覆盖了finalize方法并且该finalize方法并没有被执行过，那么，这个对象会被放置在一个叫F-Queue的队列中，之后会由虚拟机自动建立的、优先级低的Finalizer线程去执行，而虚拟机不必要等待该线程执行结束，即虚拟机只负责建立线程，其他的事情交给此线程去处理。
2. 对F-Queue中对象进行第二次标记，如果对象在finalize方法中拯救了自己，即关联上了GCRoots引用链，如把this关键字赋值给其他变量，那么在第二次标记的时候该对象将从“即将回收”的集合中移除，如果对象还是没有拯救自己，那就会被回收。一个对象可以在finalize方法中拯救了自己，然而，它只能拯救自己一次，第二次就被回收了。


# 对象的引用被划分为4种级别
从而使程序能更加灵活地控制对象的生命周期。这4种级别由高到低依次为：强引用、软引用、弱引用和虚引用。
对象的生命周期：
https://blog.csdn.net/sodino/article/details/38387049
![](https://www.showdoc.com.cn/server/api/attachment/visitfile/sign/ed20cc8bdec40fc7203270a5d4f82985)
##  强引用：
使用最普遍的引用。
` Object strongReference = new Object();`
如果一个对象具有强引用，那垃圾回收器绝不会回收它。
当内存空间不足时，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足的问题。 
如果强引用对象不使用时，需要弱化从而使GC能够回收，`strongReference = null;`
显式地设置strongReference对象为null，或让其超出对象的生命周期范围，则gc认为该对象不存在引用，这时就可以回收这个对象。具体什么时候收集这要取决于GC算法。

在一个方法的内部有一个强引用，这个引用保存在Java栈中，而真正的引用内容(Object)保存在Java堆中。 当这个方法运行完成后，就会退出方法栈，则引用对象的引用数为0，这个对象会被回收。

ps：如果这个strongReference是全局变量时，就需要在不用这个对象时赋值为null，因为强引用不会被垃圾回收。

```
ArrayList的Clear方法：
在ArrayList类中定义了一个elementData数组，在调用clear方法清空数组时，每个数组元素被赋值为null。
不同于elementData=null，强引用仍然存在，避免在后续调用 add() 等方法添加元素时进行内存的重新分配。
使用如clear()方法内存数组中存放的引用类型进行内存释放特别适用，这样就可以及时释放内存。
```

## 软引用
有用但并非必需的对象。
如果一个对象只具有软引用，则内存空间充足时，垃圾回收器就不会回收它；
如果内存空间不足了，就会回收这些对象的内存。
只要垃圾回收器没有回收它，该对象就可以被程序使用。
```
    // 强引用
    String strongReference = new String("abc");
    // 软引用
    String str = new String("abc");
    SoftReference<String> softReference = new SoftReference<String>(str);
```

垃圾收集线程会在虚拟机抛出OutOfMemoryError之前回收软引用对象，而且虚拟机会尽可能优先回收长时间闲置不用的软引用对象。

对那些刚构建的或刚使用过的**"较新的"软对象会被虚拟机尽可能保留**，这就是引入引用队列ReferenceQueue的原因。
软引用可以和一个引用队列(ReferenceQueue)联合使用。如果软引用所引用对象被垃圾回收，JAVA虚拟机就会把这个软引用加入到与之关联的引用队列中。
```
    ReferenceQueue<String> referenceQueue = new ReferenceQueue<>();
    String str = new String("abc");
    SoftReference<String> softReference = new SoftReference<>(str, referenceQueue);

    str = null;
    // Notify GC
    System.gc();

    System.out.println(softReference.get()); // abc

    Reference<? extends String> reference = referenceQueue.poll();
    System.out.println(reference); //null
```


应用场景举例：
可用来实现内存敏感的高速缓存。
将浏览完毕的页面置为软引用，回退或者再次浏览此页面时，如果内存充足，还没有被回收器回收，直接获取缓存，如果内存不足，软引用的对象已经回收则重新构建软引用。

## 弱引用
非必需对象。
一旦垃圾回收线程发现了弱引用对象，无论当前内存是否足够，在下一次GC过程中就会对其进行回收。
不过，由于垃圾回收器是一个优先级很低的线程，因此不一定会很快发现那些只具有弱引用的对象。
```
 String str = new String("abc");
    WeakReference<String> weakReference = new WeakReference<>(str);
    // 弱引用转强引用
    String strongReference = weakReference.get();
```
弱引用还可以用来实现缓存。例如用弱哈希表，即通过弱引用来缓存各种引用对象的哈希表。
当垃圾回收器运行时，假如应用程序的内存占用量高到一定程度，那些不再被其它对象所引用的缓存对象就会被自动释放。

如果一个对象是偶尔(很少)的使用，并且希望在使用时随时就能获取到，但又不想影响此对象的垃圾收集，那么你应该用Weak Reference来记住此对象。

### 虚引用
虚引用顾名思义，就是形同虚设，等于没有引用，无法通过虚引用访问其对应的对象。
如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。

应用场景：
虚引用主要用来跟踪对象被垃圾回收器回收的活动。

虚引用必须和引用队列(ReferenceQueue)联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回**收对象的内存之前，把这个虚引用加入到与之关联的引用队列中**。
程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要进行垃圾回收。
如果程序发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前进行一些操作。
```
//创建引用队列
ReferenceQueue<String> queue = new ReferenceQueue<String>();
//创建虚引用，并绑定引用队列
PhantomReference<String> str = new PhantomReference<String>("啦啦啦",queue);
```

ps:软引用、弱引用都是所引用的对象被垃圾回收后，Java虚拟机就会把这个软引用或弱引用加入到与之关联的引用队列中去。




# 垃圾收集
标记清除算法、复制算法、标记整理算法、分代搜集算法，目前主流虚拟机中使用的就是分代搜集算法。  
GC中用于回收的方法称为收集器，由于GC需要消耗一些资源和时间，Java在对对象的生命周期特征进行分析后，按照新生代、旧生代的方式来对对象进行收集，以尽可能的缩短GC对应用造成的暂停。    

## 标记-清除算法 Mark-sweep
先**标记处所需要回收的对象，在标记完成后统一回收所有被标记的对象**。

不足：标记和清除过程都效率不高；另外是空间问题，**标记清除之后会产生大量不连续的内存碎片**（类似于我们电脑的磁盘碎片），空间碎片太多导致需要分配大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾回收动作。


## 复制算法 Copying
为了解决效率问题，出现了“复制”算法，他**将可用内存按容量划分为大小相等的两块，每次只需要使用其中一块。当一块内存用完了，将还存活的对象复制到另一块上面，然后再把刚刚用完的内存空间一次清理掉。**这样就解决了内存碎片问题，但是代价就是可以用内容就缩小为原来的一半。

不足：复制算法在对象**存活率较高时就会进行频繁的复制操作**，效率将降低。

## 标记-整理算法 Mark-Compac
标记过程同标记-清除算法，但是在后续步骤**不是直接对对象进行清理，而是让所有存活的对象都向一侧移动，然后直接清理掉端边界以外的内存**。

## 分代收集算法
当前商业虚拟机的GC都是采用分代收集算法，是基于这样一个事实：不同的对象的生命周期是不一样的。因此，不同生命周期的对象可以采取不同的收集方式，以便提高回收效率。
>在java程序运行的过程中，会产生大量的对象，因每个对象所能承担的职责不同所具有的功能不同所以也有着不一样的生命周期，有的对象生命周期较长，比如Http请求中的Session对象，线程，Socket连接等；有的对象生命周期较短，比如String对象，由于其不变类的特性，有的在使用一次后即可回收。试想，在不进行对象存活时间区分的情况下，每次垃圾回收都是对整个堆空间进行回收，那么消耗的时间相对会很长，而且对于存活时间较长的对象进行的扫描工作等都是徒劳。因此就需要引入分治的思想，所谓分治的思想就是因地制宜，将对象进行代的划分，把不同生命周期的对象放在不同的代上使用不同的垃圾回收方式。

根据对象存活周期的不同将堆分为：**新生代和老年代**，方法区称为永久代（在新的版本中已经将永久代废弃，引入了**元空间**的概念，永久代使用的是JVM内存而元空间直接使用物理内存）。

>这里有个比喻很形象
“假设你是一个普通的 Java 对象，你出生在 Eden 区，在 Eden 区有许多和你差不多的小兄弟、小姐妹，可以把 Eden 区当成幼儿园，在这个幼儿园里大家玩了很长时间。Eden 区不能无休止地放你们在里面，所以当年纪稍大，你就要被送到学校去上学，这里假设从小学到高中都称为 Survivor 区。开始的时候你在 Survivor 区里面划分出来的的“From”区，读到高年级了，就进了 Survivor 区的“To”区，中间由于学习成绩不稳定，还经常来回折腾。直到你 18 岁的时候，高中毕业了，该去社会上闯闯了。于是你就去了年老代，年老代里面人也很多。在年老代里，你生活了 20 年 (每次 GC 加一岁)，最后寿终正寝，被 GC 回收。有一点没有提，你在年老代遇到了一个同学，他的名字叫爱德华 (慕光之城里的帅哥吸血鬼)，他以及他的家族永远不会死，那么他们就生活在永生代。”

这样就可以`根据各个年代的特点采用不同的收集算法`，分为 Minor GC 和 Major GC。

### 新生代 Young Generation 的Minor GC
新生代中的**对象存活时间都很短**，98% 都是朝生夕死，每次GC时都会有大量对象死去，少量存活，使用**复制**算法。  
新产生的对象优先进去**Eden区**，当Eden区满了之后再使用**Survivor from**，当Survivor from 也满了之后就进行**Minor GC**，清理之后将Eden和Survivor from中存活的对象copy进入**Survivor to**（如果空间不够，再往老年代放），然后清空Eden和Survivor from，这个时候原来的Survivor from成了新的Survivor to，原来的Survivor to成了新的Survivor from。  
Eden 区与 2个Survivor 区大小比例是 **8:1:1**，也就是每次新生代可用内存为 90%。

复制的时候，如果Survivor to无法容纳全部存活的对象（不能保证每次新生代回收只有不多于 10% 的对象存活），则根据老年代的分配担保（类似于银行的贷款担保）将对象copy进去`老年代`，如果老年代也无法容纳，则进行Full GC（老年代GC）。

### 老年代 Tenured Generaion 的Major GC
老年代中的**对象因为对象存活率高**、没有额外空间进行分配担保，就使用`标记-清除`或`标记-整理`算法。
![](https://img-blog.csdn.net/20150315170424355?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdG9ueXRmamluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

大对象直接进入老年代：JVM中有个参数配置`-XX:PretenureSizeThreshold`，令大于这个设置值的对象直接进入老年代，目的是为了避免在Eden和Survivor区之间发生大量的内存复制。
长期存活的对象进入老年代：JVM给每个对象定义一个对象年龄计数器，如果对象在Eden出生并经过第一次Minor GC后仍然存活，并且能被Survivor容纳，将被移入Survivor并且年龄设定为1。每熬过一次Minor GC，年龄就加1，当他的年龄到一定程度（默认为15岁，可以通过`XX:MaxTenuringThreshold`来设定），就会移入老年代。
但是JVM并不是永远要求年龄必须达到最大年龄才会晋升老年代，如果Survivor 空间中相同年龄（如年龄为x）所有对象大小的总和大于Survivor的一半，年龄大于等于x的所有对象直接进入老年代，无需等到最大年龄要求。

对于老年代，用标记整理算法或者标记清除算法，因为老年代对象数量庞杂，且大多数不满足清理条件，所以老年代的垃圾回收耗时长效果相对较差。；同样老年代空间不足，触发Full GC(亦称之为Major GC)，耗时长，要尽量避免，`一般来说Full GC次数一天不能超过一次`。
Major GC的速度一般会比Minor GC慢10倍以上。

### Full GC是对整个堆来说的
System.gc()此方法的调用是建议JVM进行Full GC,虽然只是建议而非一定,但很多情况下它会触发 Full GC,从而增加Full GC的频率,也即增加了间歇性停顿的次数。强烈影响系建议能不使用此方法就别使用，让虚拟机自己去管理它的内存，可通过通过-XX:+ DisableExplicitGC来禁止RMI调用System.gc。
https://blog.csdn.net/scugxl/article/details/50935863
https://blog.csdn.net/chenleixing/article/details/46706039/

## 垃圾收集器
垃圾收集算法是 内存回收的理论基础，而垃圾收集器就是内存回收的具体实现。
针对新生代跟老年代都有不同的垃圾搜集器，不同的搜集器之间只能有特定的几个组合(不能随意地组合使用，会有不兼容)，具体看项目实际情况而定。 

如用ParNew与CMS的组合，虽然CMS用的是标记清除算法，会使垃圾收集后的内存碎片较多，但是万能的前辈们早就想到了这些，提供了-XX:+UseCMSCompactAtFullCollection指令压缩内存中的碎片，以及-XX:CMSFullGCsBeforeCompaction指令设置多少次Full GC后整理内存碎片。
![](https://images2015.cnblogs.com/blog/37237/201510/37237-20151009212341456-1742347600.png)

### HotSpot JVM收集器
![](https://images2015.cnblogs.com/blog/249993/201703/249993-20170308202431391-1323581863.png)
如果两个收集器之间存在连线，那说明它们可以搭配使用。

#### 新生代Serial收集器
对**新生代采用复制算法的单线程**的收集器。  
是虚拟机运行在Client模式下的默认新生代收集器，因为它简单而高效。

用户桌面应用场景中，分配给虚拟机管理的内存一般来说不会很大，收集几十兆甚至一两百兆的新生代停顿时间在几十毫秒最多一百毫秒，只要不是频繁发生，这点停顿是完全可以接受的。

![](https://images2015.cnblogs.com/blog/249993/201703/249993-20170308204330750-898195038.png)
1. 需要STW（Stop The World），停顿时间长。
2. 简单高效，对于单个CPU环境而言，Serial收集器由于没有线程交互开销，可以获取最高的单线程收集效率。

#### 新生代ParNew收集器
对**新生代采用复制算法的并行多线程**的收集器。是Server模式下的虚拟机首选的新生代收集器。  
ParNew收集器在单CPU的环境中绝对不会有比Serial收集器更好的效果，甚至由于线程交互的开销，该收集器在两个CPU的环境中都不能百分之百保证可以超越Serial收集器。
当然，随着可用CPU数量的增加，它对于GC时系统资源的有效利用还是很有好处的。
它默认开启的收集线程数与CPU数量相同，在CPU数量非常多的情况下，可以使用-XX:ParallelGCThreads参数来限制垃圾收集的线程数。
![](https://images2015.cnblogs.com/blog/249993/201703/249993-20170308210151797-1882924644.png)

#### 新生代Parallel Scavenge收集器
>吞吐量的意思就是CPU用于运行用户代码时间与CPU总消耗时间的比值，即吞吐量=运行用户代码时间/（运行用户代码时间+垃圾收集时间），
虚拟机总运行100分钟，垃圾收集1分钟，那吞吐量就是99%。

Parallel Scavenge收集器是虚拟机运行在 jdk8 Server模式下的默认垃圾收集器。

**新生代采用复制算法的吞吐量优先收集器**。（CMS等收集器的关注点是尽可能缩短垃圾收集时用户线程的停顿时间）
停顿时间短适合需要与用户交互的程序，良好的响应速度能提升用户体验；高吞吐量则可以高效率利用CPU时间，尽快完成运算任务，主要适合在后台运算而不需要太多交互的任务。
虚拟机提供了-XX:MaxGCPauseMillis和-XX:GCTimeRatio两个参数来精确控制最大垃圾收集停顿时间和吞吐量大小。不过不要以为前者越小越好，GC停顿时间的缩短是以牺牲吞吐量和新生代空间换取的。由于与吞吐量关系密切，Parallel Scavenge收集器也被称为“吞吐量优先收集器”。

Parallel Scavenge收集器有一个-XX:+UseAdaptiveSizePolicy参数，这是一个开关参数，这个参数打开之后，就不需要手动指定新生代大小、Eden区和Survivor参数等细节参数了，虚拟机会根据当前系统的运行情况手机性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量。如果对于垃圾收集器运作原理不太了解，以至于在优化比较困难的时候，使用Parallel Scavenge收集器配合自适应调节策略，把内存管理的调优任务交给虚拟机去完成将是一个不错的选择。

>Java8默认的新生代垃圾回收器是：UseParallelGC，可以用-XX:+PrintCommandLineFlags -version查看，还有如果显示指定 -XX:+UseCurrentMarkSweepGC 的话，会默认开启 -XX:+UseParallelGC

#### Serial Old收集器
**老年代，标记整理算法的单线程收集器**，Serial收集器的老年代版本。这个收集器的主要意义也是在于给Client模式下的虚拟机使用。

#### Parallel Old收集器/吞吐量收集器
**老年代，标记整理算法的并行多线程收集器**，Parallel Scavenge收集器的老年代版本。  
开启方法是指定`-XX:+UseParallelGC`。  
“吞吐量优先收集器”终于有了比较名副其实的应用组合，在**注重吞吐量以及CPU资源敏感**的场合，都可以优先考虑Parallel Scavenge收集器+Parallel Old收集器的组合。
![](https://images2015.cnblogs.com/blog/249993/201703/249993-20170309210552797-797186750.png)   

>Java8默认的新生代垃圾回收器是：UseParallelGC，可以用-XX:+PrintCommandLineFlags -version查看，
>还有如果显示指定 -XX:+UseCurrentMarkSweepGC 的话，会默认开启 -XX:+UseParallelGC ？？
 
#### CMS(并发GC)收集器 Concurrent Mark Sweep     !!!!
**老年代，标记清除算法的并行与并发收集器**。
>并行:垃圾收集的多线程的同时进行。
 并发:垃圾收集的多线程和应用的多线程同时进行。

以获取**最短回收停顿时间**为目标的收集器。CPU 资源非常充裕，建议使用 CMS 收集器。
 启用方法是指定`-XX:+UseCurrentMarkSweepGC`。      
 使用标记 - 清除算法，收集过程分为如下四步：  
 (1). 初始标记，标记GCRoots能直接关联到的对象，时间很短。  
 (2). 并发标记，进行GCRoots Tracing（可达性分析）过程，时间很长。  
 (3). 重新标记，修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，时间较长。  
 (4). 并发清除，回收内存空间，时间很长。  
 并发标记与并发清除两个阶段耗时最长，但是可以与用户线程并发执行。
 ![](https://images2015.cnblogs.com/blog/249993/201703/249993-20170312201047482-791570909.png)
 
 1. 对CPU资源非常敏感，可能会导致应用程序变慢，吞吐率下降。  
 2. 无法处理浮动垃圾，因为在并发清理阶段用户线程还在运行，自然就会产生新的垃圾，而在此次收集中无法收集他们，只能留到下次收集，这部分垃圾为浮动垃圾，（在并发清除时，用户线程新产生的垃圾叫浮动垃圾），可能出现“Concurrent Mode Failure”失败；同时，由于用户线程并发执行，所以需要预留一部分老年代空间提供并发收集时程序运行使用。
 3. 由于采用的标记 - 清除算法，会产生大量的**内存碎片**，不利于大对象的分配，可能会提前触发一次Full GC。虚拟机提供了-XX:+UseCMSCompactAtFullCollection参数来进行碎片的合并整理过程，这样会使得停顿时间变长，虚拟机还提供了一个参数配置，-XX:+CMSFullGCsBeforeCompaction，用于设置执行多少次不压缩的Full GC后，接着来一次带压缩的GC。

>重视服务的响应速度、系统 停顿时间和用户体验的互 联网网站或者 B/S 系统。互 联网后端目前 cms 是主流 的垃圾回收器;

#### G1收集器
**跨新生代和老年代;标记 整理 + 化整为零**，不会产生内存碎片。    
G1(Garbage First)收集器是JDK8提供的一个新收集器，在**JDK9中默认使用**。  
面向服务端应用的垃圾回 收器，目标为取代 CMS。

有以下特点：  
 (1). 并行和并发。使用多个CPU来缩短Stop The World停顿时间，与用户线程并发执行。  
 (2). 分代收集。独立管理整个堆，但是能够采用不同的方式去处理新创建对象和已经存活了一段时间、熬过多次GC的旧对象，以获取更好的收集效果。  
 (3). 空间整合。基于标记 - 整理算法，无内存碎片产生。  
 (4). 可预测的停顿。能简历可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒。  
 使用G1收集器时，Java堆的内存布局与其他收集器有很大差别，它将整个Java堆划分为多个大小相等的独立区域（Region），虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一部分（可以不连续）Region的集合。
   
 分代收集，G1可以不需要其他GC收集器的配合就能独立管理整个堆，采用不同的方式处理新生对象和已经存活一段时间的对象；
 空间整合：采用标记整理算法，局部采用复制算法（Region之间），不会有内存碎片，不会因为大对象找不到足够的连续空间而提前触发GC；
 可预测的停顿：能够让使用者明确指定一个时间片段内，消耗在垃圾收集上的时间不超过时间范围内；
 
 G1收集器：面向服务端应用的垃圾收集器，过程：初始标记；并发标记；最终标记；筛选回收。
 整体上看是“标记-整理”，局部看是“复制”，不会产生内存碎片。 
 吞吐量优先的并行收集器：以到达一定的吞吐量为目标，适用于科学技术和后台处理等。 
 响应时间优先的并发收集器：保证系统的响应时间，减少垃圾收集时的停顿时间。适用于应用服务器、电信领域等。
 
在没有任何调优的情况下，G1 表现得要比 CMS 出色，主要体现在**更少的 Full GC**，需要调整的参数更少等。


## gc优化设置
`-XX:+DisableExplicitGC`：在程序代码中不允许有显示的调用`System.gc()`。每次在到操作结束时手动调用 `System.gc()` 一下，付出的代价就是系统响应时间严重降低，就和关于 Xms，Xmx 里的解释的原理一样，这样去调用 GC 导致系统的 JVM 大起大落。

`-XX:MaxTenuringThreshold=0`：设置垃圾最大年龄(对象在新生代中存活的次数)。
如果设置为0的话，则年轻代对象不经过Survivor区，直接进入年老代。对于年老代比较多的应用（需要大量常驻内存的应用），可以提高效率。
如果将此值设置为一个较大值，则新生代对象会在Survivor区进行多次复制，这样可以增加对象在新生代的存活时间，增加在年轻代即被回收的概率，减少Full GC的频率，这样做可以在某种程度上提高服务稳定性。
该参数只有在串行 GC 时才有效，这个值的设置最好根据本地的 jprofiler 监控后得到的一个理想的值，不能一概而论原搬照抄。默认为：15。

### 垃圾回收器设置
 [参考这里比较详细](https://www.cnblogs.com/moonandstar08/p/4865190.html)
 [参考2](https://troywu0.gitbooks.io/spark/content/java%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6.html)
`-XX:+UseConcMarkSweepGC` ：设置**年老代启动并发标识-清理（Mark-Sweep）回收器（CMS）**，即 `CMS gc`。
这一特性只有 jdk1.5后续版本才具有的功能，它使用的是 gc 估算触发和 heap 占用触发。我们知道频频繁的 GC 会造面 JVM 的大起大落从而影响到系统的效率，因此使用了 CMS GC 后可以在 GC 次数增多的情况下，每次 GC 的响应时间却很短，比如说使用了 CMS GC 后经过 jprofiler 的观察，GC 被触发次数非常多，而每次 GC 耗时仅为几毫秒。 优点低延迟。

jdk8据说已经废除了 `-XX:+UseConcMarkSweepGC -XX:-UseParNewGC`的组合

`-XX:CMSInitiatingOccupancyFraction`：当堆满之后，CMS 收集器便开始进行垃圾收集，例如，当没有足够的空间来容纳新分配或提升的对象。对于 CMS 收集器，长时间等待是不可取的，因为在并发垃圾收集期间应用持续在运行（并且分配对象）。因此，为了在应用程序使用完内存之前完成垃圾收集周期，CMS 收集器要比并行收集器更先启动。因为不同的应用会有不同对象分配模式，JVM 会收集实际的对象分配（和释放）的运行时数据，并且分析这些数据，来决定什么时候启动一次 CMS 垃圾收集周期。这个参数设置有很大技巧，基本上满足(Xmx-Xmn)*(100-CMSInitiatingOccupancyFraction)/100 >= Xmn 就不会出现 promotion failed。例如在应用中 Xmx 是6000，Xmn 是 512，那么 Xmx-Xmn 是 5488M，也就是老年代有 5488M，CMSInitiatingOccupancyFraction=90 说明老年代到 90% 满的时候开始执行对老年代的并发垃圾回收（CMS），这时还 剩 10% 的空间是 5488*10% = 548M，所以即使 Xmn（也就是新生代共512M）里所有对象都搬到老年代里，548M 的空间也足够了，所以只要满足上面的公式，就不会出现垃圾回收时的 promotion failed，因此这个参数的设置必须与 Xmn 关联在一起。70

`-XX:+CMSIncrementalMode`：该标志将开启 CMS 收集器的增量模式。增量模式经常暂停 CMS 过程，以便对应用程序线程作出完全的让步。因此，收集器将花更长的时间完成整个收集周期。因此，只有通过测试后发现正常 CMS 周期对应用程序线程干扰太大时，才应该使用增量模式。由于现代服务器有足够的处理器来适应并发的垃圾收集，所以这种情况发生得很少，用于少CPU情况。

`-XX:ConcGCThreads`：早期 JVM 版本也叫-XX:ParallelCMSThreads，定义并发 CMS 过程运行时的线程数。比如 value=4 意味着 CMS 周期的所有阶段都以 4 个线程来执行。尽管更多的线程会加快并发 CMS 过程，但其也会带来额外的同步开销。因此，对于特定的应用程序，应该通过测试来判断增加 CMS 线程数是否真的能够带来性能的提升。如果还标志未设置，JVM 会根据并行收集器中的 -XX:ParallelGCThreads 参数的值来计算出默认的并行 CMS 线程数。默认为:( 并行GC线程数+3)/4。

`-XX:+UseCMSCompactAtFullCollection` ：在使用concurrent gc 的情况下, 防止 memoryfragmention, 对live object 进行整理, 使 memory 碎片减少。



`-XX:+UseSerialGC`：新生代、老年代使用Serial垃圾收集器，单线程串行收集器（client模式默认垃圾收集器）。
这种垃圾回收器只适合几十兆到一两百兆的堆空间进行垃圾回收（可以控制停顿时间再 100ms 左右），但是对于超过这个大小的内存回收速度很慢，所以对于现在来说这个垃圾回收器已经是一个鸡肋。

>单线程进行垃圾回收时，必须暂停所有的工作线程，直到它回收结束。这个暂停称之为`Stop The World`,但是这种 STW 带来了恶劣的用户体验,例如:应用每运行一个小时就需要暂停响应 5 分。这个也是早期 JVM 和 java 被 C/C++语言诟病性能差的一个重要原因。所以 JVM 开发团队一直努力消除或降低 STW
的时间。

`-XX:+UseParNewGC` ：设置新生代启动并行 gc（Serial收集器的多线程升级版），多线程并行回收，这样收得快【多CPU】。老年代是串行。
当使用 `-XX:+UseConcMarkSweepGC` 时，该选项会自动开启。因此，如果新生代的并行 GC 不想开启，可以通过指定`-XX：-UseParNewGC`来关掉。
`-XX:+CMSParallelRemarkEnabled` ：在使用UseParNewGC 的情况下, 尽量减少mark 的时间，降低标记停顿。

`-XX:+UseParallelGC`：使用Parallel垃圾收集器（JDK1.8默认收集器）PS GC，优点吞吐量高，而年老代仍使用串行收集。【多CPU】
`-XX:+UseParallelOldGC`：配置年老代垃圾收集方式为并行并行Compacting收集，JDK6.0 开始支持对年老代并行收集。
并行的线程数为`cpu core<=8 ? cpu core : 3+(cpu core*5)/8`或通过`-XX:ParallelGCThreads=x`来强制指定。


-XX:+UseG1GC：使用G1垃圾回收器（新一代，重点关注），优点低延迟

由内存管理和垃圾回收可知新生代和旧生代都有多种GC策略和组合搭配，选择这些策略对于我们这些开发人员是个难题，JVM提供两种较为简单的GC策略的设置方式
1). 吞吐量优先
VM以吞吐量为指标，自行选择相应的GC策略及控制新生代与旧生代的大小比例，来达到吞吐量指标。这个值可由-XX:GCTimeRatio=n来设置
垃圾回收时间占程序运行时间的百分比为1/(1+n)

2). 暂停时间优先
JVM以暂停时间为指标，自行选择相应的GC策略及控制新生代与旧生代的大小比例，尽量保证每次GC造成的应用停止时间都在指定的数值范围内完成。这个值可由-XX:MaxGCPauseRatio=n来设置

## 其它高深的
`-XX:+AggressiveOpts`：积极的、生猛的，也即可以将最新版的JDK优化后的新特性自动注入，每当 JDK 版本升级时，你的 JVM 都会使用最新加入的优化技术（如果有的话）。
`-XX:+UseBiasedLocking`：启用一个优化了的线程锁，对于高并发访问很重要 ，太多的请求忙不过来它自动优化，对于各自长短不一的请求，出现的阻塞、排队现象，他自己优化。我们知道在我们的appserver，每个http请求就是一个线程，有的请求短有的请求长，就会有请求排队的现象，甚至还会出现线程阻塞，这个优化了的线程锁使得你的appserver内对线程处理自动进行最优调配。

`-XX:LargePageSizeInBytes` ：指定 Java heap的分页页面大小。内存页的大小不可设置过大， 会影响 Perm 的大小。

`-XX:+UseFastAccessorMethods` ：get,set 方法转成本地代码，原始类型的快速优化。

`-XX:+UseCMSInitiatingOccupancyOnly` ：指示只有在 old generation 在使用了初始化的比例后concurrent collector 启动收集。

`-Djava.awt.headless=true`：这个参数一般我们都是放在最后使用的, 在web网页中可能会输出GIF/JPG等图片流，在linux/unix环境下经常会碰到一个exception导致你在winodws开发环境下图片显示的好好可是在linux/unix下却显示不出来，因此加上这个参数以免避这样的情况出现。

`-XX:-UseCompressedOops`禁用压缩指针。




更多信息，请参考以下文章：
JVM 垃圾回收调优总结
http://developer.51cto.com/art/201201/312639.htm

JVM调优总结：典型配置举例
http://developer.51cto.com/art/201201/311739.htm

JVM基础：JVM参数设置、分析 
http://developer.51cto.com/art/201201/312018.htm

JVM 堆内存相关的启动参数：年轻代、老年代和永久代的内存分配
http://www.2cto.com/kf/201409/334840.html

Java 虚拟机–新生代与老年代GC
http://my.oschina.net/sunnywu/blog/332870

JVM（Java虚拟机）优化大全和案例实战
http://blog.csdn.net/kthq/article/details/8618052

JVM内存区域划分Eden Space、Survivor Space、Tenured Gen，Perm Gen解释 
http://blog.chinaunix.net/xmlrpc.php?r=blog/article&uid=29632145&id=4616836  


工具：https://segmentfault.com/a/1190000039097867

-XX:+UnlockExperimentalVMOptions ：
        解锁实验参数，允许使用实验性参数，JVM中有些参数不能通过-XX直接复制需要先解锁，比如要使用某些参数的时候，可能不会生效，需要设置这个参数来解锁；
一般使用在一些低版本jdk想使用高级参数或者可能高版本有的参数情况；
容器环境下
 -XX:+UnlockExperimentalVMOptions -XX:+UseCGroupMemoryLimitForHeap
 如果你想要的是JVM进程在容器中安全稳定的运行，不被容器kiil，并且你的JDK版本小于10（大于等于JDK10的版本不需要设置，参考前面的测试）。
你需要额外设置JVM参数-XX:+UnlockExperimentalVMOptions -XX:+UseCGroupMemoryLimitForHeap，即可保证你的Java进程不会因为内存问题被容器Kill。
https://blog.csdn.net/M2l0ZgSsVc7r69eFdTj/article/details/87128319



![](https://img2018.cnblogs.com/blog/1282009/201904/1282009-20190410205941903-1979709926.jpg)

# 编码习惯上
尽早释放无用对象的引用。
大多数程序员在使用临时变量的时候，都是让引用变量在退出活动域(scope)后，自动设置为null，暗示垃圾收集器来收集该对象，还必须注意该引用的对象是否被监听，如果有，则要去掉监听器，然后再赋空值。

修改数据读取方式：
例如一个EntityBean有如下字段：id, name, age, address, description。如果程序中只用到了此Bean的id和name字段，那么从数据库中只用读此两字段，而不是读取整个bean以及关联的Bean。