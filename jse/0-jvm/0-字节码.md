Java之所以可以“一次编译，到处运行”，一是因为JVM针对各种操作系统、平台都进行了定制，二是因为无论在什么平台，都可以编译生成固定格式的字节码（.class文件）供JVM使用
在Java中一般是用javac命令编译源代码为字节码文件。

一个.java文件从编译到运行的示例如图所示:
![](https://p0.meituan.net/travelcube/110b593ecf53866e0dec8df3618b0443257977.png)

过程:Java 文件->编译器>字节码->JVM->机器码。

# JVM的编译优化
[JVM对final关键字的编译优化](https://www.cnblogs.com/hexinwei1/p/10025840.html)

[jit](https://blog.csdn.net/weixin_41605937/article/details/114982056)

# 字节码结构
[参考](https://m.imooc.com/wiki/jvm-classconstant?ishidefooter=true)

字节码文件由十六进制值组成，JVM以两个十六进制值为一组，即以字节为单位进行读取。
编译后生成xxd Test.class文件，打开后是一堆十六进制数。
```
xxd Test.class
00000000: cafe babe 0000 0034 0022 0700 0201 0019  .......4."......
00000010: 636f 6d2f 636d 6f77 6572 2f6a 6176 615f  com/cmower/java_
00000020: 6465 6d6f 2f54 6573 7407 0004 0100 106a  demo/Test......j
00000030: 6176 612f 6c61 6e67 2f4f 626a 6563 7401  ava/lang/Object.
00000040: 0006 3c69 6e69 743e 0100 0328 2956 0100  ..<init>...()V..
00000050: 0443 6f64 650a 0003 0009 0c00 0500 0601  .Code...........
00000060: 000f 4c69 6e65 4e75 6d62 6572 5461 626c  ..LineNumberTabl
```

JVM对于字节码是有规范要求的，那么看似杂乱的十六进制符合什么结构呢？
JVM规范要求每一个字节码文件都要由十部分按照固定的顺序组成，整体结构如图所示：
![](https://p0.meituan.net/travelcube/393097261d80d730f434561157e219c657820.png)
![](https://ask.qcloudimg.com/http-save/1692602/ejge2cmhht.png?imageView2/2/w/1620)

## 魔数与版本号
Class文件开头固定的4个字节————`0xCAFEBABE`  `cafe babe` 被称为“魔数”，是 JVM 识别 .class 文件的标志。(文件格式的定制者可以自由选择魔数值（只要没用过），比如说 .png 文件的魔数是 8950 4e47。)

接下去的2个字节代表次要版本号 `0x0000`

再下去的两个字节是主版本号，主版本号为 `0x0034`，(十进制是52，也就是JDK1.8，高版本的JDK能够运行以前版本的Class文件，但是不能运行以后版本的Class文件，通俗一点将就是向下兼容。)

## 常量池
常量池由一个计数池和具体的常量项来组成，在我们代码中常量池数量为0x0022(十进制是34)，关于常量池的计数池有一个比较特殊的地方就是他是从1开始计数的，也就是说如果我们计数池的值是34，实际上是只有33个常量项。
常量池中主要存放两大类常量：

### 字面量
主要指的是文本字符串、声明为final的常量值等
### 符号引用
主要包含三类常量：
类和接口的全限定名
字段的名称和描述符
方法的名称和描述符

Java代码在编译的时候不存在连接时，也就是Class文件中不会保存各个方法、字段的最终内存布局信息，这些字段、方法的符号引用如果在运行期不进行转换则得不到真正的内存入口地址，所以在虚拟机运行时，需要从常量池获得对应的符号引用，在类创建和运行时解析翻译到具体的内存地址中。

可以通过javap -verbose xxx.class列出文件字节码的内容

## 访问标志 access_flags
2个字节
用来表示一个Class文件的基本访问信息，包括Class是类还是接口，是否被定义为public类型，是否被定义为abstract类型。
![](https://ask.qcloudimg.com/http-save/1692602/ehs0n4jtus.png?imageView2/2/w/1620)
![](https://ask.qcloudimg.com/http-save/yehe-2513555/5rafcs3tns.jpeg?imageView2/2/w/1620)

## 索引、父类索引以及接口索引
https://zhuanlan.zhihu.com/p/373239472
https://cloud.tencent.com/developer/article/1432238?from=article.detail.1687808

# 为什么要骗你学字节码
如通过字节码，可以很直观地看到Volatile关键字如何在字节码上生效。另外，字节码增强技术在Spring AOP、各种ORM框架、热部署中的应用屡见不鲜，深入理解其原理对于我们来说大有裨益。

跨语言！  
由于JVM规范的存在，只要最终可以生成符合规范的字节码就可以在JVM上运行，因此这就给了各种运行在JVM上的语言（如Scala、Groovy、Kotlin）一种契机，可以扩展Java所没有的特性或者实现各种语法糖。理解字节码后再学习这些语言，可以“逆流而上”，从字节码视角看它的设计思路，学习起来也“易如反掌”。


```
参考：
https://tech.meituan.com/2019/09/05/java-bytecode-enhancement.html
https://www.javatt.com/p/46581
https://juejin.cn/post/6844903866694123528
https://www.cnblogs.com/webor2006/p/9457973.html
https://blog.csdn.net/xtayfjpk/article/details/41873141
https://blog.csdn.net/huangzhilin2015/article/details/113926823
```

# 字节码增强技术
对现有字节码进行修改或者动态生成全新字节码文件的技术
asm
Javassist

>实现动态代理的方案有下列几种：
jdk 动态代理    
cglib 动态代理、javassist 动态代理-->ASM 字节码  
javassist 字节码

其中 cglib 底层实现依赖于 ASM，javassist 自成一派。
由于 ASM 和 javassist 需要程序员直接操作字节码，导致使用门槛相对较高，但实际上他们的应用是非常广泛的，如 Hibernate 底层使用了 javassist（默认）和 cglib，Spring 使用了 cglib 和 jdk 动态代理。

[ASM框架是采用访问者模式设计出来的](https://mp.weixin.qq.com/s?__biz=MzIyNjAzODEyMg==&mid=2247484737&idx=1&sn=f9874d2e3c41dca0603945de40c1aa9e&source=41#wechat_redirect)


- 典型应用：  
Java标准库的RMI  
hessian  
webservice框架


# java对象内存结构
https://mp.weixin.qq.com/s?__biz=MzU4ODM1NjY5NQ==&mid=2247484079&idx=1&sn=d7f955f18d72aebd2526861596c71555&chksm=fddf4f97caa8c6814440abe60b7b89d2c441304b74b8b114b87812a27a1097589492474fce73&cur_album_id=1425209439484870657&scene=189#wechat_redirect

对象在内存中存储的布局可以分为三块区域：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）
![](https://static001.geekbang.org/infoq/1b/1b91a007db860f43a390d6aa50127edf.png)
## 对象头Header
### markWord（标记字段）
用于存储对象自身的运行时数据， 如哈希码（HashCode）、GC 分代年龄、锁状态标志、线程持有的锁、偏向线程 ID、偏向时间戳等等，这部分数据的长度在 32 位和 64 位的虚拟机（暂 不考虑开启压缩指针的场景）中分别为 32 个和 64 个 Bits。

