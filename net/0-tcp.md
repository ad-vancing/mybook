https://plantegg.github.io/categories/TCP/  

https://zhuanlan.zhihu.com/p/144273871

《计算机网络 谢希仁版》
# TCP
TCP是面向连接的运输层协议；所谓面向连接就是双方传输数据之前，必须先建立一条通道，例如三次握手就是建议通道的一个过程，而四次挥手则是结束销毁通道的一个其中过程。

每一条TCP连接只能有两个端点（即两个套接字），只能是点对点的；

TCP提供可靠的传输服务。传送的数据无差错、不丢失、不重复、按序到达；

TCP提供全双工通信。允许通信双方的应用进程在任何时候都可以发送数据，因为两端都设有发送缓存和接受缓存；

面向字节流。

## TCP 协议头部
```
struct tcphdr {
    unsigned short      sport;    // 源端口
    unsigned short      dport;    // 目标端口
    unsigned int        seq;      // 序列号
    unsigned int        ack_seq;  // 确认号
    unsigned char       len;      // 首部长度
    unsigned char       flag;     // 标志位
    unsigned short      win;      // 窗口大小
    unsigned short      checksum; // 校验和
    unsigned short      urg;      // 紧急指针
};
```

标志位中的 SYN 字段必须设置为 1，表示这是一个 SYN包，由于 SYN位 位于 flag 字段的第二位，比如将 flag 字段设置为 0x02。

校验和计算三部分：TCP伪首部 + TCP头部 + TCP数据。

## 应用场景
效率要求相对低，但对准确性要求相对高的场景。因为传输中需要对数据确认、重发、排序等操作，相比之下效率没有UDP高。举几个例子：文件传输（准确高要求高、但是速度可以相对慢）、接受邮件、远程登录。

HTTP、HTTPS、FTP、TELNET、SMTP(简单邮件传输协议)协议基于可靠的TCP协议。

## 可靠性原理
- 传输信道无差错,保证传输数据正确;
- 不管发送方以多快的速度发送数据,接收方总是来得及处理收到的数据;
1. 首先，采用三次握手来建立TCP连接，四次挥手来释放TCP连接，从而保证建立的传输信道是可靠的。
2. 其次，TCP采用了 **连续ARQ协议**（回退N，Go-back-N；超时自动重传）来保证数据传输的正确性，使用滑动窗口协议来保证接方能够及时处理所接收到的数据，进行流量控制。
3. TCP使用慢开始、拥塞避免、快重传和快恢复来进行拥塞控制，避免网络拥塞。

### 连续 ARQ 协议
发送方维持一个发送窗口，凡位于发送窗口内的分组可以连续发送出去，而不需要等待对方确认。  
接收方一般采用累计确认，对按序到达的最后一个分组发送确认，表明到这个分组为止的所有分组都已经正确收到了。  
提高信道利用率。

### 停止等待协议
每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组；    
若接收方收到重复分组，就丢弃该分组，但同时还要发送确认。主要包括以下几种情况：无差错情况、出现差错情况（超时重传）、确认丢失和确认迟到。

停止等待协议中超时重传是指只要超过一段时间仍然没有收到确认，就重传前面发送过的分组（认为刚才发送过的分组丢失了）。因此每发送完一个分组需要设置一个超时计时器，其重传时间应比数据在分组传输的平均往返时间更长一些。这种自动重传方式常称为自动重传请求 ARQ。

## TCP 如何保证有效传输
- 有状态是指 TCP 会确认发送了哪些报文，接收方受到了哪些报文，哪些没有收到，保证数据包按序到达，不允许有差错
- 可控制的是指，如果出现丢包或者网络状况不佳，则会跳转自己的行为，减少发送的速度或者重发

## TCP 如何保证可靠传输
- 数据包校验
- 对失序数据包重排序
- 丢弃重复数据
- 应答机制：当 TCP 收到发自 TCP 连接另一端的数据，它将发送一个确认。这个确认不是立即发送，通常将推迟几分之一秒。推迟发送ACK的作用应该是：①合并多个ACK，②为了将反馈数据时带上ACK。
- 超时重发
- 流量控制

# UDP
- 无连接的传输层协议；
- 使用尽最大努力交付，不保证可靠交付；
- 面向报文的，对应用层交下来的报文，不合并，不拆分，保留原报文的边界；
- 没有拥塞控制，因此即使网络出现拥塞也不会降低发送速率；
- 支持一对一　一对多　多对多的交互通信；
- 首部开销小，只有８字节．

## 应用场景
UDP有一个重要的应用场景就是音频和视频的传输。  
效率要求相对高，对准确性要求相对低的场景。举几个例子：QQ聊天、在线视频、网络语音电话（即时通讯，速度要求高，但是出现偶尔断续不是太大问题，并且此处完全不可以使用重发机制）、广播通信（广播、多播）

DNS、DHCP、TFTP、SNMP(简单网络管理协议)、RIP基于不可靠的UDP协议

# UDP和TCP的区别
- TCP是可靠传输,UDP是不可靠传输;
- TCP协议是有连接的， 而UDP是无连接的。  
- TCP协议**保证数据按序**发送，按序到达，提供超时重传来保证可靠性，但是UDP不保证按序到达，甚至不保证到达，只是努力交付，即便是按序发送的序列，也不保证按序送到。
- TCP不保存数据边界,UDP保留数据边界;
- TCP传输速度相对UDP较慢;  
- TCP协议是重量级协议，所需资源多，TCP首部需20个字节（不算可选项），UDP首部字段只需8个字节。  
- TCP有流量控制和拥塞控制，UDP没有，网络拥堵不会影响发送端的发送速率  
- TCP是一对一的连接，而UDP则可以支持一对一，多对多，一对多的通信。  
- TCP面向的是字节流的服务，UDP面向的是报文的服务。


TCP协议是面向连接的，每个数据包的传输过程是：先建立链路、数据传输、然后清除链路。数据包不包含目的地址。受端和发端不但顺序一致，而且内容相同。它的可靠性高。

UDP协议是面向无连接的，每个数据包都有完整的源、目的地址及分组编号，各自在网络中独立传输，传输中不管其顺序，数据到达收端后再进行排序组装，遇有丢失、差错和失序等情况，通过请求重发来解决。它的效率比较高。


# TCP连接的过程
https://cloud.tencent.com/developer/article/1198221 

## 三次握手 
刚开始客户端处于 **closed** 的状态，服务端处于 **listen** 状态。  
1. 客户端发送的TCP报文中标志位SYN置1，初始序号seq=x（随机选择）。Client进入**SYN_SENT**状态，等待Server确认。  
2. 服务器收到数据包后，根据标志位SYN=1知道Client请求建立连接，Server将标志位SYN和标志位ACK都置为1，确认号ack=x+1，随机产生一个初始序号seq=y，并将该数据包发送给Client以确认连接请求，Server进入**SYN_RCVD**状态。  
3. Client收到确认后，检查确认号ack是否为x+1，标志位ACK是否为1，如果正确则将标志位ACK置为1，ack=y+1，并将该数据包发送给Server。Server检查ack是否为y+1，ACK是否为1，如果正确则连接建立成功，Client和Server进入**ESTABLISHED**状态，完成三次握手，随后Client与Server之间可以开始传输数据了。

![](https://ask.qcloudimg.com/http-save/yehe-1446775/uwl5mh9ogf.png?imageView2/2/w/1620)

### 初始化序列号 （ISN）是固定的吗

三次握手的一个重要功能是客户端和服务端交换ISN(Initial Sequence Number), 以便让对方知道接下来接收数据的时候如何按序列号组装数据。

如果ISN是固定的，攻击者很容易猜出后续的确认号，因此 ISN 是动态生成的。

### 三次握手过程中可以携带数据吗
第一次、第二次握手不可以携带数据，而第三次握手是可以携带数据的。  
第三次的话，此时客户端已经处于 established 状态，也就是说，对于客户端来说，他已经建立起连接了，并且也已经知道服务器的接收、发送能力是正常的了，所以能携带数据页没啥毛病。  

第一次握手可以放数据的话，其中一个简单的原因就是会让服务器更加容易受到攻击了。

### 为什么要三次握手建立连接
- 为什么不用2次？
- 为什么不用4次？

TCP连接是可靠的双工通信，在连接建立阶段必须确认双向通信都是OK的。理论上来讲这需要至少四次交互：  
```  
1. Client发送SYN  
2. Server响应ACK  
3. Server发送SYN  
4. Client响应ACK(如果没有这一步，Server无法知道Client能否收到自己的消息）
```
握手2次不能保证双发发送、接受信息都正常。  
实际应用中，**2、3两步合并了，所以最终就只有三次握手**。

### DDoS攻击
[传输层DDoS攻击主要包括Syn Flood、Ack Flood、UDP Flood、ICMP Flood、RstFlood等](https://help.aliyun.com/document_detail/28401.html)

#### Syn Flood/syn洪水攻击
[参考](https://cloud.tencent.com/developer/article/1802453)

服务端接收到 SYN包 后，会回复一个 SYN+ACK包 给客户端，然后等待客户端回复一个 ACK包。如果此时客户端并不会回复 ACK包，那服务端只能一直等待直到超时。服务端超时后，会重发 SYN+ACK包 给客户端，默认会重试 5 次，而且每次等待的时间都会增加（可以参考 TCP 协议超时重传的实现）。

另外，当服务端接收到 SYN包 后，会建立一个半连接状态的 Socket。所以，当**客户端一直发送 SYN包，但不回复 ACK包，那么将会耗尽服务端的资源，这就是 SYN Flood 攻击**。


## 四次挥手
刚开始双方都处于 **establised** 状态  
1. Client发送一个FIN，包含一个序列号，用来关闭Client到Server的数据传送，Client进入**FIN_WAIT_1**状态。  
2. Server收到FIN后，发送一个ACK给Client，确认序号为u + 1（与SYN相同，一个FIN占用一个序号），Server进入**CLOSE_WAIT**状态，Client进入**FIN_WAIT_2**状。  
3. Server发送一个FIN，包含一个序列号w，用来关闭Server到Client的数据传送，Server进入**LAST_ACK**状态。  
4. Client收到FIN后，Client进入**TIME_WAIT状态(主动关闭方才会进入该状态）**，接着发送一个ACK给Server，确认序号为w + 1，Server进入**CLOSED**状态，Client 需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态。

![](https://ask.qcloudimg.com/http-save/yehe-1446775/ok7sodrcza.png?imageView2/2/w/1620)


关闭连接时，服务端未必把全部数据都发给了对方，所以我们可以立即close，也可以发送一些数据给对方后，再发送FIN报文给对方表示同意关闭连接。
因此我们的**ACK和FIN一般会分开发送**。  

ACK—表明确认序号是有效的  
SYN—初始化连接的同步序号  
FIN—意味着发送端已经完成数据的传输

###  为什么 TIME_WAIT 状态需要经过 2MSL 才能返回到 CLOSE 状态
>MSL（Maximum Segment Lifetime）是报文的最大生存时间，它是任何报文段被丢弃前在网络内的最长时间。  

1. 确保对方收到自己发送的最后一个ACK（因为对方发送了FIN）  
  如果在1个MSL时间内自己发送的ACK对方没有收到那就注定收不到了，而且对方肯定还会发送FIN，那么一个FIN发送过来的最长时间也是1个MSL，所以这里要等待2MSL。
2. 保证让迟来的TCP报文段有足够的时间被识别并丢弃，为使旧的数据包在网络因过期而消失。

[参考](https://www.cnblogs.com/rexcheny/p/11143128.html)

# TCP/IP协议、长连接与短连接
HTTP 没有长短链接，只有 TCP 有，TCP 长连接可以复用一个 TCP 链接来发起多次 HTTP 请求，这样可以减少资源消耗，比如一次请求 HTML，可能还需要请求后续的 JS/CSS/图片等  
 
TCP 的 keep-alive 保活计时器（keepalive timer）包含三个参数，支持在系统内核的 net.ipv4 里面设置
- 当 TCP 链接之后，闲置了 tcp_keepalive_time，则会发生侦测包（探测报文段）
- 如果没有收到对方的 ACK，那么会每隔 tcp_keepalive_intvl 再发一次
- 直到发送了 tcp_keepalive_probes 数量的探测报文段后，就会丢弃该链接

## 一条TCP连接上可以发多少个HTTP请求
https://cloud.tencent.com/developer/article/1526057  
如果维持连接的话，一个 TCP 连接是可以发送多个 HTTP 请求的。  
HTTP/1.1 存在 Pipelining 技术可以完成这个多个请求同时发送，但是由于浏览器默认关闭，所以可以认为这是不可行的。

在 HTTP/2.0 中由于 Multiplexing 特点的存在，多个 HTTP 请求可以在同一个 TCP 连接中并行进行。

## HTTP/1.1 浏览器是如何提高页面加载效率的
- 维持和服务器已经建立的 TCP 连接，在同一连接上顺序处理多个请求。
- 和服务器建立多个 TCP 连接。


# 拥塞控制
[参考](https://blog.csdn.net/qq_48508278/article/details/122655792)

通信子网负荷比较小时，当网络负荷增加到某一值后，若网络吞吐量反而下降，则表征网络中出现了**拥塞现象**。   
此时发送的数据包会因为延迟无法到达接收端，因为超时重传机制所以发送端会重新发送数据包，那么网络带宽中本来就很拥塞，那么的话再发数据包就会更加拥塞，由此会形成恶性循环，如果不加控制的话，那么最终网络的有效吞吐量将接近为0.

### RTT(Round-Trip Time)
往返时延。  
在计算机网络中它是一个重要的性能指标，表示从发送端发送数据开始，到发送端收到来自接收端的确认（接收端收到数据后便立即发送确认），总共经历的时延。  
往返延时(RTT)由三个部分决定：即**链路的传播时间**、**末端系统的处理时间**以及**路由器的缓存中的排队和处理时间**。  
其中，前面两个部分的值作为一个TCP连接相对固定，路由器的缓存中的排队和处理时间会随着整个网络拥塞程度的变化而变化。  
所以RTT的变化在一定程度上反映了网络拥塞程度的变化。
![图](https://img2020.cnblogs.com/blog/2250171/202101/2250171-20210116165847370-858092000.png)

## 拥塞避免
TCP 主要维护两个核心状态
- 拥塞窗口（cwnd）：在发送端使用拥塞窗口来控制发送窗口的大小。
- 慢启动阈值（ssthresh）：采用一种比较保守的慢启动算法来慢慢适应这个网络，在开始传输的一段时间，发送端和接收端会首先通过三次握手建立连接，确定各自接收窗口大小，然后初始化双方的拥塞窗口，接着每经过一轮 RTT（收发时延），拥塞窗口大小**指数增长**，直到达到慢启动阈值。

## 快速重传 
TCP 传输过程中，如果发生了丢包，接收端就会发送之前重复 ACK。  
比如 第 5 个包丢了，6、7 达到，然后接收端会为 5，6，7 都发送第四个包的 ACK，这个时候发送端受到了 3 个重复的 ACK，意识到丢包了，就会马上进行重传，而不用等到 RTO （超时重传的时间）。

选择性重传：报文首部可选性中加入 SACK 属性，通过 left edge 和 right edge 标志那些包到了，然后重传没到的包。

## 快速恢复
如果发送端收到了 3 个重复的 ACK，发现了丢包，觉得现在的网络状况已经进入拥塞状态了，那么就会进入快速恢复阶段：
1. 会将拥塞阈值降低为 **拥塞窗口的一半**
2. 然后拥塞窗口大小变为拥塞阈值
3. 接着 拥塞窗口再进行**线性增加**，以适应网络状况

>慢启动不慢，是说初始值小；快恢复不快，是说初始值大

```
快速重传和快速恢复（fast retransmit and recovery，FRR）算法一般同时使用。
快速恢复算法是认为，你还有3个Duplicated Acks说明网络也不那么糟糕，所以没有必要像RTO超时那么强烈，并不需要重新回到慢启动进行，这样可能降低效率。

所以协议栈会做如下工作:

cwnd = cwnd/2
sshthresh = cwnd

然后启动快速恢复算法：
设置cwnd = ssthresh＋ACK个数＊MSS（一般情况下会是3个dup ACK）
重传丢失的数据包（对于重传丢失的那个数据包，可以参考TCP-IP详解：SACK选项）
如果只收到Dup ACK，那么cwnd = cwnd + 1， 并且在允许的条件下发送一个报文段
如果收到新的ACK, 设置cwnd = ssthresh， 进入拥塞避免阶段

```

### Karn算法
是为了更好的计算RTO（超时重传的时间）

比如：发送端发出一个报文段，并且设定的超时时间到了，还没有收到确认，于是重传报文段，经过了一段时间后，收到了报文段，现在的问题是：如何判定此确认报文段**是对先发送的报文段的确认，还是对后来重传的报文段的确认**？  
由于重传的报文段与原先的报文段完全一样，因此源主机在收到确认后就无法做出正确的判断，而正确的判断对确定**平滑的往返时间SRTT**的关系很大。

根据以上所述，Karn提出了一个算法：SRTT时，只要报文段重传了，就不采用其往返时间RTT（Round Trip Time）样本。

但是这有引起新的问题。其他因素比如网络闪动，突然变慢了，产生了比较大的延时，导致要重转所有的包（因为之前的 RTO 很小），但是根据Karn算法，不考虑重传的报文段的往返时间RTT样本。因此，超时重传时间RTO就无法更新。

因此考虑对Karn算法进行修正。方法是：报文段每重传一次，就把超时重传时间RTO增大一些。典型的做法是取新的重传时间为2倍的就得重传时间。当不再发生报文段的重传时，才根据正常的计算方法计算RTO。



# TCP协议中的窗口机制--滑动窗口 Sliding window
https://blog.csdn.net/m0_37962600/article/details/79951780  
早期的网络通信中，通信双方不会考虑网络的拥挤情况直接发送数据。由于大家不知道网络拥塞状况，同时发送数据，导致中间节点阻塞掉包，谁也发不了数据，所以就有了滑动窗口机制来解决此问题。  
TCP 利用滑动窗口实现流量控制的机制。  

流量控制是为了控制发送方发送速率，保证接收方来得及接收。接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。

滑动窗口的大小意味着接收方还有多大的缓冲区可以用于接收数据。发送方可以通过滑动窗口的大小来确定应该发送多少字节的数据。当滑动窗口为 0 时，发送方一般不能再发送数据报。

有两种情况除外，一种情况是可以发送紧急数据，例如，允许用户终止在远端机上的运行进程。  
另一种情况是发送方可以发送一个 1 字节的数据报来通知接收方重新声明它希望接收的下一字节及发送方的滑动窗口大小。


#TCP 如何解决流控、乱序、丢包问题

# 粘包和拆包
如果客户端连续不断的向服务端发送数据包时，服务端接收的数据会出现两个数据包粘在一起的情况。

一个数据包中包含了发送端发送的两个数据包的信息，这种现象即为粘包。

接收端收到了两个数据包，但是这两个数据包要么是不完整的，要么就是多出来一块，这种情况即发生了拆包和粘包。拆包和粘包的问题导致接收端在处理的时候会非常困难，因为无法区分一个完整的数据包。

## 为什么会出现粘包和拆包
https://blog.csdn.net/v123411739/article/details/99708892
- 发送方产生粘包
采用 TCP 协议传输数据的客户端与服务器经常是保持一个长连接的状态（一次连接发一次数据不存在粘包），双方在连接不断开的情况下，可以一直传输数据。  
但当发送的数据包过于的小时，那么 TCP 协议默认的会启用**Nagle 算法**，将这些较小的数据包进行**合并发送**（缓冲区数据发送是一个堆压的过程）；这个合并过程就是在发送缓冲区中进行的，也就是说数据发送出来它已经是粘包的状态了。  

- 接收方产生粘包
接收方采用 TCP 协议接收数据时的过程是这样的：数据到接收方，从网络模型的下方传递至传输层，传输层的 TCP 协议处理是将其放置接收缓冲区，然后由应用层来主动获取（C 语言用 recv、read 等函数）。  
这时会出现一个问题，就是我们在程序中调用的读取数据函数不能及时的把缓冲区中的数据拿出来，而下一个数据又到来并有一部分放入的缓冲区末尾，等我们读取数据时就是一个粘包。（放数据的速度 > 应用层拿数据速度）。

## 怎么解决拆包和粘包
- 在包头首都添加数据包的长度。

- 发送定长的数据包；
- 特殊字符作为边界；
- 自定义消息结构或规则。

- 发送方关闭Nagle算法，使用TCP_NODELAY选项关闭Nagle功能

使用 netty 的话，就有专门的编码器和解码器解决拆包和粘包问题。

ps:UDP 没有粘包问题，但是有丢包和乱序。不完整的包是不会有的，收到的都是完全正确的包。传送的数据单位协议是 UDP 报文或用户数据报，发送的时候既不合并，也不拆分。


# 套接字函数调用
![图](https://img-blog.csdn.net/2018041116433571?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dvZG9w/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
accept函数实际上是在三次握手之后，给连接分配资源

# TCP的端口有多少个
TCP端口号是大小为16bit的无符号整数。所以不能超过65535。

有些软件，比方说Windows的 Telnet ，可能用了32 bit的数据类型记录port ，这样port表面上看到是可以超过65535，但是tcp header明确定义了tcpport为16bit，那即便某些应用程序使用了32bit的数据类型，最终结果也是被强制转换。
> 如 telnet xxxx 65616，实际上是访问 xxxx 的80端口，65616-65536=80

当调用了系统的tcp/ip通讯之后，系统底层强制将大于65536的端口转换回正常范围。

# QUIC 协议
Quick UDP Internet Connections  
是一种基于 UDP 的传输层协议。与 TCP 相比，QUIC 可以减少延迟。

 QUIC 是如何实现可靠传输的呢？

## 可靠传输
- 完整性：发送端发出的数据包，接收端都能收到  
通过包号（PKN）和确认应答（SACK）

- 有序性：接收端能按序组装数据包，解码得到有效的数据
https://zhuanlan.zhihu.com/p/405387352

https://www.cnblogs.com/imteck4713/p/11777310.html
