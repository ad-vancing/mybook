[Data Structure Visualizations](https://www.cs.usfca.edu/~galles/visualization/Algorithms.html)

[OI Wiki ](https://oi-wiki.org/ds/)

https://github.com/liuyubobobo/Play-with-Algorithms

入门：《大话数据结构》和《算法图解》

基础：《数据结构和算法分析》三个语言版本

益于面试的书籍，分别是：《剑指 offer》《编程珠玑》  
《编程之美》（面试 Google、Facebook 这样的公司，可以拿这本书里的题，先来自测一下）

![](https://pic3.zhimg.com/v2-f221b3de2a863b53ef0cb75fec879d72_r.jpg)

# 常用的数据结构
数组（Array）
队列（Queue）
链表（Linked List）
栈（Stack）
树（Tree）
散列表（Hash）
堆（Heap）
图（Graph）

跳表 skip list ，其实就是一种可以进行二分查找的有序链表。

#时间复杂度
https://zhuanlan.zhihu.com/p/50479555
算法的时间复杂度是一个函数，它定性描述了该算法的运行时间。描述一个算法在问题规模不断增大时对应的时间增长曲线。
是一个代表算法输入值的字符串的长度的函数，常用大O符号表述，不包括这个函数的低阶项和首项系数。
例如，如果一个算法对于任何大小为 n （必须比 n0 大）的输入，它至多需要 5n^3 + 3n 的时间运行完毕，那么它的渐近时间复杂度是 O(n^3)。
O(n²)：算法复杂度和问题规模是平方关系。换句话说，算法复杂度随着问题规模以平方关系迅速增长。
O(n)：算法复杂度和问题规模是线性关系。换句话说，数据量大K倍，消耗时间/空间就大致增加K倍。
O(1)：算法复杂度和问题规模无关。
O(nlogn)：算法复杂度和问题规模比线性更大，但比平方更小。
O(logN)：算法复杂度和问题规模是对数关系。换句话说，数据量大幅增加时，消耗时间/空间只有少量增加（比如，当数据量从2增加到2^64时，消耗时间/空间只增加64倍）
 常见的算法时间复杂度由小到大依次为：Ο(1)＜Ο(logn)＜Ο(n)＜Ο(nlogn)＜Ο(n^2)＜Ο(n^3)＜…＜Ο(2^n)＜Ο(n!)

#空间复杂度
描述了算法执行所需要的临时空间随着某个变量n的大小而变化的空间增长曲线。
ps:
一般的递归算法就要有O(n)的空间复杂度了，因为每次递归都要存储返回信息。

磁盘IO跟内存打交道的单位是4K，一次可能读取4K的数据，可能有时候有一些局部读取的原理可能会取几十K（4的整数倍），取个16K，24K也是可以的 。


# 链表
链表支持插入和删除这两种操作，并且删除/插入链表头部/尾部结点的时间复杂度通常都是常数级别的，链表的不足在于不支持高效的random access（随机访问）。
## 单向链表 
Single-Linked List
每个节点只有一个指针的链表也叫单向链表，或者单链表，通常用在每次都只会按顺序遍历这个链表。
一个单向链表包含两个值: 当前节点的值和一个指向下一个节点的链接。

## 双向链表
Double-Linked List
不仅有指向后一个节点的指针，还有指向前一个节点的指针。这样可以从任何一个节点访问前一个节点，当然也可以访问后一个节点，以至整个链表。

## 循环链表
第一个节点之前就是最后一个节点，反之亦然。

# 堆
堆是一棵**树**，其每个节点都有一个键值，每个节点的键值都大于等于其父亲键值的堆叫做小根堆，否则叫做大根堆（堆排序）。  
堆并不等于完全二叉树，例如二项堆，斐波那契堆，就不属于二叉树。  

使用场景：对于一个随时会有更新的序列，我要随时知道这个序列的最小值或最大值是什么。

## 二叉堆 Binary Heap
它是一棵二叉树，并且是**完全二叉树**，每个结点中存有一个元素（或者说，有个权值）。

# 各种排序的稳定性，选择排序时间复杂度？最坏时间复杂度，举例最坏？
https://blog.csdn.net/Big_Rotor/article/details/97971263

# 不知道怎么归纳
[如何快速合并两个有序数组](https://zhuanlan.zhihu.com/p/388607076)

[找到出现次数大于n/2的元素]()

# 巧用位运算
[判断一个数是否为2的n次方](https://blog.csdn.net/wujingchangye/article/details/88601354)

# 递归大法
[安卓系统手势解锁](https://blog.csdn.net/qq_29051413/article/details/108616843)



# 智力题
1. 有100本书，每次可以拿1~5本。两个人比赛，谁最后拿到书谁就胜利，假设你先拿，怎么样才能赢？

2. 一天的时间中，时针、分针、秒针有多少次重合？   





## 智力题解
1. 如果A想赢，则倒数第二个人必然拿不完剩下的所有书，而且拿完之后必须剩下1-5本书。。所以应保证最后B拿的时候只剩下6本书，此时不管B拿1-5的任何数目的书，A都可把剩下的全部拿完。
   
   为了最后只剩下6本书，并且一定是轮到B拿，则必须A先拿4本书（100/6的余数为4），此后不管B拿1-5任何数目，A都拿6-B拿的数目，就能保证A必然拿到最后的书。
   
2. 只有在12点整的时候，12：00：00 有三针重合的情况，也就是一天之内两个12点整会出现三针重合的现象~
