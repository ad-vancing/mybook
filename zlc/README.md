[Data Structure Visualizations](https://www.cs.usfca.edu/~galles/visualization/Algorithms.html)

https://github.com/liuyubobobo/Play-with-Algorithms

# 常用的数据结构
数组（Array）
队列（Queue）
链表（Linked List）
栈（Stack）
树（Tree）
散列表（Hash）
堆（Heap）
图（Graph）

跳表 skip list ，其实就是一种可以进行二分查找的有序链表。

#时间复杂度
https://zhuanlan.zhihu.com/p/50479555
算法的时间复杂度是一个函数，它定性描述了该算法的运行时间。描述一个算法在问题规模不断增大时对应的时间增长曲线。
是一个代表算法输入值的字符串的长度的函数，常用大O符号表述，不包括这个函数的低阶项和首项系数。
例如，如果一个算法对于任何大小为 n （必须比 n0 大）的输入，它至多需要 5n^3 + 3n 的时间运行完毕，那么它的渐近时间复杂度是 O(n^3)。
O(n²)：算法复杂度和问题规模是平方关系。换句话说，算法复杂度随着问题规模以平方关系迅速增长。
O(n)：算法复杂度和问题规模是线性关系。换句话说，数据量大K倍，消耗时间/空间就大致增加K倍。
O(1)：算法复杂度和问题规模无关。
O(nlogn)：算法复杂度和问题规模比线性更大，但比平方更小。
O(logN)：算法复杂度和问题规模是对数关系。换句话说，数据量大幅增加时，消耗时间/空间只有少量增加（比如，当数据量从2增加到2^64时，消耗时间/空间只增加64倍）
 常见的算法时间复杂度由小到大依次为：Ο(1)＜Ο(logn)＜Ο(n)＜Ο(nlogn)＜Ο(n^2)＜Ο(n^3)＜…＜Ο(2^n)＜Ο(n!)

#空间复杂度
描述了算法执行所需要的临时空间随着某个变量n的大小而变化的空间增长曲线。
ps:
一般的递归算法就要有O(n)的空间复杂度了，因为每次递归都要存储返回信息。

磁盘IO跟内存打交道的单位是4K，一次可能读取4K的数据，可能有时候有一些局部读取的原理可能会取几十K（4的整数倍），取个16K，24K也是可以的 。


# 链表
链表支持插入和删除这两种操作，并且删除/插入链表头部/尾部结点的时间复杂度通常都是常数级别的，链表的不足在于不支持高效的random access（随机访问）。
###单向链表 
Single-Linked List
每个节点只有一个指针的链表也叫单向链表，或者单链表，通常用在每次都只会按顺序遍历这个链表。
一个单向链表包含两个值: 当前节点的值和一个指向下一个节点的链接。

###双向链表
Double-Linked List
不仅有指向后一个节点的指针，还有指向前一个节点的指针。这样可以从任何一个节点访问前一个节点，当然也可以访问后一个节点，以至整个链表。

###循环链表
第一个节点之前就是最后一个节点，反之亦然。

## 写一个链表公共节点查询

# 各种排序的稳定性，选择排序时间复杂度？最坏时间复杂度，举例最坏？
https://blog.csdn.net/Big_Rotor/article/details/97971263

# 不知道怎么归纳
[如何快速合并两个有序数组](https://zhuanlan.zhihu.com/p/388607076)

[找到出现次数大于n/2的元素]()

# 巧用位运算
[判断一个数是否为2的n次方](https://blog.csdn.net/wujingchangye/article/details/88601354)

# 递归大法
[安卓系统手势解锁](https://blog.csdn.net/qq_29051413/article/details/108616843)




